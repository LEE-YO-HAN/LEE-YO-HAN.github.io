<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Hanbbi<!-- -->&#x27;<!-- -->s DevLog</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="정보처리기사 필기(4) - 프로그래밍 언어 활용"/><meta name="keywords" content="sw, sw first test4, 정보처리기사, 정처기, 필기, 프로그래밍 언어 활용"/><meta http-equiv="title" content="정보처리기사 필기(4) - 프로그래밍 언어 활용"/><meta http-equiv="subject" content="sw"/><meta property="og:title" content="sw first test4"/><meta property="og:description" content="정보처리기사 필기(4) - 프로그래밍 언어 활용"/><meta property="og:image" content="/images/cards/SW.png"/><meta name="naver-site-verification" content="af9c8049662a7c6c85ea946e9eb561086e70062c"/><meta name="google-site-verification" content="Zgp7rA3RAdcRnhPPsGLK-t4KVTO86AejlDIQQIGpvLg"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4077287316160146" crossorigin="anonymous"></script><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="14"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/f9bc783e634631d2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f9bc783e634631d2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7d0bddee48749f95.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-b0c8bcfd40968c52.js" defer=""></script><script src="/_next/static/chunks/pages/_app-838d6642f093d3b7.js" defer=""></script><script src="/_next/static/chunks/235-2e07634c3cd78c71.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-d0432a4b187b0b46.js" defer=""></script><script src="/_next/static/pJ0C1SW6Dpnf8b5e1YSeC/_buildManifest.js" defer=""></script><script src="/_next/static/pJ0C1SW6Dpnf8b5e1YSeC/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-c845a976-0 icUnkm"><header class="sc-706d7e74-0 fRVbaU"><span style="display:none" class="sc-706d7e74-1 txrCx"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 17 17" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g></g><path d="M16 3v2h-15v-2h15zM1 10h15v-2h-15v2zM1 15h15v-2h-15v2z"></path></svg></span><h1><a href="/">Hanbbi<!-- -->&#x27;<!-- -->s DevLog</a></h1><nav style="transform:translateX(-100%)" class="sc-e9bb2eba-0 extUal"><div class="sc-e9bb2eba-1 eDAIOV"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M405 136.798L375.202 107 256 226.202 136.798 107 107 136.798 226.202 256 107 375.202 136.798 405 256 285.798 375.202 405 405 375.202 285.798 256z"></path></svg></div><ul class="sc-e9bb2eba-2 kjvNul"><div><p class="sc-e9bb2eba-3 bvmfTl">FE</p><li class="sc-e9bb2eba-4 bSVRxo"><a href="/html">HTML</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/css">CSS</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/javascript">JavaScript</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/typescript">TypeScript</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/redux">Redux</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/react">React</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/nextjs">Nextjs</a></li></div><div><p class="sc-e9bb2eba-3 bvmfTl">BE</p><li class="sc-e9bb2eba-4 bSVRxo"><a href="/nestjs">Nestjs</a></li></div><div><p class="sc-e9bb2eba-3 bvmfTl">CS</p><li class="sc-e9bb2eba-4 bSVRxo"><a style="color:white;font-weight:bold" href="/sw">정보처리기사</a></li></div><div><p class="sc-e9bb2eba-3 bvmfTl">ETC</p><li class="sc-e9bb2eba-4 bSVRxo"><a href="/github">Simple Memo</a></li></div></ul></nav></header><section class="sc-c845a976-1 bePtAz"><aside class="sc-226f6af7-0 jzKfYm"><div class="sc-226f6af7-1 eudLNA"><a target="_blank" href="https://portfolio-sigma-wheat-63.vercel.app/"><img alt="profile" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" src="/images/profileImage/cat.png"/><span>Go Profile!</span></a><p>Hanbbi</p></div><div class="sc-226f6af7-2 fEJwOM"><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0 0 68.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"></path></svg><span>yhl0078@gmail.com</span></a><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>Github</span></a></div></aside><article class="sc-c845a976-2 jRRSKe"><main class="sc-39211eb-0 hLWqGG"><section class="sc-39211eb-1 cLKxEH"><p>정보처리기사</p><h1>정보처리기사 필기(4) - 프로그래밍 언어 활용</h1><span>2023-12-27</span></section><main class="sc-39211eb-2 kPnWiO"><div class="markdown"><h2>필기 시험 공략</h2>
<p>개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.</p>
<p>구글 앱 스토어에서 &quot;<strong>정보처리기출문제</strong>&quot;라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.</p>
<p>나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.</p>
<p>표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.</p>
<ol>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84">소프트웨어 설계</a></p>
</li>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C">소프트웨어 개발</a></p>
</li>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95">DB구축</a></p>
</li>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9">프로그래밍 언어 활용</a></p>
</li>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC">정보시스템 구축 관리</a></p>
</li>
</ol>
<p>본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.</p>
<hr/>
<h1>모듈화와 결합도/응집도 ★★★</h1>
<h3>모듈화</h3>
<ul>
<li>모듈화는, 거대한 문제를 작은 조각의 문제로 나누어 다루기 쉽도록 하는 과정으로, 작게 나누어진 각 부분을 모듈이라고 한다.</li>
<li>소프트웨어의 모듈은 프로그래밍 언어에서 Subroutine, Function 등으로 표현될 수 있다.</li>
<li>모듈화는 시스템을 지능적으로 관리할 수 있도록 해주며, 복잡도 문제를 해결하는데 도움을 준다.</li>
<li>모듈화는 시스템의 유지보수와 수정을 용이하게 한다.</li>
</ul>
<h4>모듈의 개념</h4>
<ul>
<li>하나의 프로그램을 몇 개의 작은 부분으로 분할한 단위이다.</li>
<li>모듈의 독립성은 결합도와 응집도에 의해 측정된다.</li>
<li>각 모듈은 논리적 또는 기능적으로 분리되어 격리되고 독립적인 일을 수행한다.</li>
<li>특성 : Unity(한 가지 일만 수행), Smallness(간단 명료), Simplicity(단순성), Independency(독십성) 등</li>
</ul>
<h3>결합도(Coupling)</h3>
<ul>
<li>
<p>한 모듈과 다른 모듈 간의 상호 의존도 또는 두 모듈 사이의 연관 관계를 의미한다.</p>
</li>
<li>
<p>모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상된다.</p>
</li>
<li>
<p>인터페이스가 정확히 설정되어 있지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도는 높아지고 결합도가 증가한다.</p>
</li>
<li>
<p>다른 모듈과 데이터 교류가 필요한 경우 전역 변수(Global Variable)보다는 매개 변수(Parameter)를 사용하는 것이 결합도를 낮추는데 도움이 된다.</p>
</li>
<li>
<p>결합도 정도 : 데이터 결합도 &lt; 스탬프 결합도 &lt; 제어 결합도 &lt; 외부 결합도 &lt; 공통 결합도 &lt; 내용 결합도</p>
</li>
<li>
<p>데이터 결합도(Data Coupling)</p>
<ul>
<li>한 모듈이 파라미터나 인수로 다른 모듈에 데이터를 넘겨주고 호출받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 경우의 결합도.</li>
</ul>
</li>
<li>
<p>스탬프 결합도(Stamp Coupling)</p>
<ul>
<li>두 모듈이 동일한 자료 구조를 조회하는 경우의 결하볻</li>
</ul>
</li>
<li>
<p>제어 결합도(Control Coupling)</p>
<ul>
<li>한 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우의 결합도</li>
</ul>
</li>
<li>
<p>외부 결합도(External Coupling)</p>
<ul>
<li>한 모듈에서 외부로 선언한 변수를 다른 모듈에서 참조할 경우의 결합도</li>
</ul>
</li>
<li>
<p>공통 결합도(Common Coupling)</p>
<ul>
<li>한 모듈이 다른 모듈에 제어 요소를 전달하고 여러 모듈이 공통 자료 영역을 사용하는 경우의 결합도</li>
</ul>
</li>
<li>
<p>내용 결합도(Content Coupling)</p>
<ul>
<li>한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도</li>
</ul>
</li>
</ul>
<h3>응집도(Cohesion)</h3>
<ul>
<li>
<p>한 모듈 내부의 처리 요소 간의 기능적 연관도를 의미한다.</p>
</li>
<li>
<p>모듈 내부 요소는 명령어, 명령어의 모임, 호출문, 특정 작업 수행 코드 등이다.</p>
</li>
<li>
<p>응집도 정도 : 기능적 응집도 &gt; 순차적 응집도 &gt; 교환적 응집도 &gt; 절차적 응집도 &gt; 시간적 응집도 &gt; 논리적 응집도 &gt; 우연적 응집도</p>
</li>
<li>
<p>기능적 응집도(Functional Cohesion)</p>
<ul>
<li>한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로써 제공되는 경우의 응집도</li>
</ul>
</li>
<li>
<p>순차적 응집도(Sequential Cohesion)</p>
<ul>
<li>모듈의 구성 요소가 하나의 활동으로부터 나온 출력 자료를 그다음 활동의 입력 자료로 사용하는 같은 모듈 내에서의 응집도</li>
</ul>
</li>
<li>
<p>교환적 응집도(Communicational Cohesion)</p>
<ul>
<li>동일한 입력과 출력을 사용하는 소 작업들이 모인 모듈에서 볼 수 있는 응집도.</li>
</ul>
</li>
<li>
<p>절차적 응집도(Procedural Cohesion)</p>
<ul>
<li>모듈이 다수의 관련 기능을 가질 때 모듈 내부의 기능 요소들이 그 기능을 순차적으로 수행할 경우의 응집도</li>
</ul>
</li>
<li>
<p>시간적 응집도(Temporal Cohesion)</p>
<ul>
<li>특정 시간에 처리되는 여러 기능을 모아 한 개의 모듈로 작성할 경우의 응집도</li>
</ul>
</li>
<li>
<p>논리적 응집도(Logical Cohesion)</p>
<ul>
<li>유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도</li>
</ul>
</li>
<li>
<p>우연적 응집도(Coincidental Cohesion)</p>
<ul>
<li>서로 간에 어떠한 의미 있는 연관 관계도 지니지 않은 기능 요소로 구성되는 경우의 응집도</li>
</ul>
</li>
</ul>
<h3>효과적인 모듈화 설계 방법</h3>
<ul>
<li>응집도는 강하게, 결합도는 약하게 설계한다.</li>
<li>복잡도와 중복성을 줄이고 일관성을 유지할 수 있도록 설계한다.</li>
<li>유지보수가 용이하도록 설계한다.</li>
<li>모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 설계한다.</li>
<li>모듈 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.</li>
</ul>
<h1>C 언어</h1>
<h3>C언어의 기본 구조</h3>
<ul>
<li>main 함수를 반드시 포함해야 하며, main 함수에서 실행이 시작된다.</li>
<li>영문 대/소문자를 엄격하게 구별한다.</li>
<li>문장을 끝마칠 때는 세미콜론(;)을 사용한다.</li>
<li>여러 개의 문장을 묶어 하나의 블록으로 구성할 때 중괄호({})를 사용한다.</li>
<li>주석문은 /_ ~ _/로 표기한다.</li>
</ul>
<h3>기본 자료형</h3>
<table><thead><tr><th style="text-align:center">자료형</th><th style="text-align:center">예약어</th><th style="text-align:center">크기</th></tr></thead><tbody><tr><td style="text-align:center">정수형</td><td style="text-align:center">int</td><td style="text-align:center">2Byte</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">long</td><td style="text-align:center">4Byte</td></tr><tr><td style="text-align:center">실수형</td><td style="text-align:center">float</td><td style="text-align:center">4Byte</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">double</td><td style="text-align:center">8Byte</td></tr><tr><td style="text-align:center">문자형</td><td style="text-align:center">char</td><td style="text-align:center">1Byte</td></tr></tbody></table>
<h3>입/출력 함수</h3>
<ul>
<li>표준 입/출력 함수<!-- -->
<ul>
<li>scanf() : 표준 입력 함수</li>
<li>printf() : 표준 출력 함수</li>
<li>getchar() : 문자 입력 함수</li>
<li>putchar() : 문자 출력 함수</li>
<li>gets() : 문자열 입력 함수</li>
<li>puts() : 문자열 출력 함수</li>
</ul>
</li>
<li>변환 문자(출력 형식 지정 문자)<!-- -->
<ul>
<li>%d : 10진 정수</li>
<li>%o : 8진 정수</li>
<li>%x : 16진 정수</li>
<li>%f : 실수형</li>
<li>%e : 지수형</li>
<li>%c : 문자</li>
<li>%s : 문자열</li>
</ul>
</li>
</ul>
<h3>탈출문(Escape Sequence)</h3>
<table><thead><tr><th style="text-align:center">문자</th><th style="text-align:center">의미</th><th style="text-align:center">기능</th></tr></thead><tbody><tr><td style="text-align:center">\n</td><td style="text-align:center">new line</td><td style="text-align:center">커서를 다음 줄 처음으로 이동한다.</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">carriage return</td><td style="text-align:center">커서를 현재 줄 처음으로 이동한다.</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">tab</td><td style="text-align:center">커서를 일정 간격만큼 띄운다.</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">backspace</td><td style="text-align:center">커서를 뒤로 한 칸 이동한다.</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">form feed</td><td style="text-align:center">한 페이지를 넘긴다.</td></tr><tr><td style="text-align:center">\0</td><td style="text-align:center">null character</td><td style="text-align:center">널 문자를 출력한다.</td></tr><tr><td style="text-align:center">&#x27;</td><td style="text-align:center">single quote</td><td style="text-align:center">작은 따옴표를 출력한다.</td></tr><tr><td style="text-align:center">&quot;</td><td style="text-align:center">double quote</td><td style="text-align:center">큰따옴표를 출력한다.</td></tr><tr><td style="text-align:center">\ \</td><td style="text-align:center">backslash</td><td style="text-align:center">역슬래시를 출력한다.</td></tr><tr><td style="text-align:center">\a</td><td style="text-align:center">alert</td><td style="text-align:center">벨 소리를 발생한다.</td></tr></tbody></table>
<h3>C언어 변수명 작성 규칙</h3>
<ul>
<li>영문 대소문자(A<del>Z, a</del>z), 숫자(0~9), &#x27;_&#x27;를 혼용하여 사용할 수 있다.</li>
<li>첫 글자는 숫자로 시작할 수 없고, 영문자나 &quot;_&quot;로 시작해야 한다.</li>
<li>영문자는 대소문자를 구분한다.</li>
<li>공백을 포함할 수 없다.</li>
<li>auto, beak, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register,return, short, signed, sizeof, static, struct, switch, typedef, union, unsigend, void, volatile, while 32개 예약어(Reserved Word)를 사용할 수 없다.</li>
</ul>
<h3>포인터 변수</h3>
<ul>
<li>다른 변수의 주소값을 저장할 수 있다.</li>
<li>표인터 변수는 자료형에 상관없이 메모리 크기가 동일하다.</li>
<li>가리키고 있는 변수값을 읽기 위해서는 포인터 연산자를 사용한다.</li>
<li>포인터 변수에 일반 변수의 주소를 대입하기 위해서는 &amp;(주소) 연산자를 사용한다.</li>
<li>포인터 변수를 가리키는 포인터 변수를 선언할 수 있다.</li>
</ul>
<h3>표준 라이브러리 함수</h3>
<ul>
<li>stdio.h : C언어의 표준 입/출력 라이브러리(Standard Input and Output Library)이다.</li>
<li>stdlib.h : C 표준 유틸리티 함수를 모아놓은 헤더 파일이다. 문자형 변환, 수치를 문자형으로 변환, 동적 할당 관련 함수, 난수 생성 함수, 정수의 연산 함수, 검색 및 정렬 함수 등이다.</li>
<li>stdlib.h 함수 종류<!-- -->
<ul>
<li>atoi() : 문자열을 정수형으로 변환</li>
<li>atof() : 문자열을 실수형으로 변환</li>
<li>atol() : 문자열을 log형 정수로 변환</li>
<li>itoa() : 숫자를 문자열로 변환</li>
<li>ceil() : 자리 올림</li>
<li>floor() : 자리 버림</li>
<li>rand() : 난수 발생</li>
<li>div() : 정수 나눗셈</li>
</ul>
</li>
</ul>
<h3>C언어 연산자의 특징</h3>
<h4>단항 연산자</h4>
<ul>
<li>! : 부정(NOT)</li>
<li>~ : 1의 보수(0-&gt;1, 1-&gt;0)를 구한다.</li>
<li>++ : 1씩 증가를 의미한다.</li>
<li>-- : 1씩 감소를 의미한다.</li>
<li>&amp; : 변수의 주소를 의미한다.</li>
<li>* : 변수의 내용을 의미한다.</li>
<li>sizeof : 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구한다.</li>
</ul>
<h4>산술 연산자</h4>
<ul>
<li>이항 연산자는 +, -는 *, /, % 보다 우선순위가 낮다.</li>
<li>% : 정수 나눗셈 연산 후 나머지를 구한다.</li>
</ul>
<h4>시프트(Shift) 연산자</h4>
<ul>
<li>&lt;&lt;는 비트를 왼쪽으로 이동시킨다.</li>
<li>&gt;&gt;는 비트를 오른쪽으로 이동시킨다.</li>
</ul>
<h4>관계 연산자</h4>
<ul>
<li>&lt; : ~보다 작다.</li>
<li>&gt; : ~보다 크다.</li>
<li>&lt;= : ~보다 작거나 같다.</li>
<li>&gt;\ : ~보다 크거나 같다.</li>
<li>== : ~와 같다.</li>
<li>!= : ~와 같지 않다.</li>
</ul>
<h4>비트 연산자</h4>
<ul>
<li>&amp; : 논리곱(AND)</li>
<li>| : 논리합(OR)</li>
<li>^ : 배타적 논리합(XOR)</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-C" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>
</span>#include &lt;stdio.h&gt;
<!-- -->int main(int argc, char *argv[]) {
<!-- -->    int a = 4;
<!-- -->    int b = 7;
<!-- -->    int c = a|b;
<!-- -->    printf(&quot;%d&quot;, c);
<!-- -->    return 0;
<!-- -->}
<!-- -->// 1. 변수 a와 b의 4, 7을 (2진수)비트 연산자 |(OR)로 연산한다.
<!-- -->// 2. 비트 연산자는 2진수로 변환 후 계산한다.
<!-- -->// 3. OR 연산자는 두 비트 중 1개라도 1이면 1이 출력된다.
<!-- -->//     0100 (10진수: 4)
<!-- -->// OR  0111 (10진수: 7)
<!-- -->// =   0111(둘 중 1개라도 1이면 1이기 때문에 10진수: 7)
<!-- -->// 4. 0111는 &quot;%d&quot; 출력 형식 지정 문자에 의해 10진수로 변환하면 7이 되어 출력된다.
<!-- -->//
<!-- -->// 2와 5를 가정할때
<!-- -->//     0010
<!-- -->// OR  0101
<!-- -->// =   0111
</code></pre></pre>
<h4>논리 연산자</h4>
<ul>
<li>! : 논리 부정(NOT)</li>
<li>&amp;&amp; : 논리곱(AND)</li>
<li>|| : 논리합(OR)</li>
</ul>
<h4>조건 연산자</h4>
<ul>
<li>C언어에서 유일하게 3개의 피연산자를 갖는 삼항 연산자이다.</li>
<li>조건식 ? 참일 경우 값 : 거짓일 경우 값</li>
<li>ex. big = a &gt; b ? a:b; -&gt; a와 b 중에서 큰 수가 big에 저장됨</li>
</ul>
<h1>Java 언어</h1>
<ul>
<li>객체지향 언어이다.</li>
<li>추상화, 상속화, 다형성과 같은 특징을 가진다.</li>
<li>네트워크 환경에서 분산 작업이 가능하도록 설계되었다.</li>
<li>특정 컴퓨터 구조와 무관한 가상 바이트 머신 코드를 사용하므로 플랫폼이 독립적이다.</li>
</ul>
<h3>Garbage Collector</h3>
<ul>
<li>S/W 개발 중 유효하지 않은 가비지 메모리가 발생한다. Java에서는 C언어와 달리 JVM 가비지 컬렉터가 불필요 메모리를 알아서 정리해준다.</li>
</ul>
<h3>Java 언어의 기본 자료형</h3>
<table><thead><tr><th style="text-align:center">분류</th><th style="text-align:center">예약어</th><th style="text-align:center">바이트 수</th><th style="text-align:center">비고</th></tr></thead><tbody><tr><td style="text-align:center">정수형</td><td style="text-align:center">byte</td><td style="text-align:center">1byte</td><td style="text-align:center">-127 ~ +128</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">short</td><td style="text-align:center">2byte</td><td style="text-align:center">-32,768 ~ +32,767</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">int</td><td style="text-align:center">4byte</td><td style="text-align:center">-2,147,483,648 ~ +2,147,483,648</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">long</td><td style="text-align:center">8byte</td><td style="text-align:center">-9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,808</td></tr><tr><td style="text-align:center">실수형</td><td style="text-align:center">float</td><td style="text-align:center">4byte</td><td style="text-align:center">단정도 실수형 (유효 자리는 7정도임)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">double</td><td style="text-align:center">8byte</td><td style="text-align:center">배정도 실수형 (유효 자리는 15정도)</td></tr><tr><td style="text-align:center">문자형</td><td style="text-align:center">char</td><td style="text-align:center">2byte</td><td style="text-align:center">유니코드 문자열 1자</td></tr><tr><td style="text-align:center">논리형</td><td style="text-align:center">boolean</td><td style="text-align:center">1byte</td><td style="text-align:center">true,false</td></tr></tbody></table>
<h3>이스케이프 시퀀스(Escape Sequence)</h3>
<table><thead><tr><th style="text-align:center">문자</th><th style="text-align:center">의미</th><th style="text-align:center">기능</th></tr></thead><tbody><tr><td style="text-align:center">\n</td><td style="text-align:center">new line</td><td style="text-align:center">커서를 다음 줄 처음으로 이동한다.</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">carriage return</td><td style="text-align:center">커서를 현재 줄 처음으로 이동한다.</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">tab</td><td style="text-align:center">커서를 일정 간격만큼 띄운다.</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">backspace</td><td style="text-align:center">커서를 뒤로 한 칸 이동한다.</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">form feed</td><td style="text-align:center">한 페이지 넘긴다.</td></tr><tr><td style="text-align:center">&#x27;</td><td style="text-align:center">single quote</td><td style="text-align:center">작은따옴표를 출력한다.</td></tr><tr><td style="text-align:center">&quot;</td><td style="text-align:center">double quote</td><td style="text-align:center">큰따옴표를 출력한다.</td></tr><tr><td style="text-align:center">\ \</td><td style="text-align:center">backslash</td><td style="text-align:center">역슬래시를 출력한다.</td></tr></tbody></table>
<h3>Java 접근 제한자(접근 제어자)</h3>
<ul>
<li>public : 모든 접근을 허용한다.</li>
<li>private : 같은 패키지에 있는 객체와 상속 관계의 객체들만 허용한다.</li>
<li>default : 같은 패키지에 있는 객체들만 허용한다.</li>
<li>protected : 현재 객체 내에서만 허용한다.</li>
</ul>
<h3>Java의 출력 함수</h3>
<ul>
<li>System.out.print() : 괄호 안을 출력하고 줄 바꿈을 안 한다.</li>
<li>System.out.printIn() : 괄호 안을 출력하고 줄 바꿈을 한다.</li>
<li>System.out.printf() : 변환 문자를 사용하여 출력한다.</li>
<li>변환 문자(출력 형식 지정 문자)</li>
<li>%d : 10진 정수</li>
<li>%o : 8진 정수</li>
<li>%x : 16진 정수</li>
<li>%f : 실수형</li>
<li>%e : 지수형</li>
<li>%c : 문자</li>
<li>%s : 문자열</li>
</ul>
<h3>Java 언어 변수명 작성 규칙</h3>
<ul>
<li>영문 대소문자(A<del>Z, a</del>z), 숫자(0~9), &#x27;_&#x27;, &#x27;$&#x27;를 혼용하여 사용할 수 있다.</li>
<li>첫 글자는 영문자나 &#x27;_&#x27;, &#x27;$&#x27;로 시작해야 한다.</li>
<li>영문자는 대소문자를 구분한다.</li>
<li>공백을 포함할 수 없다.</li>
<li>예약어(Reserved Word)를 사용할 수 없다.</li>
</ul>
<h3>오버로딩(Overloading)과 오버라이딩(Overiding)</h3>
<h4>오버로딩(Overloading - 과적, 과부하)</h4>
<ul>
<li>한 클래스 내에서 같은 메서드를 사용하는 것이다.</li>
<li>같은 이름의 메서드를 여러 개 정의하면서 매개 변수의 유형과 개수가 달라지도록 하는 기술이다.</li>
</ul>
<h4>오버라이딩(Overriding - 다른 것보다 우선인)</h4>
<ul>
<li>상속 관계의 두 클래스의 상위 클래스에서 정의한 메서드를 하위 클래스에서 변경(재정의)하는 것이다.</li>
<li>Java 언어에서는 static 메ㅓㅅ드의 오버라이딩을 허용하지 않는다.</li>
<li>오버라이딩의 경우 하위 객체의 매개 변수 개수와 타입은 상위 객체와 같아야 한다.</li>
</ul>
<h1>스크립트 언어</h1>
<ul>
<li>소스 코드를 컴파일 과정을 거치지 않고 실행할 수 있는 프로그래밍 언어이다.</li>
<li>스크립트 언어에 내장된 번역기에 의해 번역되어 실행된다.</li>
<li>실행 단계에서 구분을 분석한다.</li>
</ul>
<h3>스크립트 언어의 종류</h3>
<ol>
<li>서버 측 스크립트 언어<!-- -->
<ul>
<li>ASP(Active Server Page)<!-- -->
<ul>
<li>서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 Windows 계열의 운영체제에서 실행 가능하다.</li>
</ul>
</li>
<li>JSP(Java Server Page)<!-- -->
<ul>
<li>Java를 기반으로 하고 서버 측에서 동적으로 수행하는 페이지를 만드는 언어이다.</li>
</ul>
</li>
<li>PHP(Professional Hypertext Preprocessor)<!-- -->
<ul>
<li>소스 코드가 HTML 파일에 포함되는 언어이다.</li>
<li>데이터베이스와의 연동이 매우 용이하다.</li>
<li>Linux, UNIX, Window 등의 다양한 운영 체제에서 사용 가능하다.<!-- -->
<ul>
<li>PHP 연산자<!-- -->
<ul>
<li>산술 연산자 : +, -, *, /, %, **</li>
<li>할당 연산자 : =, +=, -=, *=, /=, %=</li>
<li>증감 연산자 : ++, --</li>
<li>관계 연산자 : ==, ===, !=, &lt;&gt;, !==, &gt;, &lt;, &gt;=, &lt;=</li>
<li>논리 연산자 : and, or, xor, &amp;&amp;, ||, !</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>파이썬(Python)<!-- -->
<ul>
<li>인터프리터 방식의 객체지향 언어이다.</li>
<li>실행 시점에 데이터 타입을 결정하는 동적 타이핑 기능을 갖는다.</li>
</ul>
</li>
</ul>
</li>
<li>클라이언트 측 스크립트 언어<!-- -->
<ul>
<li>JavaScript<!-- -->
<ul>
<li>HTML 문서에서 HTML이나 CSS로 표현하기 어렵거나 불가능한 작업을 수행하기 위해 개발되었다.</li>
<li>소스 코드가 HTML 문서에 포함되어 있다.</li>
<li>클래스가 존재하지 않으며 변수 선언도 필요 없다.(?)</li>
<li>사용자의 웹 브라우저에서 직접 번역되고 시랳ㅇ된다.</li>
</ul>
</li>
<li>VBScript<!-- -->
<ul>
<li>마이크로소프트가 개발한 액티브 스크립트 언어이다.</li>
<li>VBScript의 구분은 비주얼 베이직(Visual Basic) 프로그래밍 언어를 일부 반영한다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1>파이썬(Python)</h1>
<h3>파이썬 변수명 작성 규칙</h3>
<ul>
<li>영문 대소문자(A<del>Z, a</del>z), 숫자(0~9), &#x27;_&#x27;를 혼용하여 사용할 수 있다.</li>
<li>첫 글자는 영문자나 &#x27;_&#x27;로 시작해야 한다.</li>
<li>영문자는 대소문자를 구분한다.</li>
<li>공백을 포함할 수 없다.</li>
<li>예약어(Reserved Word)를 사용할 수 없다.</li>
</ul>
<h3>문자열 추출</h3>
<ul>
<li>하나의 문자를 추출하려면 추출하려는 문자의 인덱스(0부터 시작)을 지정한다.</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-python" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>
</span><span>string </span><span class="token" style="color:#a9b7c6">=</span><span> </span><span class="token" style="color:#6a8759">&#x27;hello python&#x27;</span><span>
</span>
<span>s1 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#6897bb">0</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s1</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;h&#x27;</span><span>
</span>
<span>s2 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#6897bb">4</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s2</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;o&#x27;</span><span>
</span>
<span></span><span class="token" style="color:#808080"># 역순으로 맨 오른쪽의 인덱스는 -1이다.</span><span>
</span>
<span>s3 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#a9b7c6">-</span><span class="token" style="color:#6897bb">1</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s3</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;n&#x27;</span><span>
</span>
<span>s4 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#a9b7c6">-</span><span class="token" style="color:#6897bb">6</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s4</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;p&#x27;</span><span>
</span>
<span></span><span class="token" style="color:#808080"># [:]는 처음부터 끝까지 추출한다.</span><span>
</span>
<span>s5 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s5</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;hello python&#x27;</span><span>
</span>
<span></span><span class="token" style="color:#808080"># [x:] 인덱스 x부터 끝까지 추출한다.</span><span>
</span>
<span>s6 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#6897bb">6</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s6</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;python&#x27;</span><span>
</span>
<span>s7 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#a9b7c6">-</span><span class="token" style="color:#6897bb">6</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s7</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;python&#x27;</span><span>
</span>
<span></span><span class="token" style="color:#808080"># [:y] 처음부터 인덱스 y-1 까지 추출한다.</span><span>
</span>
<span>s8 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#6897bb">5</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s8</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;hello&#x27;</span><span>
</span>
<span></span><span class="token" style="color:#808080"># [x:y] 인덱스 x부터 y-1까지 추출한다.</span><span>
</span><span>s9 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#6897bb">4</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#6897bb">7</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s9</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;o p&#x27;</span><span>
</span>
<span></span><span class="token" style="color:#808080"># [x:y:z] 인덱스 x부터 y-1까지 z만큼 건너뛰면서 추출한다.</span><span>
</span><span>s10 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#6897bb">10</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#6897bb">2</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s10</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;hlopt&#x27;</span><span>
</span>
<span>s11 </span><span class="token" style="color:#a9b7c6">=</span><span> string</span><span class="token" style="color:#a9b7c6">[</span><span class="token" style="color:#6897bb">1</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#6897bb">10</span><span class="token" style="color:#a9b7c6">:</span><span class="token" style="color:#6897bb">2</span><span class="token" style="color:#a9b7c6">]</span><span>
</span><span></span><span class="token" style="color:#cc7832">print</span><span class="token" style="color:#a9b7c6">(</span><span>s11</span><span class="token" style="color:#a9b7c6">)</span><span> </span><span class="token" style="color:#808080"># &#x27;el yh&#x27;</span><span>
</span></code></pre></pre>
<h1>운영체제(OS : Operating System)</h1>
<ul>
<li>운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어이다.</li>
<li>운영체제는 컴퓨터를 편리하게 사용하고 컴퓨터 하드웨어를 효율적으로 사용할 수 있도록 한다.</li>
<li>운영체제는 스스로 어떤 유용한 기능도 수행하지 않고 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 마련해준다.</li>
<li>운영체제의 종류로는 MS-DOS, Windows 10, Linux, UNIX, OS/2, 안드로이드, IOS 등이 있다.</li>
</ul>
<h3>운영체제의 기능</h3>
<ul>
<li>사용자와 시스템 간의 편리한 인터페이스를 제공한다.</li>
<li>컴퓨터의 시스템의 성능을 최적화시킨다.</li>
<li>자원의 효과적인 경영을 위해 스케줄링 기능을 제공한다.</li>
<li>자원 보호 기능을 제공한다.</li>
<li>시스템에서 발생하는 오류로부터 시스템을 보호한다.</li>
<li>사용자들 간에 데이터를 공유할 수 있도록 한다.</li>
</ul>
<h3>운영체제의 목적</h3>
<ol>
<li>처리 능력(Throughput) 향상<!-- -->
<ul>
<li>처리 능력은 일정 시간 내에 시스템이 처리하는 일의 양이다.</li>
<li>처리 능력이 높을수록 처리하는 일의 양이 많아진다.</li>
</ul>
</li>
<li>반환 시간(Turnaround Time)감소<!-- -->
<ul>
<li>반환 시간은 컴퓨터 센터에 작업을 지시하고 나서부터 결과를 받을 때까지의 경과 시간이다.</li>
<li>반환 시간이 감소될수록 처리 속도가 빨라진다.</li>
</ul>
</li>
<li>신뢰도(Reliability) 향상<!-- -->
<ul>
<li>신뢰도는 시스템이 주어진 문제를 정확하게 해결하는 정도이다.</li>
<li>신뢰도가 높을수록 일을 정확하게 처리한다.</li>
</ul>
</li>
<li>사용 가능도(Availability) 향상<!-- -->
<ul>
<li>사용 가능도는 한정된 자원을 여러 사용자가 요구할 때, 어느 정도 신속하고 충분히 지원해 줄 수 있는지의 정도이다.</li>
<li>사용 가능도가 높을수록 반환 시간이 감소한다.</li>
</ul>
</li>
</ol>
<h3>운영체제의 운영 방식</h3>
<ol>
<li>일괄 처리 시스템(Batch Processing System)<!-- -->
<ul>
<li>일정량 또는 일정 기간 동안 데이터를 한꺼번에 모아서 처리하는 방식이다.</li>
<li>운영체제 운용 방식 중 시대적으로 가장 먼저 생겨났다.</li>
<li>ex. 수도요금 계산 업무, 월급 계산 업무 등</li>
</ul>
</li>
<li>다중 프로그래밍 시스템(Multi programming System)<!-- -->
<ul>
<li>컴퓨터 시스템 자원 활용률을 극대화하기 위해 2개 이상의 프로그램을 주기억 장치에 기억시키고 CPU를 번갈아 사용하면서 처리하는 방식이다.</li>
</ul>
</li>
<li>시분할 시스템(Time Sharing System)<!-- -->
<ul>
<li>CPU의 전체 사용 시간을 작은 작업 시간량(Time Slice)으로 나누어서 그 시간량 동안만 번갈아 가면서 CPU를 할당하여 각 작업을 처리하는 방식이다.</li>
<li>실제로 많은 사용자가 하나의 컴퓨터를 공유하고 있지만 마치 자신만이 컴퓨터 시스템을 독점하여 사용하고 있는 것처럼 느끼게 된다.</li>
</ul>
</li>
<li>다중 처리 시스템(Multi-Processing System)<!-- -->
<ul>
<li>동시에 프로그램을 수행할 수 있는 CPU를 두 개 이상 두고 각각 그 업무를 분담하여 처리할 수 있는 방식이다.</li>
</ul>
</li>
<li>실시간 처리 시스템(Real Time Processing System)<!-- -->
<ul>
<li>데이터 발생 즉시, 또는 데이터 처리 요구가 있는 즉시 처리하여 결과를 산출하는 방식이다.</li>
<li>정해진 시간에 반드시 수행되어야 하는 작업들을 처리할 때 가장 정합하다.</li>
<li>ex. 항공기 예약 업무, 은행 창구 업무, 조회 및 질의 업무 등</li>
</ul>
</li>
<li>다중 모드 시스템(Multi-mode System)<!-- -->
<ul>
<li>일괄 처리 + 시분할 + 다중 처리 + 실시간 처리</li>
</ul>
</li>
<li>분산 처리 시스템(Distributed Processing System)<!-- -->
<ul>
<li>여러 대의 컴퓨터로 작업을 나누어 처리하여 그 내용이나 결과를 통신망을 이용하여 상호 교환되도록 연결하는 방식이다.</li>
</ul>
</li>
</ol>
<h1>프로세스(Process)</h1>
<h3>프로세스의 정의</h3>
<ul>
<li>실행 중인 프로그램이다.</li>
<li>실행 가능한 PCB를 가진 프로그램이다.</li>
<li>프로세서가 할당되는 실체이다.</li>
<li>프로시저가 활동 중인 것이다.</li>
<li>비동기적 행위를 일으키는 주체이다.</li>
</ul>
<h3>프로세스 제어 블록(PCB: Process Control Block)</h3>
<ul>
<li>운영체제가 프로세스를 관리하기 위해 프로세스에 대한 중요한 정보를 저장해 놓은 곳이다.</li>
<li>프로세스가 생성될 때마다 고유의 PCB가 생성되며, 프로세스가 소멸되면 PCB도 소멸된다.</li>
<li>PCB에 저장되어 있는 정보 : 프로세스의 현재 상태, 프로세스의 우선순위, 프로세스에 할당된 자원에 대한 정보, CPU 레지스터 정보</li>
</ul>
<h3>프로세스 상태 전이</h3>
<pre><code node="[object Object]">생성(New) -&gt; 준비(Ready) -(디스패치-Dispatch)-&gt; 실행(Run) -&gt; 종료(Exit)
                ↑        &lt;-(Timer Runout)-    ↙
             Wake Up            Block ←-------
                |           ↙
           대기(Blocked) ←--
</code></pre>
<ul>
<li>준비 상태(Ready State)<!-- -->
<ul>
<li>프로세스가 CPU를 할당받기 위해 준비하고 있는 상태이다.</li>
</ul>
</li>
<li>실행 상태(Running State)<!-- -->
<ul>
<li>준비 상태의 프로세스가 CPU를 할당받아 실행 중인 상태이다.</li>
<li>디스패치(Dispatch) : 우선순위가 가장 높은 프로세스가 준비 상태에서 실행 상태로 전환되는 것이다.</li>
<li>할당 시간 종료(Time Runout) : 실행 상태의 프로세스가 할당 시간(타이머)이 종료되어 준비 상태로 전환되는 것이다.</li>
</ul>
</li>
<li>대기 상태(Blocked State)<!-- -->
<ul>
<li>실행 상태의 프로세스가 종료되기 전에 입/출력 등의 다른 작업이 필요할 경우 CPU를 반납하고 작업의 완료를 기다리는 상태이다.</li>
<li>블록(Block) : 실행 상태에서 대기 상태로 전환되는 것이다.</li>
<li>웨이크 업(Wake Up) : 대기 상태의 프로세스가 웨이크업(조건 만족)되면 준비 상태로 전환된다.</li>
</ul>
</li>
</ul>
<h3>스레드(Thread)</h3>
<ul>
<li>프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위를 의미한다.</li>
<li>하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.</li>
<li>한 개의 프로세스는 여러 개의 스레드를 가질 수 있다.</li>
</ul>
<h2>프로세스 스케줄링(Process Scheduling)</h2>
<ul>
<li>프로세스의 생성 및 실행에 필요한 시스템의 자원을 해당 프로세스에 할당하는 작업이다.</li>
<li>다중 프로그래밍 운영체제에서 자원의 성능을 향상시키고 효율적인 프로세서의 관리를 위해 작업 순서를 결정하는 것이다.</li>
</ul>
<h3>프로세스 스케줄링 기법</h3>
<h4>비선점(Non-Preemptive) 스케줄링</h4>
<ol>
<li>FIFO(First in Fist Out)<!-- -->
<ul>
<li>준비 상태 큐에 도착한 순서대로 CPU를 할당하는 기법이다.</li>
<li>FCFS(Fist Come First Service)라고도 한다.</li>
</ul>
</li>
<li>SJF(Shortest Job First)<!-- -->
<ul>
<li>준비 상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 스케줄링 기법이다.</li>
<li>평균 대기 시간을 최소화한다.</li>
</ul>
</li>
<li>HRN(Highest Responseratio Next)<!-- -->
<ul>
<li>어떤 작업이 서비스받을 시간과 그 작업이 서비스를 기다린 시간으로 결정되는 우선순위에 따라 CPU를 할당하는 기법이다.</li>
<li>우선순위 계산식 = (대기 시간 + 서비스를 받을 시간) / 서비스를 받을 시간</li>
</ul>
</li>
<li>우선순위(Priority)<!-- -->
<ul>
<li>준비 상태 큐에서 대기하는 프로세스에게 부여된 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법이다.</li>
<li>우선순위가 낮은 프로세스는 무한 정지(Indefinite Blocking)가 발생할 수 있으며, 에이징(Aging) 기법으로 이를 해결할 수 있다.</li>
</ul>
</li>
</ol>
<h4>선점(Preemptive) 스케줄링</h4>
<ul>
<li>한 프로세스가 CPU를 할당받아 실행 중이라도 우선순위가 높은 다른 프로세스가 CPU를 강제적으로 뺴앗을 수 있는 방식이다.</li>
<li>긴급하고 높은 우선순위의 프로세스들이 빠르게 처리될 수 있다.</li>
<li>선점을 위한 시간 배당에 대한 인터럽트용 타이머 클럭(Clock)이 필요하다.</li>
<li>온라인 응용에 적합한 스케줄링이다.</li>
<li>종류<!-- -->
<ul>
<li>RR(Round Robin)<!-- -->
<ul>
<li>주어진 시간 할당량(Time Slice) 안에 작업을 마치지 않으면 준비 상태 큐의 가장 뒤로 배치된다.</li>
<li>시분할 시스템(Time-sharing System)을 위해 고안된 방식이다.</li>
<li>시간 할당량이 커지면 FCFS 스케줄링과 같은 효과를 얻을 수 있다.</li>
<li>시간 할당이 작아지면 프로세스 문맥 교환이 자주 일어난다.</li>
</ul>
</li>
<li>SRT(Shortest Remainig Time)<!-- -->
<ul>
<li>작업이 끝나기까지의 실행시간 추정치가 가장 작은 작업을 먼저 실행시키는 기법이다.</li>
<li>FIFO 기법보다 평균 대기 시간이 감소된다.</li>
<li>작업 시간이 큰 경우 오랫동안 대기하여야 한다.</li>
</ul>
</li>
<li>다단계 큐(Multi-Level Queue)<!-- -->
<ul>
<li>프로세스들을 우선순위에 따라 상위, 중위, 하위 단계의 단계별 준비 상태 큐를 배치하는 기법이다.</li>
</ul>
</li>
<li>다단계 피드백 큐(Multi-Level Feedback Queue)<!-- -->
<ul>
<li>각 준비 상태 큐마다 부여된 시간 할당량 안에 완료하지 못한 프로세스는 다음 단계의 준비 상태 큐로 이동하는 기법이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>OST(Open Systems Interconnection) 7계층 ★★★</h1>
<ol>
<li>물리 계층(Physical Layer)<!-- -->
<ul>
<li>물리적인 장치와 인터페이스가 전송을 위해 필요한 기계적, 전기적, 기능적, 절차적 기능을 정의하는 계층이다.</li>
<li>장치와 전송 매체 간의 인터페이스 특성 규정, 전송 매체의 유형 규정, 전송로의 연결, 유지 및 해제를 담당한다.</li>
<li>프로토콜 종류 : RS-232C, V.24, X.21</li>
</ul>
</li>
<li>데이터 링크 계층(Data Link Layer)<!-- -->
<ul>
<li>인접한 두 개의 통신 시스템 간에 신뢰성 있는 효율적인 데이터를 전송하는 계층이다.</li>
<li>링크의 설정과 유지 및 종료를 담당한다.</li>
<li>전송 데이터의 흐름 제어, 프레임 동기, 오류 제어 등을 수행한다.</li>
<li>링크의 효율성을 향상시킨다.</li>
<li>프로토콜 종류 : HDLC, PPP, LLC, LAPB, LAPD, ADCCP</li>
</ul>
</li>
<li>네트워크 계층(Network Layer)<!-- -->
<ul>
<li>통신망을 통해 패킷을 목적지까지 전달하는 계층.</li>
<li>경로 설정 및 네트워크 연결 관리를 수행.</li>
<li>과도한 패킷 유입에 대한 폭주 제어 기능을 한다.</li>
<li>프로토콜 종류 : X.25, IP, ICMP, IGMP</li>
</ul>
</li>
<li>전송 계층(Transport Layer)<!-- -->
<ul>
<li>통신 종단 간(End-to-End) 신뢰성 있고 효율적인 데이터를 전송하는 계층이다.</li>
<li>투명한 데이터 전송을 제공한다.</li>
<li>에러 제어 및 흐름 제어를 담당한다.</li>
<li>프로토콜 종류 : TCP, UDP</li>
</ul>
</li>
<li>세션 계층(Session Layer)<!-- -->
<ul>
<li>프로세스 간에 대한 연결을 확립, 관리, 단절시키는 수단을 제공한다.</li>
<li>논리적 동기 제어, 긴급 데이터 전송, 통신 시스템 간의 회화 기능 등을 제공한다.</li>
</ul>
</li>
<li>표현 계층(Presentation Layer)<!-- -->
<ul>
<li>응용 간의 대화 제어(Dialogue Control)을 담당한다.</li>
<li>응용 계층과 세션 계층 사이에서 데이터 변환을 담당한다.</li>
<li>정보의 형식 설정, 암호화, 데이터 압축, 코드 변환, 문맥 관리 등의 기능을 수행한다.</li>
<li>긴 파일 전송 중에 통신 상태가 불량하여 트랜스포트 연결이 끊어지는 경우 처음부터 다시 전송하지 않고 어디까지 전송이 진행되었는지를 나타내는 동기점을 이용하여 오류를 복구한다.</li>
</ul>
</li>
<li>응용 계층(Application Layer)<!-- -->
<ul>
<li>사용자에게 서비스를 제공한다.</li>
<li>응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.</li>
<li>프로토콜 종류 : HTTP, FTP, SMTP, Telnet, DNS</li>
</ul>
</li>
</ol>
<h1>TCP/IP 프로토콜(Transmission Control Protocol/Internet Protocol)</h1>
<ul>
<li>인터넷에 연결된 서로 다른 기종의 컴퓨터 간에 데이터 송/수신이 가능하도록 도와주는 표준 프로토콜이다.</li>
<li>TCP 프로토콜과 IP 프로토콜의 결합적 의미로서 TCP가 IP보다 상위층에 존재한다.</li>
<li>접속형 서비스, 전이중 전송 서비스, 신뢰성 서비스를 제공한다.</li>
<li>네트워크 환경에 따라 여러 개의 프로토콜을 허용한다.</li>
<li>TCP 프로토콜의 기본 헤더 크기는 20byte이고 60byte까지 확장 가능하다.</li>
<li>OSI 표준 프로토콜과 가까운 네트워크 구조를 가진다.<!-- -->
<ul>
<li>OSI 7계층 : 물리, 데이터, 네트워크, 전송, 세션, 표현, 응용 계층</li>
<li>TCP/IP 4계층 : 링크, 인터넷, 전송, 응용 계층</li>
</ul>
</li>
</ul>
<h3>TCP(Transmission Control Protocol)</h3>
<ul>
<li>OSI 7계층의 전송 계층의 역할을 수행한다.</li>
<li>서비스 처리를 위해 Multiplexing과 DeMultiplexing을 이용한다.</li>
<li>전이중 서비스와 스트림 데이터 서비스를 제공한다.</li>
</ul>
<h3>IP(Internet Protocol)</h3>
<ul>
<li>OSI 7계층의 네트워크 계층에 해당하며 비신뢰성 서비스를 제공한다.</li>
</ul>
<h2>TCP/IP의 구조</h2>
<h3>링크 계층(Link Layer)</h3>
<ul>
<li>프레임을 송/수신한다.</li>
<li>프로토콜의 종류 : Ethernet, IEEE 802, HDLC, X.25, RS-232C 등</li>
</ul>
<h3>인터넷 계층(Internet Layer)</h3>
<ul>
<li>주소 지정, 경로 설정을 제공한다.</li>
<li>네트워크 계층이라고도 한다.</li>
<li>프로토콜 종류 : IP, ICMP, IGMP, ARP, RARP 등<!-- -->
<ul>
<li>IP(Internet Protocol)<!-- -->
<ul>
<li>비연결형 및 비신뢰성 전송 서비스를 제공한다.</li>
<li>라우팅과 단편화 기능을 수행한다.</li>
<li>데이터그램(Datagram)이라는 데이터 전송 형식을 가진다.</li>
<li>각 데이터그램이 독립적으로 처리되고 목적지까지 다른 경로를 통해 전송될 수 있어 데이터그램은 전송 순서와 도착 순서가 다를 수 있다.</li>
<li>비연결성이기 때문에 송신지가 여러 개인 데이터 그램을 보내면서 순서가 뒤바뀌어 도달할 수 있으며 IP 프로토콜의 헤더 길이는 최소 20~60byte이다.</li>
</ul>
</li>
<li>ICMP(Internet Control Message Protocol)<!-- -->
<ul>
<li>IP 프로토콜에서는 오류 보고와 수정을 위한 메커니즘이 없기 때문에 이를 보완하기 위해 설계된 프로토콜이다.</li>
<li>메시지는 크게 오류 보고(Error-Reporting) 메시지와 질의(Query) 메시지로 나눌 수 있다.</li>
<li>메시지 형식은 8바이트의 헤더와 가변 길이의 데이터 영역으로 분리된다.</li>
<li>에코 메시지는 호스트가 정상적으로 동작하는지를 결정하는데 사용할 수 있다.</li>
<li>수신지 도달 불가 메시지는 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는데 사용한다.</li>
</ul>
</li>
<li>IGMP(Internet Group Management Protocol)<!-- -->
<ul>
<li>시작지 호스트에서 여러 목적지 호스트로 데이터를 전송할 때 사용되는 프로토콜이다.</li>
<li>멀티캐스트 그룹에 가입한 네트워크 내의 호스트를 관리한다.</li>
</ul>
</li>
<li>ARP 20.9(Address Resolution Protocol)<!-- -->
<ul>
<li>논리 주소(IP 주소)를 물리 주소(MAC 주소)로 변환하는 프로토콜이다.</li>
<li>네트워크에서 두 호스트가 성공적으로 통신하기 위해 각 하드웨워의 물리적인 주소 문제를 해결해 줄 수 있다.</li>
</ul>
</li>
<li>RARP(Reverse Address Resolution Protocol)<!-- -->
<ul>
<li>호스트의 물리 주소(MAC 주소)로부터 논리 주소(IP 주소)를 구하는 프로토콜이다.</li>
<li>IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP 주소를 모르는 경우, 서버에게 IP 주소를 요청하기 위해 사용한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>전송 계층(Transport Layer)</h3>
<ul>
<li>호스트 간 신뢰성 있는 통신을 제공한다.</li>
<li>프로토콜 종류 : TCP, UDP<!-- -->
<ul>
<li>TCP 20.8(Transmission Control Protocol)<!-- -->
<ul>
<li>신뢰성 있는 연결 지향형 전달 서비스를 제공한다.</li>
<li>순서 제어, 에러 제어, 흐름 제어 기능을 제공한다.</li>
<li>전이중 서비스와 스트림 데이터 서비스를 제공한다.</li>
<li>메시지를 캡슐화(Encapsulation)와 역캡슐화(Decapsulation)한다.</li>
<li>서비스 처리를 위해 다중화(Multiplexing)와 역다중화(Demultiplexing)를 이용한다.</li>
</ul>
</li>
<li>UDP 20.9(User Datagram Protocol)<!-- -->
<ul>
<li>비연결형 및 비신뢰성 전송 서비스를 제공한다.</li>
<li>흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.</li>
<li>수신된 데이터의 순서 재조정 기능을 지원하지 않는다.</li>
<li>복구 기능을 제공하지 않는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>IP 주소 ★★★</h1>
<h3>IPv4(Internet Protocol version 4)</h3>
<ul>
<li>32비트 길이의 IP주소이다.</li>
<li>주소의 각 부분을 8비트씩 4개로 나눠서 10진수로 표현한다.</li>
<li>IP 주소 = 네트워크 주소(Netid) + 호스트 주소</li>
</ul>
<h4>IPv4의 주소 체계</h4>
<ul>
<li>클래스 A<!-- -->
<ul>
<li>0.0.0.0 ~ 127.255.255.255</li>
<li>기본 서브넷 마스크 : 255.0.0.0</li>
<li>국가나 대형 통신망에서 사용한다.</li>
</ul>
</li>
<li>클래스 B<!-- -->
<ul>
<li>128.0.0.0 ~ 191.255.255.255</li>
<li>기본 서브넷 마스크 : 255.255.0.0</li>
<li>중대형 통신망에서 사용한다.</li>
</ul>
</li>
<li>클래스 C<!-- -->
<ul>
<li>192.0.0.0 ~ 223.255.255.255</li>
<li>기본 서브넷 마스크 : 255.255.255.0</li>
<li>소규모 통신망에서 사용한다.</li>
</ul>
</li>
<li>클래스 D<!-- -->
<ul>
<li>224.0.0.0 ~ 239.255.255.255</li>
<li>멀티캐스트용으로 사용한다.</li>
</ul>
</li>
<li>클래스 E<!-- -->
<ul>
<li>240.0.0.0 ~ 255.255.255.255</li>
<li>실험용으로 사용한다.</li>
</ul>
</li>
</ul>
<h3>IPv6(Internet Protocol version 6)</h3>
<ul>
<li>IPv4의 주소 부족 문제를 해결하기 위해 개발되었다.</li>
<li>128비트 길이의 IP 주소이다.</li>
<li>16비트씩 8개의 필드로 분리 표기된다.</li>
</ul>
<h4>IPv6의 장점</h4>
<ul>
<li>인증 보안 기능을 포함하고 있어 IPv4보다 보안성이 강화되었다.</li>
<li>IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다.</li>
<li>임의의 크기의 패킷을 주고받을 수 있도록 패킷 크기 제한이 없다.</li>
<li>멀티미디어의 실시간 처리가 가능하다.</li>
<li>자동으로 네트워크 환경 구성이 가능하다.</li>
<li>주소체계는 유니캐스트(Unicast), 애니캐스트(Anycast), 멀티캐스트(Multicast) 등 세 가지로 나뉜다.</li>
</ul>
<h4>IPv6의 통신 방식 20.6</h4>
<ul>
<li>유니캐스트(Unicast)<!-- -->
<ul>
<li>하나의 호스트에서 다른 하나의 호스트에게 전달하는 1:1 통신 방식이다.</li>
</ul>
</li>
<li>애니캐스트(Anycast)<!-- -->
<ul>
<li>하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달하는 &#x27;1: 가장 가까운 1&#x27; 통신 방식이다.</li>
</ul>
</li>
<li>멀티캐스트(Multicast)<!-- -->
<ul>
<li>하나의 호스트에서 네트워크상의 특정 그룹 호스트들에게 전달하는 1:N 통신 방식이다.</li>
</ul>
</li>
</ul>
<h3>서브넷 마스크(Subnet Mask)</h3>
<ul>
<li>네트워크를 작은 내부 네트워크로 분리하여 효율적으로 네트워크를 관리하기 위한 수단이다.</li>
<li>서브넷 마스크는 32비트의 값으로 IP 주소를 네트워크와 호스트 IP 주소를 구분하는 역할을 한다.</li>
<li>네트워크 ID에 해당하는 모든 비트를 1로 설정하며, 호스트 ID에 해당하는 모든 비트를 0으로 설정한다.</li>
<li>CIDR 표기 형식 : 10진수의 IP/네트워크 ID의 1비트의 개수</li>
</ul>
<hr/>
<p>참조 : <a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9">Github repository</a></p></div></main><div class="sc-e5001ff0-0 hvYKNx"><p><strong>정보처리기사</strong> 카테고리의 다른 글</p><ul class="sc-e5001ff0-1 fGkysO"></ul></div><div class="sc-39211eb-3 jqcgtI"><p>COMMENTS</p><section id="comment-box"></section></div></main></article><aside class="sc-7eadfa91-0 cYGwoY"><nav class="sc-ef3fe011-0 fOQwiv"><ul class="sc-ef3fe011-1 gcpOaT"><p>Category</p><div><p class="sc-ef3fe011-2 jLZscn">FE</p><li class="sc-ef3fe011-3 frUPYo"><a href="/html">HTML</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/css">CSS</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/javascript">JavaScript</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/typescript">TypeScript</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/redux">Redux</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/react">React</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/nextjs">Nextjs</a></li></div><div><p class="sc-ef3fe011-2 jLZscn">BE</p><li class="sc-ef3fe011-3 frUPYo"><a href="/nestjs">Nestjs</a></li></div><div><p class="sc-ef3fe011-2 jLZscn">CS</p><li class="sc-ef3fe011-3 frUPYo"><a style="color:white;font-weight:bold" href="/sw">정보처리기사</a></li></div><div><p class="sc-ef3fe011-2 jLZscn">ETC</p><li class="sc-ef3fe011-3 frUPYo"><a href="/github">Simple Memo</a></li></div></ul></nav></aside></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"sw first test4","description":"정보처리기사 필기(4) - 프로그래밍 언어 활용","category":"sw","keyword":"정보처리기사, 정처기, 필기, 프로그래밍 언어 활용","date":"2023-12-27","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 모듈화와 결합도/응집도 ★★★\r\n\r\n### 모듈화\r\n\r\n- 모듈화는, 거대한 문제를 작은 조각의 문제로 나누어 다루기 쉽도록 하는 과정으로, 작게 나누어진 각 부분을 모듈이라고 한다.\r\n- 소프트웨어의 모듈은 프로그래밍 언어에서 Subroutine, Function 등으로 표현될 수 있다.\r\n- 모듈화는 시스템을 지능적으로 관리할 수 있도록 해주며, 복잡도 문제를 해결하는데 도움을 준다.\r\n- 모듈화는 시스템의 유지보수와 수정을 용이하게 한다.\r\n\r\n#### 모듈의 개념\r\n\r\n- 하나의 프로그램을 몇 개의 작은 부분으로 분할한 단위이다.\r\n- 모듈의 독립성은 결합도와 응집도에 의해 측정된다.\r\n- 각 모듈은 논리적 또는 기능적으로 분리되어 격리되고 독립적인 일을 수행한다.\r\n- 특성 : Unity(한 가지 일만 수행), Smallness(간단 명료), Simplicity(단순성), Independency(독십성) 등\r\n\r\n### 결합도(Coupling)\r\n\r\n- 한 모듈과 다른 모듈 간의 상호 의존도 또는 두 모듈 사이의 연관 관계를 의미한다.\r\n- 모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상된다.\r\n- 인터페이스가 정확히 설정되어 있지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도는 높아지고 결합도가 증가한다.\r\n- 다른 모듈과 데이터 교류가 필요한 경우 전역 변수(Global Variable)보다는 매개 변수(Parameter)를 사용하는 것이 결합도를 낮추는데 도움이 된다.\r\n- 결합도 정도 : 데이터 결합도 \u003c 스탬프 결합도 \u003c 제어 결합도 \u003c 외부 결합도 \u003c 공통 결합도 \u003c 내용 결합도\r\n\r\n- 데이터 결합도(Data Coupling)\r\n  - 한 모듈이 파라미터나 인수로 다른 모듈에 데이터를 넘겨주고 호출받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 경우의 결합도.\r\n- 스탬프 결합도(Stamp Coupling)\r\n  - 두 모듈이 동일한 자료 구조를 조회하는 경우의 결하볻\r\n- 제어 결합도(Control Coupling)\r\n  - 한 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우의 결합도\r\n- 외부 결합도(External Coupling)\r\n  - 한 모듈에서 외부로 선언한 변수를 다른 모듈에서 참조할 경우의 결합도\r\n- 공통 결합도(Common Coupling)\r\n  - 한 모듈이 다른 모듈에 제어 요소를 전달하고 여러 모듈이 공통 자료 영역을 사용하는 경우의 결합도\r\n- 내용 결합도(Content Coupling)\r\n  - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도\r\n\r\n### 응집도(Cohesion)\r\n\r\n- 한 모듈 내부의 처리 요소 간의 기능적 연관도를 의미한다.\r\n- 모듈 내부 요소는 명령어, 명령어의 모임, 호출문, 특정 작업 수행 코드 등이다.\r\n- 응집도 정도 : 기능적 응집도 \u003e 순차적 응집도 \u003e 교환적 응집도 \u003e 절차적 응집도 \u003e 시간적 응집도 \u003e 논리적 응집도 \u003e 우연적 응집도\r\n\r\n- 기능적 응집도(Functional Cohesion)\r\n  - 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로써 제공되는 경우의 응집도\r\n- 순차적 응집도(Sequential Cohesion)\r\n  - 모듈의 구성 요소가 하나의 활동으로부터 나온 출력 자료를 그다음 활동의 입력 자료로 사용하는 같은 모듈 내에서의 응집도\r\n- 교환적 응집도(Communicational Cohesion)\r\n  - 동일한 입력과 출력을 사용하는 소 작업들이 모인 모듈에서 볼 수 있는 응집도.\r\n- 절차적 응집도(Procedural Cohesion)\r\n  - 모듈이 다수의 관련 기능을 가질 때 모듈 내부의 기능 요소들이 그 기능을 순차적으로 수행할 경우의 응집도\r\n- 시간적 응집도(Temporal Cohesion)\r\n  - 특정 시간에 처리되는 여러 기능을 모아 한 개의 모듈로 작성할 경우의 응집도\r\n- 논리적 응집도(Logical Cohesion)\r\n  - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도\r\n- 우연적 응집도(Coincidental Cohesion)\r\n  - 서로 간에 어떠한 의미 있는 연관 관계도 지니지 않은 기능 요소로 구성되는 경우의 응집도\r\n\r\n### 효과적인 모듈화 설계 방법\r\n\r\n- 응집도는 강하게, 결합도는 약하게 설계한다.\r\n- 복잡도와 중복성을 줄이고 일관성을 유지할 수 있도록 설계한다.\r\n- 유지보수가 용이하도록 설계한다.\r\n- 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 설계한다.\r\n- 모듈 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.\r\n\r\n# C 언어\r\n\r\n### C언어의 기본 구조\r\n\r\n- main 함수를 반드시 포함해야 하며, main 함수에서 실행이 시작된다.\r\n- 영문 대/소문자를 엄격하게 구별한다.\r\n- 문장을 끝마칠 때는 세미콜론(;)을 사용한다.\r\n- 여러 개의 문장을 묶어 하나의 블록으로 구성할 때 중괄호({})를 사용한다.\r\n- 주석문은 /_ ~ _/로 표기한다.\r\n\r\n### 기본 자료형\r\n\r\n| 자료형 | 예약어 | 크기  |\r\n| :----: | :----: | :---: |\r\n| 정수형 |  int   | 2Byte |\r\n|        |  long  | 4Byte |\r\n| 실수형 | float  | 4Byte |\r\n|        | double | 8Byte |\r\n| 문자형 |  char  | 1Byte |\r\n\r\n### 입/출력 함수\r\n\r\n- 표준 입/출력 함수\r\n  - scanf() : 표준 입력 함수\r\n  - printf() : 표준 출력 함수\r\n  - getchar() : 문자 입력 함수\r\n  - putchar() : 문자 출력 함수\r\n  - gets() : 문자열 입력 함수\r\n  - puts() : 문자열 출력 함수\r\n- 변환 문자(출력 형식 지정 문자)\r\n  - %d : 10진 정수\r\n  - %o : 8진 정수\r\n  - %x : 16진 정수\r\n  - %f : 실수형\r\n  - %e : 지수형\r\n  - %c : 문자\r\n  - %s : 문자열\r\n\r\n### 탈출문(Escape Sequence)\r\n\r\n| 문자 |      의미       |               기능                |\r\n| :--: | :-------------: | :-------------------------------: |\r\n|  \\n  |    new line     | 커서를 다음 줄 처음으로 이동한다. |\r\n|  \\r  | carriage return | 커서를 현재 줄 처음으로 이동한다. |\r\n|  \\t  |       tab       |   커서를 일정 간격만큼 띄운다.    |\r\n|  \\b  |    backspace    |    커서를 뒤로 한 칸 이동한다.    |\r\n|  \\f  |    form feed    |        한 페이지를 넘긴다.        |\r\n|  \\0  | null character  |        널 문자를 출력한다.        |\r\n|  \\'  |  single quote   |      작은 따옴표를 출력한다.      |\r\n|  \\\"  |  double quote   |       큰따옴표를 출력한다.        |\r\n| \\ \\\\ |    backslash    |       역슬래시를 출력한다.        |\r\n|  \\a  |      alert      |        벨 소리를 발생한다.        |\r\n\r\n### C언어 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 숫자로 시작할 수 없고, 영문자나 \"\\_\"로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- auto, beak, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register,return, short, signed, sizeof, static, struct, switch, typedef, union, unsigend, void, volatile, while 32개 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 포인터 변수\r\n\r\n- 다른 변수의 주소값을 저장할 수 있다.\r\n- 표인터 변수는 자료형에 상관없이 메모리 크기가 동일하다.\r\n- 가리키고 있는 변수값을 읽기 위해서는 포인터 연산자를 사용한다.\r\n- 포인터 변수에 일반 변수의 주소를 대입하기 위해서는 \u0026(주소) 연산자를 사용한다.\r\n- 포인터 변수를 가리키는 포인터 변수를 선언할 수 있다.\r\n\r\n### 표준 라이브러리 함수\r\n\r\n- stdio.h : C언어의 표준 입/출력 라이브러리(Standard Input and Output Library)이다.\r\n- stdlib.h : C 표준 유틸리티 함수를 모아놓은 헤더 파일이다. 문자형 변환, 수치를 문자형으로 변환, 동적 할당 관련 함수, 난수 생성 함수, 정수의 연산 함수, 검색 및 정렬 함수 등이다.\r\n- stdlib.h 함수 종류\r\n  - atoi() : 문자열을 정수형으로 변환\r\n  - atof() : 문자열을 실수형으로 변환\r\n  - atol() : 문자열을 log형 정수로 변환\r\n  - itoa() : 숫자를 문자열로 변환\r\n  - ceil() : 자리 올림\r\n  - floor() : 자리 버림\r\n  - rand() : 난수 발생\r\n  - div() : 정수 나눗셈\r\n\r\n### C언어 연산자의 특징\r\n\r\n#### 단항 연산자\r\n\r\n- ! : 부정(NOT)\r\n- ~ : 1의 보수(0-\u003e1, 1-\u003e0)를 구한다.\r\n- ++ : 1씩 증가를 의미한다.\r\n- \\-- : 1씩 감소를 의미한다.\r\n- \u0026 : 변수의 주소를 의미한다.\r\n- \\* : 변수의 내용을 의미한다.\r\n- sizeof : 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구한다.\r\n\r\n#### 산술 연산자\r\n\r\n- 이항 연산자는 +, -는 \\*, /, % 보다 우선순위가 낮다.\r\n- % : 정수 나눗셈 연산 후 나머지를 구한다.\r\n\r\n#### 시프트(Shift) 연산자\r\n\r\n- \u003c\u003c는 비트를 왼쪽으로 이동시킨다.\r\n- \\\u003e\u003e는 비트를 오른쪽으로 이동시킨다.\r\n\r\n#### 관계 연산자\r\n\r\n- \u003c : ~보다 작다.\r\n- \\\u003e : ~보다 크다.\r\n- \u003c= : ~보다 작거나 같다.\r\n- \\\u003e\\ : ~보다 크거나 같다.\r\n- == : ~와 같다.\r\n- != : ~와 같지 않다.\r\n\r\n#### 비트 연산자\r\n\r\n- \u0026 : 논리곱(AND)\r\n- | : 논리합(OR)\r\n- ^ : 배타적 논리합(XOR)\r\n\r\n```C\r\n\r\n#include \u003cstdio.h\u003e\r\nint main(int argc, char *argv[]) {\r\n    int a = 4;\r\n    int b = 7;\r\n    int c = a|b;\r\n    printf(\"%d\", c);\r\n    return 0;\r\n}\r\n// 1. 변수 a와 b의 4, 7을 (2진수)비트 연산자 |(OR)로 연산한다.\r\n// 2. 비트 연산자는 2진수로 변환 후 계산한다.\r\n// 3. OR 연산자는 두 비트 중 1개라도 1이면 1이 출력된다.\r\n//     0100 (10진수: 4)\r\n// OR  0111 (10진수: 7)\r\n// =   0111(둘 중 1개라도 1이면 1이기 때문에 10진수: 7)\r\n// 4. 0111는 \"%d\" 출력 형식 지정 문자에 의해 10진수로 변환하면 7이 되어 출력된다.\r\n//\r\n// 2와 5를 가정할때\r\n//     0010\r\n// OR  0101\r\n// =   0111\r\n\r\n```\r\n\r\n#### 논리 연산자\r\n\r\n- ! : 논리 부정(NOT)\r\n- \u0026\u0026 : 논리곱(AND)\r\n- || : 논리합(OR)\r\n\r\n#### 조건 연산자\r\n\r\n- C언어에서 유일하게 3개의 피연산자를 갖는 삼항 연산자이다.\r\n- 조건식 ? 참일 경우 값 : 거짓일 경우 값\r\n- ex. big = a \u003e b ? a:b; -\u003e a와 b 중에서 큰 수가 big에 저장됨\r\n\r\n# Java 언어\r\n\r\n- 객체지향 언어이다.\r\n- 추상화, 상속화, 다형성과 같은 특징을 가진다.\r\n- 네트워크 환경에서 분산 작업이 가능하도록 설계되었다.\r\n- 특정 컴퓨터 구조와 무관한 가상 바이트 머신 코드를 사용하므로 플랫폼이 독립적이다.\r\n\r\n### Garbage Collector\r\n\r\n- S/W 개발 중 유효하지 않은 가비지 메모리가 발생한다. Java에서는 C언어와 달리 JVM 가비지 컬렉터가 불필요 메모리를 알아서 정리해준다.\r\n\r\n### Java 언어의 기본 자료형\r\n\r\n|  분류  | 예약어  | 바이트 수 |                          비고                           |\r\n| :----: | :-----: | :-------: | :-----------------------------------------------------: |\r\n| 정수형 |  byte   |   1byte   |                       -127 ~ +128                       |\r\n|        |  short  |   2byte   |                    -32,768 ~ +32,767                    |\r\n|        |   int   |   4byte   |             -2,147,483,648 ~ +2,147,483,648             |\r\n|        |  long   |   8byte   | -9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,808 |\r\n| 실수형 |  float  |   4byte   |           단정도 실수형 (유효 자리는 7정도임)           |\r\n|        | double  |   8byte   |           배정도 실수형 (유효 자리는 15정도)            |\r\n| 문자형 |  char   |   2byte   |                   유니코드 문자열 1자                   |\r\n| 논리형 | boolean |   1byte   |                       true,false                        |\r\n\r\n### 이스케이프 시퀀스(Escape Sequence)\r\n\r\n| 문자 |      의미       |               기능                |\r\n| :--: | :-------------: | :-------------------------------: |\r\n|  \\n  |    new line     | 커서를 다음 줄 처음으로 이동한다. |\r\n|  \\r  | carriage return | 커서를 현재 줄 처음으로 이동한다. |\r\n|  \\t  |       tab       |   커서를 일정 간격만큼 띄운다.    |\r\n|  \\b  |    backspace    |    커서를 뒤로 한 칸 이동한다.    |\r\n|  \\f  |    form feed    |         한 페이지 넘긴다.         |\r\n|  \\'  |  single quote   |      작은따옴표를 출력한다.       |\r\n|  \\\"  |  double quote   |       큰따옴표를 출력한다.        |\r\n| \\ \\  |    backslash    |       역슬래시를 출력한다.        |\r\n\r\n### Java 접근 제한자(접근 제어자)\r\n\r\n- public : 모든 접근을 허용한다.\r\n- private : 같은 패키지에 있는 객체와 상속 관계의 객체들만 허용한다.\r\n- default : 같은 패키지에 있는 객체들만 허용한다.\r\n- protected : 현재 객체 내에서만 허용한다.\r\n\r\n### Java의 출력 함수\r\n\r\n- System.out.print() : 괄호 안을 출력하고 줄 바꿈을 안 한다.\r\n- System.out.printIn() : 괄호 안을 출력하고 줄 바꿈을 한다.\r\n- System.out.printf() : 변환 문자를 사용하여 출력한다.\r\n- 변환 문자(출력 형식 지정 문자)\r\n- %d : 10진 정수\r\n- %o : 8진 정수\r\n- %x : 16진 정수\r\n- %f : 실수형\r\n- %e : 지수형\r\n- %c : 문자\r\n- %s : 문자열\r\n\r\n### Java 언어 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_', '$'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 영문자나 '\\_', '$'로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 오버로딩(Overloading)과 오버라이딩(Overiding)\r\n\r\n#### 오버로딩(Overloading - 과적, 과부하)\r\n\r\n- 한 클래스 내에서 같은 메서드를 사용하는 것이다.\r\n- 같은 이름의 메서드를 여러 개 정의하면서 매개 변수의 유형과 개수가 달라지도록 하는 기술이다.\r\n\r\n#### 오버라이딩(Overriding - 다른 것보다 우선인)\r\n\r\n- 상속 관계의 두 클래스의 상위 클래스에서 정의한 메서드를 하위 클래스에서 변경(재정의)하는 것이다.\r\n- Java 언어에서는 static 메ㅓㅅ드의 오버라이딩을 허용하지 않는다.\r\n- 오버라이딩의 경우 하위 객체의 매개 변수 개수와 타입은 상위 객체와 같아야 한다.\r\n\r\n# 스크립트 언어\r\n\r\n- 소스 코드를 컴파일 과정을 거치지 않고 실행할 수 있는 프로그래밍 언어이다.\r\n- 스크립트 언어에 내장된 번역기에 의해 번역되어 실행된다.\r\n- 실행 단계에서 구분을 분석한다.\r\n\r\n### 스크립트 언어의 종류\r\n\r\n1. 서버 측 스크립트 언어\r\n   - ASP(Active Server Page)\r\n     - 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 Windows 계열의 운영체제에서 실행 가능하다.\r\n   - JSP(Java Server Page)\r\n     - Java를 기반으로 하고 서버 측에서 동적으로 수행하는 페이지를 만드는 언어이다.\r\n   - PHP(Professional Hypertext Preprocessor)\r\n     - 소스 코드가 HTML 파일에 포함되는 언어이다.\r\n     - 데이터베이스와의 연동이 매우 용이하다.\r\n     - Linux, UNIX, Window 등의 다양한 운영 체제에서 사용 가능하다.\r\n       - PHP 연산자\r\n         - 산술 연산자 : +, -, \\*, /, %, \\*\\*\r\n         - 할당 연산자 : =, +=, -=, \\*=, /=, %=\r\n         - 증감 연산자 : ++, --\r\n         - 관계 연산자 : ==, ===, !=, \u003c\u003e, !==, \u003e, \u003c, \u003e=, \u003c=\r\n         - 논리 연산자 : and, or, xor, \u0026\u0026, ||, !\r\n   - 파이썬(Python)\r\n     - 인터프리터 방식의 객체지향 언어이다.\r\n     - 실행 시점에 데이터 타입을 결정하는 동적 타이핑 기능을 갖는다.\r\n2. 클라이언트 측 스크립트 언어\r\n   - JavaScript\r\n     - HTML 문서에서 HTML이나 CSS로 표현하기 어렵거나 불가능한 작업을 수행하기 위해 개발되었다.\r\n     - 소스 코드가 HTML 문서에 포함되어 있다.\r\n     - 클래스가 존재하지 않으며 변수 선언도 필요 없다.(?)\r\n     - 사용자의 웹 브라우저에서 직접 번역되고 시랳ㅇ된다.\r\n   - VBScript\r\n     - 마이크로소프트가 개발한 액티브 스크립트 언어이다.\r\n     - VBScript의 구분은 비주얼 베이직(Visual Basic) 프로그래밍 언어를 일부 반영한다.\r\n\r\n# 파이썬(Python)\r\n\r\n### 파이썬 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 영문자나 '\\_'로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 문자열 추출\r\n\r\n- 하나의 문자를 추출하려면 추출하려는 문자의 인덱스(0부터 시작)을 지정한다.\r\n\r\n```python\r\n\r\nstring = 'hello python'\r\n\r\ns1 = string[0]\r\nprint(s1) # 'h'\r\n\r\ns2 = string[4]\r\nprint(s2) # 'o'\r\n\r\n# 역순으로 맨 오른쪽의 인덱스는 -1이다.\r\n\r\ns3 = string[-1]\r\nprint(s3) # 'n'\r\n\r\ns4 = string[-6]\r\nprint(s4) # 'p'\r\n\r\n# [:]는 처음부터 끝까지 추출한다.\r\n\r\ns5 = string[:]\r\nprint(s5) # 'hello python'\r\n\r\n# [x:] 인덱스 x부터 끝까지 추출한다.\r\n\r\ns6 = string[6:]\r\nprint(s6) # 'python'\r\n\r\ns7 = string[-6:]\r\nprint(s7) # 'python'\r\n\r\n# [:y] 처음부터 인덱스 y-1 까지 추출한다.\r\n\r\ns8 = string[:5]\r\nprint(s8) # 'hello'\r\n\r\n# [x:y] 인덱스 x부터 y-1까지 추출한다.\r\ns9 = string[4:7]\r\nprint(s9) # 'o p'\r\n\r\n# [x:y:z] 인덱스 x부터 y-1까지 z만큼 건너뛰면서 추출한다.\r\ns10 = string[:10:2]\r\nprint(s10) # 'hlopt'\r\n\r\ns11 = string[1:10:2]\r\nprint(s11) # 'el yh'\r\n\r\n```\r\n\r\n# 운영체제(OS : Operating System)\r\n\r\n- 운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어이다.\r\n- 운영체제는 컴퓨터를 편리하게 사용하고 컴퓨터 하드웨어를 효율적으로 사용할 수 있도록 한다.\r\n- 운영체제는 스스로 어떤 유용한 기능도 수행하지 않고 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 마련해준다.\r\n- 운영체제의 종류로는 MS-DOS, Windows 10, Linux, UNIX, OS/2, 안드로이드, IOS 등이 있다.\r\n\r\n### 운영체제의 기능\r\n\r\n- 사용자와 시스템 간의 편리한 인터페이스를 제공한다.\r\n- 컴퓨터의 시스템의 성능을 최적화시킨다.\r\n- 자원의 효과적인 경영을 위해 스케줄링 기능을 제공한다.\r\n- 자원 보호 기능을 제공한다.\r\n- 시스템에서 발생하는 오류로부터 시스템을 보호한다.\r\n- 사용자들 간에 데이터를 공유할 수 있도록 한다.\r\n\r\n### 운영체제의 목적\r\n\r\n1. 처리 능력(Throughput) 향상\r\n   - 처리 능력은 일정 시간 내에 시스템이 처리하는 일의 양이다.\r\n   - 처리 능력이 높을수록 처리하는 일의 양이 많아진다.\r\n2. 반환 시간(Turnaround Time)감소\r\n   - 반환 시간은 컴퓨터 센터에 작업을 지시하고 나서부터 결과를 받을 때까지의 경과 시간이다.\r\n   - 반환 시간이 감소될수록 처리 속도가 빨라진다.\r\n3. 신뢰도(Reliability) 향상\r\n   - 신뢰도는 시스템이 주어진 문제를 정확하게 해결하는 정도이다.\r\n   - 신뢰도가 높을수록 일을 정확하게 처리한다.\r\n4. 사용 가능도(Availability) 향상\r\n   - 사용 가능도는 한정된 자원을 여러 사용자가 요구할 때, 어느 정도 신속하고 충분히 지원해 줄 수 있는지의 정도이다.\r\n   - 사용 가능도가 높을수록 반환 시간이 감소한다.\r\n\r\n### 운영체제의 운영 방식\r\n\r\n1. 일괄 처리 시스템(Batch Processing System)\r\n   - 일정량 또는 일정 기간 동안 데이터를 한꺼번에 모아서 처리하는 방식이다.\r\n   - 운영체제 운용 방식 중 시대적으로 가장 먼저 생겨났다.\r\n   - ex. 수도요금 계산 업무, 월급 계산 업무 등\r\n2. 다중 프로그래밍 시스템(Multi programming System)\r\n   - 컴퓨터 시스템 자원 활용률을 극대화하기 위해 2개 이상의 프로그램을 주기억 장치에 기억시키고 CPU를 번갈아 사용하면서 처리하는 방식이다.\r\n3. 시분할 시스템(Time Sharing System)\r\n   - CPU의 전체 사용 시간을 작은 작업 시간량(Time Slice)으로 나누어서 그 시간량 동안만 번갈아 가면서 CPU를 할당하여 각 작업을 처리하는 방식이다.\r\n   - 실제로 많은 사용자가 하나의 컴퓨터를 공유하고 있지만 마치 자신만이 컴퓨터 시스템을 독점하여 사용하고 있는 것처럼 느끼게 된다.\r\n4. 다중 처리 시스템(Multi-Processing System)\r\n   - 동시에 프로그램을 수행할 수 있는 CPU를 두 개 이상 두고 각각 그 업무를 분담하여 처리할 수 있는 방식이다.\r\n5. 실시간 처리 시스템(Real Time Processing System)\r\n   - 데이터 발생 즉시, 또는 데이터 처리 요구가 있는 즉시 처리하여 결과를 산출하는 방식이다.\r\n   - 정해진 시간에 반드시 수행되어야 하는 작업들을 처리할 때 가장 정합하다.\r\n   - ex. 항공기 예약 업무, 은행 창구 업무, 조회 및 질의 업무 등\r\n6. 다중 모드 시스템(Multi-mode System)\r\n   - 일괄 처리 + 시분할 + 다중 처리 + 실시간 처리\r\n7. 분산 처리 시스템(Distributed Processing System)\r\n   - 여러 대의 컴퓨터로 작업을 나누어 처리하여 그 내용이나 결과를 통신망을 이용하여 상호 교환되도록 연결하는 방식이다.\r\n\r\n# 프로세스(Process)\r\n\r\n### 프로세스의 정의\r\n\r\n- 실행 중인 프로그램이다.\r\n- 실행 가능한 PCB를 가진 프로그램이다.\r\n- 프로세서가 할당되는 실체이다.\r\n- 프로시저가 활동 중인 것이다.\r\n- 비동기적 행위를 일으키는 주체이다.\r\n\r\n### 프로세스 제어 블록(PCB: Process Control Block)\r\n\r\n- 운영체제가 프로세스를 관리하기 위해 프로세스에 대한 중요한 정보를 저장해 놓은 곳이다.\r\n- 프로세스가 생성될 때마다 고유의 PCB가 생성되며, 프로세스가 소멸되면 PCB도 소멸된다.\r\n- PCB에 저장되어 있는 정보 : 프로세스의 현재 상태, 프로세스의 우선순위, 프로세스에 할당된 자원에 대한 정보, CPU 레지스터 정보\r\n\r\n### 프로세스 상태 전이\r\n\r\n```\r\n생성(New) -\u003e 준비(Ready) -(디스패치-Dispatch)-\u003e 실행(Run) -\u003e 종료(Exit)\r\n                ↑        \u003c-(Timer Runout)-    ↙\r\n             Wake Up            Block ←-------\r\n                |           ↙\r\n           대기(Blocked) ←--\r\n```\r\n\r\n- 준비 상태(Ready State)\r\n  - 프로세스가 CPU를 할당받기 위해 준비하고 있는 상태이다.\r\n- 실행 상태(Running State)\r\n  - 준비 상태의 프로세스가 CPU를 할당받아 실행 중인 상태이다.\r\n  - 디스패치(Dispatch) : 우선순위가 가장 높은 프로세스가 준비 상태에서 실행 상태로 전환되는 것이다.\r\n  - 할당 시간 종료(Time Runout) : 실행 상태의 프로세스가 할당 시간(타이머)이 종료되어 준비 상태로 전환되는 것이다.\r\n- 대기 상태(Blocked State)\r\n  - 실행 상태의 프로세스가 종료되기 전에 입/출력 등의 다른 작업이 필요할 경우 CPU를 반납하고 작업의 완료를 기다리는 상태이다.\r\n  - 블록(Block) : 실행 상태에서 대기 상태로 전환되는 것이다.\r\n  - 웨이크 업(Wake Up) : 대기 상태의 프로세스가 웨이크업(조건 만족)되면 준비 상태로 전환된다.\r\n\r\n### 스레드(Thread)\r\n\r\n- 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위를 의미한다.\r\n- 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.\r\n- 한 개의 프로세스는 여러 개의 스레드를 가질 수 있다.\r\n\r\n## 프로세스 스케줄링(Process Scheduling)\r\n\r\n- 프로세스의 생성 및 실행에 필요한 시스템의 자원을 해당 프로세스에 할당하는 작업이다.\r\n- 다중 프로그래밍 운영체제에서 자원의 성능을 향상시키고 효율적인 프로세서의 관리를 위해 작업 순서를 결정하는 것이다.\r\n\r\n### 프로세스 스케줄링 기법\r\n\r\n#### 비선점(Non-Preemptive) 스케줄링\r\n\r\n1. FIFO(First in Fist Out)\r\n   - 준비 상태 큐에 도착한 순서대로 CPU를 할당하는 기법이다.\r\n   - FCFS(Fist Come First Service)라고도 한다.\r\n2. SJF(Shortest Job First)\r\n   - 준비 상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 스케줄링 기법이다.\r\n   - 평균 대기 시간을 최소화한다.\r\n3. HRN(Highest Responseratio Next)\r\n   - 어떤 작업이 서비스받을 시간과 그 작업이 서비스를 기다린 시간으로 결정되는 우선순위에 따라 CPU를 할당하는 기법이다.\r\n   - 우선순위 계산식 = (대기 시간 + 서비스를 받을 시간) / 서비스를 받을 시간\r\n4. 우선순위(Priority)\r\n   - 준비 상태 큐에서 대기하는 프로세스에게 부여된 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법이다.\r\n   - 우선순위가 낮은 프로세스는 무한 정지(Indefinite Blocking)가 발생할 수 있으며, 에이징(Aging) 기법으로 이를 해결할 수 있다.\r\n\r\n#### 선점(Preemptive) 스케줄링\r\n\r\n- 한 프로세스가 CPU를 할당받아 실행 중이라도 우선순위가 높은 다른 프로세스가 CPU를 강제적으로 뺴앗을 수 있는 방식이다.\r\n- 긴급하고 높은 우선순위의 프로세스들이 빠르게 처리될 수 있다.\r\n- 선점을 위한 시간 배당에 대한 인터럽트용 타이머 클럭(Clock)이 필요하다.\r\n- 온라인 응용에 적합한 스케줄링이다.\r\n- 종류\r\n  - RR(Round Robin)\r\n    - 주어진 시간 할당량(Time Slice) 안에 작업을 마치지 않으면 준비 상태 큐의 가장 뒤로 배치된다.\r\n    - 시분할 시스템(Time-sharing System)을 위해 고안된 방식이다.\r\n    - 시간 할당량이 커지면 FCFS 스케줄링과 같은 효과를 얻을 수 있다.\r\n    - 시간 할당이 작아지면 프로세스 문맥 교환이 자주 일어난다.\r\n  - SRT(Shortest Remainig Time)\r\n    - 작업이 끝나기까지의 실행시간 추정치가 가장 작은 작업을 먼저 실행시키는 기법이다.\r\n    - FIFO 기법보다 평균 대기 시간이 감소된다.\r\n    - 작업 시간이 큰 경우 오랫동안 대기하여야 한다.\r\n  - 다단계 큐(Multi-Level Queue)\r\n    - 프로세스들을 우선순위에 따라 상위, 중위, 하위 단계의 단계별 준비 상태 큐를 배치하는 기법이다.\r\n  - 다단계 피드백 큐(Multi-Level Feedback Queue)\r\n    - 각 준비 상태 큐마다 부여된 시간 할당량 안에 완료하지 못한 프로세스는 다음 단계의 준비 상태 큐로 이동하는 기법이다.\r\n\r\n# OST(Open Systems Interconnection) 7계층 ★★★\r\n\r\n1. 물리 계층(Physical Layer)\r\n   - 물리적인 장치와 인터페이스가 전송을 위해 필요한 기계적, 전기적, 기능적, 절차적 기능을 정의하는 계층이다.\r\n   - 장치와 전송 매체 간의 인터페이스 특성 규정, 전송 매체의 유형 규정, 전송로의 연결, 유지 및 해제를 담당한다.\r\n   - 프로토콜 종류 : RS-232C, V.24, X.21\r\n2. 데이터 링크 계층(Data Link Layer)\r\n   - 인접한 두 개의 통신 시스템 간에 신뢰성 있는 효율적인 데이터를 전송하는 계층이다.\r\n   - 링크의 설정과 유지 및 종료를 담당한다.\r\n   - 전송 데이터의 흐름 제어, 프레임 동기, 오류 제어 등을 수행한다.\r\n   - 링크의 효율성을 향상시킨다.\r\n   - 프로토콜 종류 : HDLC, PPP, LLC, LAPB, LAPD, ADCCP\r\n3. 네트워크 계층(Network Layer)\r\n   - 통신망을 통해 패킷을 목적지까지 전달하는 계층.\r\n   - 경로 설정 및 네트워크 연결 관리를 수행.\r\n   - 과도한 패킷 유입에 대한 폭주 제어 기능을 한다.\r\n   - 프로토콜 종류 : X.25, IP, ICMP, IGMP\r\n4. 전송 계층(Transport Layer)\r\n   - 통신 종단 간(End-to-End) 신뢰성 있고 효율적인 데이터를 전송하는 계층이다.\r\n   - 투명한 데이터 전송을 제공한다.\r\n   - 에러 제어 및 흐름 제어를 담당한다.\r\n   - 프로토콜 종류 : TCP, UDP\r\n5. 세션 계층(Session Layer)\r\n   - 프로세스 간에 대한 연결을 확립, 관리, 단절시키는 수단을 제공한다.\r\n   - 논리적 동기 제어, 긴급 데이터 전송, 통신 시스템 간의 회화 기능 등을 제공한다.\r\n6. 표현 계층(Presentation Layer)\r\n   - 응용 간의 대화 제어(Dialogue Control)을 담당한다.\r\n   - 응용 계층과 세션 계층 사이에서 데이터 변환을 담당한다.\r\n   - 정보의 형식 설정, 암호화, 데이터 압축, 코드 변환, 문맥 관리 등의 기능을 수행한다.\r\n   - 긴 파일 전송 중에 통신 상태가 불량하여 트랜스포트 연결이 끊어지는 경우 처음부터 다시 전송하지 않고 어디까지 전송이 진행되었는지를 나타내는 동기점을 이용하여 오류를 복구한다.\r\n7. 응용 계층(Application Layer)\r\n   - 사용자에게 서비스를 제공한다.\r\n   - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.\r\n   - 프로토콜 종류 : HTTP, FTP, SMTP, Telnet, DNS\r\n\r\n# TCP/IP 프로토콜(Transmission Control Protocol/Internet Protocol)\r\n\r\n- 인터넷에 연결된 서로 다른 기종의 컴퓨터 간에 데이터 송/수신이 가능하도록 도와주는 표준 프로토콜이다.\r\n- TCP 프로토콜과 IP 프로토콜의 결합적 의미로서 TCP가 IP보다 상위층에 존재한다.\r\n- 접속형 서비스, 전이중 전송 서비스, 신뢰성 서비스를 제공한다.\r\n- 네트워크 환경에 따라 여러 개의 프로토콜을 허용한다.\r\n- TCP 프로토콜의 기본 헤더 크기는 20byte이고 60byte까지 확장 가능하다.\r\n- OSI 표준 프로토콜과 가까운 네트워크 구조를 가진다.\r\n  - OSI 7계층 : 물리, 데이터, 네트워크, 전송, 세션, 표현, 응용 계층\r\n  - TCP/IP 4계층 : 링크, 인터넷, 전송, 응용 계층\r\n\r\n### TCP(Transmission Control Protocol)\r\n\r\n- OSI 7계층의 전송 계층의 역할을 수행한다.\r\n- 서비스 처리를 위해 Multiplexing과 DeMultiplexing을 이용한다.\r\n- 전이중 서비스와 스트림 데이터 서비스를 제공한다.\r\n\r\n### IP(Internet Protocol)\r\n\r\n- OSI 7계층의 네트워크 계층에 해당하며 비신뢰성 서비스를 제공한다.\r\n\r\n## TCP/IP의 구조\r\n\r\n### 링크 계층(Link Layer)\r\n\r\n- 프레임을 송/수신한다.\r\n- 프로토콜의 종류 : Ethernet, IEEE 802, HDLC, X.25, RS-232C 등\r\n\r\n### 인터넷 계층(Internet Layer)\r\n\r\n- 주소 지정, 경로 설정을 제공한다.\r\n- 네트워크 계층이라고도 한다.\r\n- 프로토콜 종류 : IP, ICMP, IGMP, ARP, RARP 등\r\n  - IP(Internet Protocol)\r\n    - 비연결형 및 비신뢰성 전송 서비스를 제공한다.\r\n    - 라우팅과 단편화 기능을 수행한다.\r\n    - 데이터그램(Datagram)이라는 데이터 전송 형식을 가진다.\r\n    - 각 데이터그램이 독립적으로 처리되고 목적지까지 다른 경로를 통해 전송될 수 있어 데이터그램은 전송 순서와 도착 순서가 다를 수 있다.\r\n    - 비연결성이기 때문에 송신지가 여러 개인 데이터 그램을 보내면서 순서가 뒤바뀌어 도달할 수 있으며 IP 프로토콜의 헤더 길이는 최소 20~60byte이다.\r\n  - ICMP(Internet Control Message Protocol)\r\n    - IP 프로토콜에서는 오류 보고와 수정을 위한 메커니즘이 없기 때문에 이를 보완하기 위해 설계된 프로토콜이다.\r\n    - 메시지는 크게 오류 보고(Error-Reporting) 메시지와 질의(Query) 메시지로 나눌 수 있다.\r\n    - 메시지 형식은 8바이트의 헤더와 가변 길이의 데이터 영역으로 분리된다.\r\n    - 에코 메시지는 호스트가 정상적으로 동작하는지를 결정하는데 사용할 수 있다.\r\n    - 수신지 도달 불가 메시지는 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는데 사용한다.\r\n  - IGMP(Internet Group Management Protocol)\r\n    - 시작지 호스트에서 여러 목적지 호스트로 데이터를 전송할 때 사용되는 프로토콜이다.\r\n    - 멀티캐스트 그룹에 가입한 네트워크 내의 호스트를 관리한다.\r\n  - ARP 20.9(Address Resolution Protocol)\r\n    - 논리 주소(IP 주소)를 물리 주소(MAC 주소)로 변환하는 프로토콜이다.\r\n    - 네트워크에서 두 호스트가 성공적으로 통신하기 위해 각 하드웨워의 물리적인 주소 문제를 해결해 줄 수 있다.\r\n  - RARP(Reverse Address Resolution Protocol)\r\n    - 호스트의 물리 주소(MAC 주소)로부터 논리 주소(IP 주소)를 구하는 프로토콜이다.\r\n    - IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP 주소를 모르는 경우, 서버에게 IP 주소를 요청하기 위해 사용한다.\r\n\r\n### 전송 계층(Transport Layer)\r\n\r\n- 호스트 간 신뢰성 있는 통신을 제공한다.\r\n- 프로토콜 종류 : TCP, UDP\r\n  - TCP 20.8(Transmission Control Protocol)\r\n    - 신뢰성 있는 연결 지향형 전달 서비스를 제공한다.\r\n    - 순서 제어, 에러 제어, 흐름 제어 기능을 제공한다.\r\n    - 전이중 서비스와 스트림 데이터 서비스를 제공한다.\r\n    - 메시지를 캡슐화(Encapsulation)와 역캡슐화(Decapsulation)한다.\r\n    - 서비스 처리를 위해 다중화(Multiplexing)와 역다중화(Demultiplexing)를 이용한다.\r\n  - UDP 20.9(User Datagram Protocol)\r\n    - 비연결형 및 비신뢰성 전송 서비스를 제공한다.\r\n    - 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.\r\n    - 수신된 데이터의 순서 재조정 기능을 지원하지 않는다.\r\n    - 복구 기능을 제공하지 않는다.\r\n\r\n# IP 주소 ★★★\r\n\r\n### IPv4(Internet Protocol version 4)\r\n\r\n- 32비트 길이의 IP주소이다.\r\n- 주소의 각 부분을 8비트씩 4개로 나눠서 10진수로 표현한다.\r\n- IP 주소 = 네트워크 주소(Netid) + 호스트 주소\r\n\r\n#### IPv4의 주소 체계\r\n\r\n- 클래스 A\r\n  - 0.0.0.0 ~ 127.255.255.255\r\n  - 기본 서브넷 마스크 : 255.0.0.0\r\n  - 국가나 대형 통신망에서 사용한다.\r\n- 클래스 B\r\n  - 128.0.0.0 ~ 191.255.255.255\r\n  - 기본 서브넷 마스크 : 255.255.0.0\r\n  - 중대형 통신망에서 사용한다.\r\n- 클래스 C\r\n  - 192.0.0.0 ~ 223.255.255.255\r\n  - 기본 서브넷 마스크 : 255.255.255.0\r\n  - 소규모 통신망에서 사용한다.\r\n- 클래스 D\r\n  - 224.0.0.0 ~ 239.255.255.255\r\n  - 멀티캐스트용으로 사용한다.\r\n- 클래스 E\r\n  - 240.0.0.0 ~ 255.255.255.255\r\n  - 실험용으로 사용한다.\r\n\r\n### IPv6(Internet Protocol version 6)\r\n\r\n- IPv4의 주소 부족 문제를 해결하기 위해 개발되었다.\r\n- 128비트 길이의 IP 주소이다.\r\n- 16비트씩 8개의 필드로 분리 표기된다.\r\n\r\n#### IPv6의 장점\r\n\r\n- 인증 보안 기능을 포함하고 있어 IPv4보다 보안성이 강화되었다.\r\n- IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다.\r\n- 임의의 크기의 패킷을 주고받을 수 있도록 패킷 크기 제한이 없다.\r\n- 멀티미디어의 실시간 처리가 가능하다.\r\n- 자동으로 네트워크 환경 구성이 가능하다.\r\n- 주소체계는 유니캐스트(Unicast), 애니캐스트(Anycast), 멀티캐스트(Multicast) 등 세 가지로 나뉜다.\r\n\r\n#### IPv6의 통신 방식 20.6\r\n\r\n- 유니캐스트(Unicast)\r\n  - 하나의 호스트에서 다른 하나의 호스트에게 전달하는 1:1 통신 방식이다.\r\n- 애니캐스트(Anycast)\r\n  - 하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달하는 '1: 가장 가까운 1' 통신 방식이다.\r\n- 멀티캐스트(Multicast)\r\n  - 하나의 호스트에서 네트워크상의 특정 그룹 호스트들에게 전달하는 1:N 통신 방식이다.\r\n\r\n### 서브넷 마스크(Subnet Mask)\r\n\r\n- 네트워크를 작은 내부 네트워크로 분리하여 효율적으로 네트워크를 관리하기 위한 수단이다.\r\n- 서브넷 마스크는 32비트의 값으로 IP 주소를 네트워크와 호스트 IP 주소를 구분하는 역할을 한다.\r\n- 네트워크 ID에 해당하는 모든 비트를 1로 설정하며, 호스트 ID에 해당하는 모든 비트를 0으로 설정한다.\r\n- CIDR 표기 형식 : 10진수의 IP/네트워크 ID의 1비트의 개수\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n"},"__N_SSG":true},"page":"/[slug]","query":{"slug":"sw-first-test4"},"buildId":"pJ0C1SW6Dpnf8b5e1YSeC","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>