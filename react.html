<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Rain Sugar BangBang Front-End</title><meta name="description" content="developer&#x27;s blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta http-equiv="subject" content="react"/><meta property="og:title" content="Rain Sugar BangBang"/><meta property="og:description" content="welcome to developer&#x27;s blog"/><meta property="og:image" content="/images/cards/REACT.png"/><meta name="naver-site-verification" content="af9c8049662a7c6c85ea946e9eb561086e70062c"/><meta name="google-site-verification" content="Zgp7rA3RAdcRnhPPsGLK-t4KVTO86AejlDIQQIGpvLg"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4077287316160146" crossorigin="anonymous"></script><link rel="icon" href="/favicon.ico"/><link rel="preload" as="image" href="/images/cards/REACT.png"/><meta name="next-head-count" content="13"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/f9bc783e634631d2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f9bc783e634631d2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7d0bddee48749f95.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-b0c8bcfd40968c52.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9ab2984ff460f65e.js" defer=""></script><script src="/_next/static/chunks/789-6e729330f76e9f3d.js" defer=""></script><script src="/_next/static/chunks/pages/react-6e85d367c24cca35.js" defer=""></script><script src="/_next/static/OV20HWrLkXuRM8jaFvyc0/_buildManifest.js" defer=""></script><script src="/_next/static/OV20HWrLkXuRM8jaFvyc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-c845a976-0 icUnkm"><header class="sc-fe6a8-0 fZHroo"><span style="display:none" class="sc-fe6a8-1 kOlYBJ"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 17 17" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g></g><path d="M16 3v2h-15v-2h15zM1 10h15v-2h-15v2zM1 15h15v-2h-15v2z"></path></svg></span><h1><a href="/">Rain Sugar BangBang</a></h1><span style="display:none" class="sc-fe6a8-1 kOlYBJ"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg></span></header><section class="sc-c845a976-1 bePtAz"><aside class="sc-226f6af7-0 jzKfYm"><div class="sc-226f6af7-1 eudLNA"><a target="_blank" href="https://portfolio-sigma-wheat-63.vercel.app/"><img alt="profile" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" src="/images/profileImage/cat.png"/><span>Go Profile!</span></a><p>Hanbbi</p></div><div class="sc-226f6af7-2 fEJwOM"><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0 0 68.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"></path></svg><span>yhl0078@gmail.com</span></a><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>Github</span></a></div></aside><article class="sc-c845a976-2 jRRSKe"><div class="sc-b797c1b7-0 jSiudw"><div class="sc-b797c1b7-1 ctQsiT"><span>전체 글<!-- --> (<!-- -->16<!-- -->)</span><form><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg><input type="text" style="opacity:0" placeholder="키워드 입력 후 엔터를 눌러주세요" class="sc-15314a72-0 bDAivC"/></form></div><ul class="sc-b797c1b7-2 dwTYwt"><a href="/react-common-components"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/REACT.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>React 공통 컴포넌트 제작 (input, button...</p><span>2023. 04. 13</span></div></li></a><a href="/react-type-assertion"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/REACT.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>React Form event type (feat. 타입...</p><span>2023. 04. 13</span></div></li></a><a href="/react-smooth-scroll"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/REACT.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>React/Javascript 부드러운 스크롤 이동 적용...</p><span>2023. 03. 25</span></div></li></a><a href="/react-component-lifecycle"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/REACT.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>React 함수형 컴포넌트와 Class형 컴포넌트 생명주...</p><span>2023. 03. 23</span></div></li></a><a href="/react-memo"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/REACT.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>React.memo() 를 통한 컴포넌트 최적화</p><span>2023. 03. 16</span></div></li></a><a href="/react-usecallback"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/REACT.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>useCallback을 이용한 컴포넌트 최적화하기</p><span>2023. 03. 16</span></div></li></a></ul><ul class="sc-4a3f34e2-0 dBfZty"><li class="noPrev"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z"></path></svg></li><li id="1" class="activePage">1</li><li id="2" class="page">2</li><li id="3" class="page">3</li><li class=""><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z"></path></svg></li></ul></div></article><aside class="sc-7eadfa91-0 cYGwoY"><nav class="sc-32fda5e8-0 eZaEbO"><ul class="sc-32fda5e8-1 hkagAC"><p>Category</p><div><p class="sc-32fda5e8-2 lkubIK">FE</p><li class="sc-32fda5e8-3 nVQIN"><a href="/html">HTML</a></li><li class="sc-32fda5e8-3 nVQIN"><a href="/css">CSS</a></li><li class="sc-32fda5e8-3 nVQIN"><a href="/javascript">JavaScript</a></li><li class="sc-32fda5e8-3 nVQIN"><a href="/typescript">TypeScript</a></li><li class="sc-32fda5e8-3 nVQIN"><a href="/redux">Redux</a></li><li class="sc-32fda5e8-3 nVQIN"><a style="color:white;font-weight:bold" href="/react">React</a></li><li class="sc-32fda5e8-3 nVQIN"><a href="/nextjs">Nextjs</a></li></div><div><p class="sc-32fda5e8-2 lkubIK">BE</p><li class="sc-32fda5e8-3 nVQIN"><a href="/nestjs">Nestjs</a></li></div><div><p class="sc-32fda5e8-2 lkubIK">CS</p><li class="sc-32fda5e8-3 nVQIN"><a href="/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC">정보처리기사</a></li></div><div><p class="sc-32fda5e8-2 lkubIK">ETC</p><li class="sc-32fda5e8-3 nVQIN"><a href="/github">Simple Memo</a></li></div></ul></nav></aside></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"react common components","description":"React 공통 컴포넌트 제작 (input, button)","category":"react","date":"2023-04-13","content":"\r\n## 공통 컴포넌트 제작의 필요성\r\n\r\n\u003e 하나의 사이트를 제작할때 비슷한 input이나 button을 사용해야 하는 상황이 자주 있는데, 공통된 컴포넌트를 만들어 놓으면 코드 중복을 줄이면서 상황에 맞춰 적절하게 사용할 수 있게 된다.\r\n\r\n## 컴포넌트 제작\r\n\r\n### Input\r\n\r\n```typescript\r\nimport React from \"react\"; // element 속성을 가져오기 위해 import\r\nimport styled from \"styled-components\"; // CSS 적용\r\n\r\n// 컴포넌트의 props 타입을 InputElement의 속성과 내가 설정하고자 하는 타입을 포함한다.\r\ntype Props = React.HTMLAttributes\u003cHTMLInputElement\u003e \u0026 InputProps;\r\n\r\ninterface InputProps {\r\n  type?: string | undefined; // type?: 의 ?는 있어도 되고 없어도 된다는 의미\r\n  name?: string | undefined;\r\n  autoComplete?: string | undefined;\r\n  width: string;\r\n  height: string;\r\n  border?: string | undefined;\r\n}\r\n\r\n// width와 height는 number로 지정해도 무관하나,\r\n// 상황에 따라 뷰포트에 맞춰 쓸지, px에 맞춰 쓸지 달라질 수 있기 때문에 string으로 설정한 경우\r\n\r\nexport const MainInput = ({\r\n  type,\r\n  name,\r\n  autoComplete,\r\n  width,\r\n  height,\r\n  border,\r\n  ...props\r\n}: Props) =\u003e {\r\n  return (\r\n    \u003cMain\r\n      // input이 갖고 있는 속성을 사용할 수 있도록 도와준다. (placeholder, onChange 등 속성과 이벤트들)\r\n      {...props}\r\n      name={name}\r\n      autoComplete={autoComplete || \"on\"}\r\n      type={type || \"text\"}\r\n      style={{\r\n        width: `${width}`,\r\n        height: `${height}`,\r\n        border: `${border \u0026\u0026 border !== \"\" ? `1px solid ${border}` : \"\"}`,\r\n      }}\r\n    /\u003e\r\n  );\r\n};\r\n\r\nconst Main = styled.input`\r\n  padding: 5px;\r\n  border: none;\r\n  border: 1px solid ${props =\u003e props.theme.inputBorderColor};\r\n  border-radius: 5px;\r\n  font-size: 1.2rem;\r\n  \u0026:hover {\r\n    background: ${props =\u003e props.theme.inputBorderColor};\r\n  }\r\n  \u0026:focus {\r\n    outline: none;\r\n    border-color: ${props =\u003e props.theme.hoverBorderColor};\r\n    box-shadow: 0 0 1px ${props =\u003e props.theme.hoverBorderColor};\r\n  }\r\n`;\r\n```\r\n\r\n### TextArea\r\n\r\n```typescript\r\ntype TaProps = React.HTMLAttributes\u003cHTMLTextAreaElement\u003e \u0026 TextAreaProps;\r\ninterface TextAreaProps {\r\n  name?: string | undefined;\r\n  width: string;\r\n  height: string;\r\n  border?: string | undefined;\r\n}\r\n\r\nexport const MainTextArea = ({\r\n  name,\r\n  width,\r\n  height,\r\n  border,\r\n  ...props\r\n}: TaProps) =\u003e {\r\n  return (\r\n    \u003cTextArea\r\n      {...props}\r\n      name={name}\r\n      autoComplete=\"off\"\r\n      style={{\r\n        width: `${width}`,\r\n        height: `${height}`,\r\n        border: `${border \u0026\u0026 border !== \"\" ? `1px solid ${border}` : \"\"}`,\r\n      }}\r\n    /\u003e\r\n  );\r\n};\r\n\r\nconst TextArea = styled.textarea`\r\n  padding: 5px;\r\n  border: none;\r\n  border: 1px solid ${props =\u003e props.theme.inputBorderColor};\r\n  border-radius: 5px;\r\n  font-size: 1.2rem;\r\n  resize: none;\r\n  white-space: pre;\r\n  \u0026:hover {\r\n    background: ${props =\u003e props.theme.inputBorderColor};\r\n  }\r\n  \u0026:focus {\r\n    outline: none;\r\n    border-color: ${props =\u003e props.theme.hoverBorderColor};\r\n    box-shadow: 0 0 1px ${props =\u003e props.theme.hoverBorderColor};\r\n  }\r\n`;\r\n```\r\n\r\n## Button\r\n\r\n```typescript\r\ntype Props = React.HTMLAttributes\u003cHTMLButtonElement\u003e \u0026 ButtonProps;\r\n\r\ninterface ButtonProps {\r\n  type?: \"button\" | \"submit\" | \"reset\" | undefined; // 버튼 타입은 이와 같이 설정해준다.\r\n  content: string;\r\n  width: string;\r\n  height: string;\r\n}\r\n\r\nexport const MainButton = ({\r\n  type,\r\n  content,\r\n  width,\r\n  height,\r\n  ...props\r\n}: Props) =\u003e {\r\n  return (\r\n    \u003cMain\r\n      {...props}\r\n      type={type || \"button\"}\r\n      style={{ width: `${width}`, height: `${height}` }}\r\n    \u003e\r\n      {content}\r\n    \u003c/Main\u003e\r\n  );\r\n};\r\n\r\nconst Main = styled.button`\r\n  border: none;\r\n  border-radius: 5px;\r\n  background: none;\r\n  background-color: ${props =\u003e props.theme.mainButton};\r\n  color: ${props =\u003e props.theme.mainFontColor};\r\n  font-size: 1rem;\r\n  font-weight: bold;\r\n  cursor: pointer;\r\n  \u0026:hover {\r\n    background-color: ${props =\u003e props.theme.mainButtonHover};\r\n  }\r\n`;\r\n```\r\n"},{"title":"react type assertion","description":"React Form event type (feat. 타입 단언 as)","category":"react","date":"2023-04-13","content":"\r\n## Form Event Type\r\n\r\n우리는 로그인이나 포스팅 등의 화면을 만들어줄 때 클라이언트가 입력하는 데이터를 입력받는 방법 중 하나로 onChange 등의 FormEvent를 이용해 원하는 값을 추출할 수 있다. 이때 이벤트 타입은 아래와 같이 사용될 수 있다.\r\n\r\n```typescript\r\nimport { FormEvent } from \"react\";\r\n\r\nexport type FormEvents = FormEvent\u003cHTMLFormElement\u003e;\r\nexport type InputEvent = FormEvent\u003cHTMLInputElement\u003e;\r\nexport type LabelEvent = FormEvent\u003cHTMLLabelElement\u003e;\r\n```\r\n\r\nreact에서 FormEvent 타입을 받아오고, 해당되는 element를 제네릭 타입으로 넣어주면 된다.\r\n\r\n## onChangeHandler\r\n\r\n```typescript\r\nconst [formData, setFormData] = useState(formDataInit);\r\nconst formChangeHandler = (e: FormEvent\u003cHTMLFormElement\u003e) =\u003e {\r\n  const target = e.target;\r\n  const name = target.name;\r\n  const value = target.value;\r\n  setFormData(prev =\u003e ({ ...prev, [name]: value }));\r\n};\r\n```\r\n\r\n원하는 데이터를 받을 수는 있지만, name과 value의 타입 에러가 발생한다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F80Q0s%2Fbtr9SOPHzuW%2F7t6EmYi1k5gMiyeurxmCP0%2Fimg.png)\r\n\r\ntarget의 타입을 정해줘도 타입 에러가 발생하는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbsb5ww%2Fbtr9N2aq2VJ%2FsFJkJduLoSt1bhyae9SFdK%2Fimg.png)\r\n\r\n하지만 우리는 form의 input이 변할때마다 대상의 값을 받아오는 것을 알고 있다.\r\n\r\n이때 필요한 것이 타입 단언(as)이다.\r\n\r\n## 타입 단언 사용 예시\r\n\r\n```typescript\r\nconst formChangeHandler = (e: FormEvents) =\u003e {\r\n  const target = e.target as InputTarget; // InputTarget === HTMLInputElement\r\n  const name = target.name;\r\n  const value = target.value;\r\n  setFormData(prev =\u003e ({ ...prev, [name]: value }));\r\n};\r\n```\r\n\r\n### 주의사항\r\n\r\n타입 단언을 사용하면 타입 체크를 할 수 없다. 사실상 강제로 타입을 지정하는 행위이기 때문에 타입 체커에게 해당 타입 에러를 무시하라는 명령이나 다름없다. as를 남발하거나 내려받는 데이터가 확실하지 않는 경우에는 오류 탐색에 지장이 있을 수 있으니, 로직에 따라 조건문 등을 사용해 타입 에러를 피해 주는 것이 좋을 수 있다.\r\n\r\n```typescript\r\n// ex)\r\nconst someFN = (someData) =\u003e{\r\n\tconst someMutation = someData..logic\r\n    if(someMutation){\r\n    \t// ... nest logic\r\n    }\r\n}\r\n```\r\n"},{"title":"react smooth scroll","description":"React/Javascript 부드러운 스크롤 이동 적용","category":"react","date":"2023-03-25","content":"\r\n# **부드러운 스크롤 이동 적용 방법**\r\n\r\n\u003e behavior:\"smooth\" 속성을 scroll 이벤트와 scroll 메서드와 같이 사용하며 부드러운 스크롤 이동을 적용해볼 수 있다.\r\n\r\n본 보스팅은 Nextjs 13 환경에서 작성되었다.\r\n\r\n## **scroll() 메서드**\r\n\r\n### **scroll() , scrollTo()**\r\n\r\nscroll(x,y) || scroll(options), scrollTo(x,y) || scrollTo(options) 와 같이 사용할 수 있다.\r\n\r\n사실상 두 메서드는 동일하게 작동한다.\r\n\r\nxy 좌표를 통해서도 사용 가능하며 options를 적용한다면 아래와 같이 사용할 수 있다.\r\n\r\n```javascript\r\nwindow.scroll({\r\n  top: 0,\r\n  left: 0,\r\n  behavior: \"smooth\", // smooth: 부드럽게 전환 , auto: 즉시 이동\r\n});\r\n\r\nwindow.scrollTo({\r\n  top: 0,\r\n  left: 0,\r\n  behavior: \"smooth\", // smooth: 부드럽게 전환 , auto: 즉시 이동\r\n});\r\n```\r\n\r\n### **scrollBy()**\r\n\r\n**scrollBy(x,y) || scrollBy(options)**\r\n\r\nscroll()과 scrollTo()가 특정 좌표로 이동한다면, scrollBy는 길이만큼 스크롤을 이동시킨다.\r\n\r\n옵션과 예제는 아래와 같다.\r\n\r\n```javascript\r\n// 기본 사용\r\nwindow.scrollBy(x, y);\r\n\r\n// 한 페이지 아래\r\nwindow.scrollBy(0, window.innerHeight);\r\n\r\n// 한 페이지 위\r\nwindow.scrollBy(0, -window.innerHeight);\r\n\r\n// 옵션\r\nwindow.scrollBy({\r\n  top: 0,\r\n  left: 0,\r\n  behavior: \"smooth\", // smooth: 부드럽게 전환 , auto: 즉시 이동\r\n});\r\n```\r\n\r\nscroll 메서드가 적용된 화면과 예제코드\r\n\r\n![image](https://blog.kakaocdn.net/dn/bV3l2O/btr5OcgXBcx/ickRekJIOy3VMmRLtzt2pK/img.gif)\r\n\r\n```javascript\r\n// 최상단으로 이동\r\nconst moveScroll = () =\u003e {\r\n  scroll({ top: 0, behavior: \"smooth\" });\r\n};\r\n\r\n// 한 페이지 위로 이동\r\nconst moveScrollByUp = () =\u003e {\r\n  scrollBy({ top: -window.innerHeight, behavior: \"smooth\" });\r\n};\r\n\r\n// 한 페이지 아래로 이동\r\nconst moveScrollByDown = () =\u003e {\r\n  scrollBy({ top: window.innerHeight, behavior: \"smooth\" });\r\n};\r\n\r\n// top 500 위치로 이동\r\nconst moveScrollTo = () =\u003e {\r\n  scrollTo({\r\n    top: 500,\r\n    behavior: \"smooth\",\r\n  });\r\n};\r\n\r\n// jsx\r\n\u003cContainer\u003e\r\n  \u003cNavBtn\u003e\r\n    \u003cbutton onClick={moveScroll}\u003eScroll최상단\u003c/button\u003e\r\n    \u003cbutton onClick={moveScrollByUp}\u003emoveScrollByUp\u003c/button\u003e\r\n    \u003cbutton onClick={moveScrollByDown}\u003emoveScrollByDown\u003c/button\u003e\r\n    \u003cbutton onClick={moveScrollTo}\u003emoveScrollTo\u003c/button\u003e\r\n  \u003c/NavBtn\u003e\r\n  \u003cTestContainer1 id=\"box1\" /\u003e\r\n  \u003cTestContainer2 id=\"box2\" /\u003e\r\n  \u003cTestContainer3 id=\"box3\" /\u003e\r\n  \u003cTestContainer4 id=\"box4\" /\u003e\r\n  \u003cTestContainer5 id=\"box5\" /\u003e\r\n  \u003cTestContainer6 id=\"box6\" /\u003e\r\n\u003c/Container\u003e;\r\n```\r\n\r\n## **Chrome 브라우저에서 behavior:\"smooth\" 속성이 적용되지 않을 때**\r\n\r\n아래와 같이 크롬 버전은 최신이지만, smooth 속성이 적용되지 않는 현상이 나타났다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fx3Fal%2Fbtr5ORwXdp3%2FAHsT7DB2D5i76OjhYqcN9k%2Fimg.png)\r\n\r\n![image](https://blog.kakaocdn.net/dn/bourLn/btr5NyrsLbU/nkulo83V1NSn2kEMQb2xYK/img.gif)\r\n\r\n호환성에도 문제가 없지만 MDN의 예제를 실행해 봐도 크롬에선 smooth 속성이 사용되지 않았다.\r\n\r\nMDN 스크롤 예제 : https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmJ1Dl%2Fbtr5Nv2OZvD%2Fmk5c6Hks8ai7J4UKhL6wR1%2Fimg.png)\r\n\r\n크롬 브라우저 설정을 따로 해주면 해결된다고는 하지만, 내 PC에서만 작동하는 건 근본적인 해결방법이 아니기 때문에 배제했다.\r\n\r\n참조 : http://www.devdic.com/css/refer/properties/property:1195/scroll-behavior\r\n\r\n### **smoothscroll-polyfill - 적용 실패**\r\n\r\n사용법 : https://www.npmjs.com/package/smoothscroll-polyfill?activeTab=readme\r\n\r\n```typescript\r\n// 패키지 설치\r\n// yarn add smoothscroll-polyfill\r\n\r\n// 최상단 파일\r\n\r\nimport smoothscroll from \"smoothscroll-polyfill\";\r\n\r\nif (typeof window !== \"undefined\") {\r\n  smoothscroll.polyfill();\r\n}\r\n```\r\n\r\n브라우저 호환성 적용을 위한 패키지라고 하는데, 본인에겐 효과가 없었다.\r\n\r\n## **scroll 이벤트를 통한 스크롤 이동 적용**\r\n\r\n스크롤만 이용해서 기능을 적용할 생각이었기에 직접 만들기로 했다.\r\n\r\naddEventListener를 통해 스크롤 이벤트를 감지해 주는 hook을 만들어줬다.\r\n\r\n```typescript\r\n// 스크롤 위 아래 여부 확인\r\nimport { useState, useEffect, useRef } from \"react\";\r\n\r\ninterface MutableRefObject\u003cT\u003e {\r\n  current: T;\r\n}\r\n\r\nexport const useScroll = () =\u003e {\r\n  const [scrollCheck, setScrollCheck] = useState(\"\");\r\n  const prevScrollPos: MutableRefObject\u003cnumber\u003e = useRef(0);\r\n\r\n  useEffect(() =\u003e {\r\n    const handleScroll = () =\u003e {\r\n      const currentScrollPos = window.pageYOffset; // window객체의 pageYOffset 를 통해 현재 스크롤 위치 저장\r\n      if (currentScrollPos \u003e prevScrollPos.current) {\r\n        // 스크롤 위치에 따른 스크롤 진행 방향 검증\r\n        setScrollCheck(\"DOWN\");\r\n      } else {\r\n        setScrollCheck(\"UP\");\r\n      }\r\n      prevScrollPos.current = currentScrollPos; // 사용된 현재 스크롤 위치를 다음 이벤트 비교대상으로 저장\r\n    };\r\n\r\n    window.addEventListener(\"scroll\", handleScroll); // event 등록\r\n    return () =\u003e {\r\n      window.removeEventListener(\"scroll\", handleScroll); // event clear\r\n    };\r\n  }, [prevScrollPos]);\r\n  return {\r\n    scrollCheck, // up/down 여부 return\r\n  };\r\n};\r\n\r\n// hook 사용 컴포넌트\r\nimport { useScroll } from \"@/hooks/useScroll\";\r\nconst { scrollCheck } = useScroll();\r\nuseEffect(() =\u003e {\r\n  if (scrollCheck === \"UP\") {\r\n    console.log(\"scroll UP\");\r\n  }\r\n  if (scrollCheck === \"DOWN\") {\r\n    console.log(\"scroll DOWN\");\r\n  }\r\n}, [scrollCheck]);\r\n```\r\n\r\n원하는 값이 잘 나오는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FF7CNJ%2Fbtr5QzP3p9N%2FErlbv8julxnc1PKZSGRC71%2Fimg.png)\r\n\r\n\u003e 스크롤 이벤트 특성상 한 번 휠을 돌릴 때마다 많은 호출이 일어나기 때문에 필요한 경우에만 사용될 수 있도록 setTimeout 등을 통해 적용하고자 하는 코드에 맞게 함수 실행을 조절해줘야 한다.\r\n\r\n```typescript\r\nimport { useState, useEffect, useRef } from \"react\";\r\nimport { scrollToSmoothly } from \"@/components/profile/SmoothScroll\";\r\nimport { useScroll } from \"@/hooks/useScroll\";\r\nconst { scrollCheck } = useScroll();\r\nconst scrollRef = useRef({\r\n  // window.innerHeight 값 저장\r\n  height: 0,\r\n});\r\n\r\nconst smoothScrollHandler = () =\u003e {\r\n  let maxHeight = window.innerHeight * 6; // 최대 스크롤 길이\r\n  let currentHeight = scrollRef.current.height; // 현재 스크롤 저장\r\n  if (scrollCheck === \"UP\" \u0026\u0026 currentHeight !== 0) {\r\n    // scroll up이고 맨 위가 아닐 때\r\n    scrollRef.current.height -= window.innerHeight; // useRef에 이동할 height 조정\r\n    scrollToSmoothly(scrollRef.current.height, 500); // 이동할 height까지 500ms동안 이동시킬 함수 (requestAnimationFrame 사용)\r\n  } else if (scrollCheck === \"DOWN\" \u0026\u0026 currentHeight !== maxHeight) {\r\n    // scroll이 down이고 맨 아래가 아닐 때\r\n    scrollRef.current.height += window.innerHeight; // 상기 동일\r\n    scrollToSmoothly(scrollRef.current.height, 500);\r\n  }\r\n};\r\n\r\nuseEffect(() =\u003e {\r\n  smoothScrollHandler();\r\n}, [scrollCheck]); // useScroll()을 통해 구분한 UP/Down이 변경될 때마다 실행\r\n```\r\n\r\n위의 함수를 실행하면 아래와 같이 그나마 정상 작동하는 모습을 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/cpwxY9/btr5NJNGHOP/34qTHrvGprHknp2jmkpkpK/img.gif)\r\n\r\n## **a 태그를 통한 스크롤 이동**\r\n\r\na 태그의 href 속성을 이용해 간단하게 스크롤을 이동시키는 방법도 있다.\r\n\r\n```javascript\r\n\u003cProfileContainer\u003e\r\n  \u003cNavBtn\u003e\r\n    \u003cLink href=\"#box1\"\u003e1번박스로 이동\u003c/Link\u003e // nextjs에서 Link는 a태그의 역할을\r\n    한다.\r\n    \u003cLink href=\"#box2\"\u003e2번박스로 이동\u003c/Link\u003e // href에 스크롤을 이동시킬 'ID'를 입력하고\r\n    클릭하면\r\n    \u003cLink href=\"#box3\"\u003e3번박스로 이동\u003c/Link\u003e // 해당 ID요소로 스크롤을\r\n    이동시킨다.\r\n    \u003cLink href=\"#box4\"\u003e4번박스로 이동\u003c/Link\u003e\r\n    \u003cLink href=\"#box5\"\u003e5번박스로 이동\u003c/Link\u003e\r\n    \u003cLink href=\"#box6\"\u003e6번박스로 이동\u003c/Link\u003e\r\n  \u003c/NavBtn\u003e\r\n  \u003cTestContainer1 id=\"box1\" /\u003e\r\n  \u003cTestContainer2 id=\"box2\" /\u003e\r\n  \u003cTestContainer3 id=\"box3\" /\u003e\r\n  \u003cTestContainer4 id=\"box4\" /\u003e\r\n  \u003cTestContainer5 id=\"box5\" /\u003e\r\n  \u003cTestContainer6 id=\"box6\" /\u003e\r\n\u003c/ProfileContainer\u003e\r\n```\r\n\r\n---\r\n\r\n**참조**\r\n\r\n**scroll 메서드**\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/Window/scroll\r\n\r\n**requestAnimationFrame**\r\n\r\nhttps://developer.mozilla.org/ko/docs/Web/API/window/requestAnimationFrame\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp\r\n"},{"title":"react component lifecycle","description":"React 함수형 컴포넌트와 Class형 컴포넌트 생명주기","category":"react","date":"2023-03-23","content":"\r\n# **React state와 LifeCycle**\r\n\r\n\u003e 함수형 컴포넌트와 class형 컴포넌트의 LifeCycle이 어떻게 되는지 간단하게 비교해 보는 글이다.\r\n\r\n## 클래스형 컴포넌트와 생명주기 메서드\r\n\r\n### 1. Mount(컴포넌트가 처음 실행될 때)\r\n\r\n- state, context, defalutProps 저장\r\n- componentWillMount - 안전하지 않은 접근\r\n- render\r\n- componentDidMount - DOM 접근 가능\r\n\r\n### 2. Props Update(프롭스가 업데이트될때)\r\n\r\n- componentWillReceiveProps - 사용 종료\r\n- shouldComponentUpdate\r\n- componentWillUpdate - 사용 종료\r\n- render\r\n- componentDidUpdate - DOM 접근 가능\r\n\r\n### 3. State Update (스테이트가 업데이트됐을 때)\r\n\r\n- shouldComponentUpdate\r\n- componentWillUpdate - 사용 종료\r\n- render\r\n- componentDidUpdate - DOM 접근 가능\r\n\r\n**사실상 componentWillReceiveProps와 componentWillUpdate의 사용 종료로 state와 props가 업데이트될 때 동일하게 작동한다.**\r\n\r\n### 4. Unmount (컴포넌트가 제거되는 것)\r\n\r\n- componentWillUnmount\r\n\r\n사용 종료의 기준은 아래와 같다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb0qQTJ%2Fbtr5h96VtyB%2FqLpFZAk7aybC21CEWPD9H1%2Fimg.png)\r\n\r\n## 함수형 컴포넌트와 useEffect 훅\r\n\r\n### 컴포넌트의 실행\r\n\r\n- 함수형 컴포넌트 호출\r\n\r\n- 함수형 컴포넌트의 내부에서 실행\r\n\r\n- return()으로 화면에 렌더링\r\n\r\n- 생명주기 메서드 대신 useEffect를 통한 비슷한 처리 가능\r\n\r\n### dependency에 따른 useEffect의 실행\r\n\r\n- deps 값이 없는 경우 : 화면이 렌더링 된 이후 수행이 되며, 리렌더링이 발생할 때마다 다시 실행\r\n\r\n- deps 값이 빈 배열인 경우 : 첫 렌더링 완료 후 1회만 실행\r\n\r\n- deps 값이 존재하는 경우 : 첫 렌더링 완료 후 1회 실행 \u0026\u0026 deps 값이 변경되었을 경우마다 실행\r\n\r\n```javascript\r\n// dep X\r\nuseEffect(() =\u003e {\r\n  // effect\r\n  return () =\u003e {\r\n    // cleanup\r\n  };\r\n});\r\n\r\n// dep []\r\nuseEffect(() =\u003e {\r\n  return () =\u003e {};\r\n}, []);\r\n\r\n// dep [some dep...]\r\nuseEffect(() =\u003e {\r\n  return () =\u003e {};\r\n}, [dep]);\r\n```\r\n\r\n**[Mounting]** useEffect() - 컴포넌트 렌더링 이후 실행\r\n\r\n- dep 설정에 따라 실행됨\r\n\r\n**[Updating]** useEffect() - 컴포넌트 내에서 변화가 발생했을 경우 실행\r\n\r\n- 부모 컴포넌트의 리렌더링, 부모로부터의 props값 변화, 해당 컴포넌트 내에서 state 변경 등\r\n\r\n**[Unmounting]** useEffect() - 컴포넌트 내에서 DOM을 제거할 때 실행되는 메서드\r\n\r\n- 컴포넌트의 DOM이 제거될 때 수행되며 useEffect 내부의 return 값이 사용됨\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbryvuq%2Fbtr5pFcEsKC%2FIUUp45qfkl3kWGMGsXLoF0%2Fimg.png)\r\n\r\n**위와 같이 컴포넌트를 여닫는 페이지가 있다고 가정했을 때, console을 통해 대략적인 흐름을 확인해 볼 수 있다.**\r\n\r\n### **Class형 컴포넌트**\r\n\r\n**컴포넌트가 처음 실행될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOvMHN%2Fbtr5nGi34Pf%2Fr7cGOBhis0thuYoKgE5Y81%2Fimg.png)\r\n\r\n**state가 변경될 때 (props가 변경될 때와 동일)**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FD45Ra%2Fbtr5gtxPbHC%2FBcyreT9Rmknfdukr6PuUMK%2Fimg.png)\r\n\r\n**컴포넌트가 제거될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6mDAw%2Fbtr5qsKSrcJ%2FSzo6Rjkm0liLDy3wCZZ27k%2Fimg.png)\r\n\r\n### **함수형 컴포넌트**\r\n\r\n**컴포넌트가 처음 실행될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3fXKy%2Fbtr5paDZhii%2FxGLf5vByXzPMT1jphHzBkK%2Fimg.png)\r\n\r\n**컴포넌트가 업데이트될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7vKwD%2Fbtr5paYhomj%2F5iPCpcpuRTIKbpr0dFNNO1%2Fimg.png)\r\n\r\n\u003e 콘솔에 출력된 것과 같이, useEffect의 return 이후 부분은 componentWillUnmount와 비슷하지만, 컴포넌트가 다시 렌더링 되기 전마다 다시 실행된다.\r\n\r\n**컴포넌트가 제거될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5feUj%2Fbtr5sdzGrHx%2F1FTXMaZBnR6FmKQmslJRK1%2Fimg.png)\r\n\r\n컴포넌트가 제거될 때는 componentWillUnmount처럼 useEffect의 return 부분이 실행되는 것을 볼 수 있다.\r\n\r\n사용된 코드\r\n\r\n```javascript\r\n// Lifecycle.jsx\r\n\r\nimport { useState } from \"react\";\r\nimport { FunctionComponent } from \"./FunctionComponent\";\r\nimport { ClassComponent } from \"./ClassComponent\";\r\n\r\nexport const Lifecycle = () =\u003e {\r\n  const [fnOpen, setFnOpen] = useState(false);\r\n  const [classOpen, setClassOpen] = useState(false);\r\n  const effectComponentHandler = num =\u003e {\r\n    if (num) {\r\n      setFnOpen(!fnOpen);\r\n    } else {\r\n      setClassOpen(!classOpen);\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eFn component / Class component\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e effectComponentHandler(1)}\u003e함수 open/close\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e effectComponentHandler(\"\")}\u003e\r\n        클래스 open/close\r\n      \u003c/button\u003e\r\n      {fnOpen ? \u003cFunctionComponent some1={1} some2={2} some3={3} /\u003e : null}\r\n      {classOpen ? \u003cClassComponent some1={1} some2={2} some3={3} /\u003e : null}\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n```javascript\r\n// FunctionComponent.jsx\r\n\r\nimport { useState, useEffect } from \"react\";\r\n\r\nexport const FunctionComponent = props =\u003e {\r\n  console.log(\"컴포넌트 렌더링\", props);\r\n  const [count, setCount] = useState(0);\r\n  useEffect(() =\u003e {\r\n    // effect\r\n    if (count === 0) {\r\n      console.log(`useEffect 첫 등장`);\r\n    } else {\r\n      console.log(`useEffect 다시 등장 count: ${count}`);\r\n    }\r\n    return () =\u003e {\r\n      // cleanup\r\n      console.log(\r\n        \"useEffect 퇴장 --- componentWillUnmount와 비슷하지만 리렌더링마다 사용됨\",\r\n      );\r\n    };\r\n  }, [count]);\r\n\r\n  const plus = () =\u003e {\r\n    setCount(prev =\u003e prev + 1);\r\n  };\r\n  const minus = () =\u003e {\r\n    setCount(prev =\u003e prev - 1);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e함수형 컴포넌트\u003c/p\u003e\r\n      \u003cspan\u003e{count}\u003c/span\u003e\r\n      \u003cbutton onClick={plus}\u003e+\u003c/button\u003e\r\n      \u003cbutton onClick={minus}\u003e-\u003c/button\u003e\r\n      \u003cp\u003eProps 받기\u003c/p\u003e\r\n      \u003cdiv\u003eprops1 = {props.some1}\u003c/div\u003e\r\n      \u003cdiv\u003eprops2 = {props.some2}\u003c/div\u003e\r\n      \u003cdiv\u003eprops3 = {props.some3}\u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n```javascript\r\n// ClassComponent.jsx\r\n\r\nimport { Component } from \"react\";\r\n\r\nexport class ClassComponent extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    // Class형 컴포넌트의 state는 무조건 객체 형태여야 한다.\r\n    this.state = {\r\n      counter: 0,\r\n    };\r\n    console.log(\r\n      \"Mount - 컴포넌트가 처음 실행될 때 state, context, defalutProps 저장\",\r\n      props,\r\n    );\r\n  }\r\n  plus = () =\u003e {\r\n    this.setState(state =\u003e ({ counter: state.counter + 1 }));\r\n  };\r\n  minus = () =\u003e {\r\n    this.setState(state =\u003e ({ counter: state.counter - 1 }));\r\n  };\r\n\r\n  componentWillMount() {\r\n    console.log(\"componentWillMount\");\r\n  }\r\n  componentDidMount() {\r\n    console.log(\"componentDidMount - DOM 접근 가능\");\r\n  }\r\n  componentDidUpdate() {\r\n    console.log(\"componentDidUpdate\");\r\n  }\r\n  shouldComponentUpdate() {\r\n    console.log(\"shouldComponentUpdate - state or props 업데이트\");\r\n    return true;\r\n  }\r\n  componentWillUnmount() {\r\n    console.log(\"componentWillUnmount\");\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      \u003cdiv\u003e\r\n        \u003cp\u003eClass형 컴포넌트\u003c/p\u003e\r\n        \u003cspan\u003e{this.state.counter}\u003c/span\u003e\r\n        \u003cbutton onClick={this.plus}\u003e+\u003c/button\u003e\r\n        \u003cbutton onClick={this.minus}\u003e-\u003c/button\u003e\r\n        \u003cp\u003eProps 받기\u003c/p\u003e\r\n        \u003cdiv\u003eprops1 = {this.props.some1}\u003c/div\u003e\r\n        \u003cdiv\u003eprops2 = {this.props.some2}\u003c/div\u003e\r\n        \u003cdiv\u003eprops3 = {this.props.some3}\u003c/div\u003e\r\n      \u003c/div\u003e\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n참조\r\n\r\nhttps://ko.reactjs.org/docs/state-and-lifecycle.html\r\n\r\nhttps://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html\r\n"},{"title":"react memo","description":"React.memo() 를 통한 컴포넌트 최적화","category":"react","date":"2023-03-16","content":"\r\n\u003e 유저에게 UI를 빠르게 제공하기 위해서는 컴포넌트의 렌더링을 최소화해 성능을 향상시킬 필요가 있다. 이를 위해 React.memo()에 대한 간단한 사용법을 기록해본다.\r\n\r\n# 1. React.memo()\r\n\r\n컴포넌트가 React.memo()로 래핑될 때, React는 컴포넌트를 렌더링하고 결과를 Memoizing한다.\r\n\r\n그리고 다음 렌더링이 일어날 때 props가 값다면, React는 Memoizing된 내용을 재사용한다.\r\n\r\n## 사용법\r\n\r\n```javascript\r\nimport React from \"react\";\r\n\r\nexport const MemoTest = ({ someProps }) =\u003e {\r\n  console.log(\"Memo test, props 바뀔때만 콘솔 작동\");\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cp\u003eMemoTest 컴포넌트\u003c/p\u003e\r\n      \u003cp\u003eprops가 바뀔때만 렌더링\u003c/p\u003e\r\n      \u003cspan\u003ecount와 연동된 props: {someProps}\u003c/span\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 다른 컴포넌트에서 불러올 때, 해당 컴포넌트를 import 해주면 된다.\r\nexport const MemoTestComponent = React.memo(MemoTest);\r\n```\r\n\r\n## 사용 예시\r\n\r\n```javascript\r\nexport const TestApp = () =\u003e {\r\n  const values = useContextValue();\r\n  const update = useContextUpdate();\r\n  const [count, setCount] = useState(0);\r\n  console.log(\"최상위 컴포넌트 : 렌더링 될때마다 콘솔 작동\");\r\n\r\n  const contextHandler = () =\u003e {\r\n    values === \"someData\" ? update(\"dataSome\") : update(\"someData\");\r\n  };\r\n\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cNormalComponent /\u003e\r\n      \u003cMemoTestComponent someProps={count} /\u003e\r\n      \u003cbutton\r\n        onClick={() =\u003e {\r\n          setCount(pre =\u003e pre + 1);\r\n        }}\r\n      \u003e\r\n        +count버튼\r\n      \u003c/button\u003e\r\n      \u003cbutton\r\n        onClick={() =\u003e {\r\n          setCount(pre =\u003e pre - 1);\r\n        }}\r\n      \u003e\r\n        -count버튼\r\n      \u003c/button\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003econtext value\u003c/p\u003e\r\n        \u003cspan\u003evalue : {values}\u003c/span\u003e\r\n        \u003cbutton onClick={contextHandler}\u003econtext 변경 버튼\u003c/button\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVQkSV%2Fbtr37vCBXzm%2FVXiqfYdD4H2FTcw3tGVFzk%2Fimg.png)\r\n\r\n위 이미지는 TestApp 코드의 초기 화면이다.\r\n\r\n모든 컴포넌트가 첫 렌더링을 거쳐 각각 콘솔을 찍어내고 있다.\r\n\r\n### TestApp의 count state는 MemoTest 컴포넌트에 props로 전달해주고 있기 때문에 React.memo()의 효과는 사용되지 않고, 일반 컴포넌트와 마찬가지로 TestApp count state가 변경될 때마다 렌더링되는 것을 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/Hl6oT/btr4gSJ05tT/kipvw3VkehYfnxf2Pbq780/img.gif)\r\n\r\n### 하지만 contextAPI처럼 MemoTest의 props와 연관되지 않은 다른 방식을 통해 통해 리렌더링을 발생시키는 경우라면, memoTest 컴포넌트의 props가 변경되지 않기 때문에 MemoTest는 렌더링을 발생시키지 않는다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/cmaheq/btr36GRW8J1/uhzNP5d6ymqDxVDGFK4Ay1/img.gif)\r\n\r\n\u003e contextAPI의 기본 사용법 : https://lee-yo-han.github.io/react/react-context-api\r\n\r\n---\r\n\r\n## 1-1 - props 동등 비교 커스터마이징\r\n\r\nReact.memo()는 props 혹은 props의 객체를 비교할 때 얕은 비교를 하기 때문에, 비교 방식을 수정하고 싶다면 React.memo() 두 번째 매개변수로 비교함수를 만들어 수동으로 연산 후 넘겨주면 된다.\r\n\r\n```javascript\r\nimport React from \"react\";\r\n\r\nexport const MemoTest = ({ someProps }) =\u003e {\r\n  console.log(\"Memo test, props 바뀔때만 콘솔 작동\");\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cp\u003eMemoTest 컴포넌트\u003c/p\u003e\r\n      \u003cp\u003eprops가 바뀔때만 렌더링\u003c/p\u003e\r\n      \u003cspan\u003ecount와 연동된 props: {someProps}\u003c/span\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\nconst propsAreEqual = (prev, next) =\u003e {\r\n  return (\r\n    prev.someProps === next.someProps\r\n    // 다른 props들이 있는 경우 \u0026\u0026을 통해 연산 추가\r\n  );\r\n};\r\n\r\nexport const MemoTestComponent = React.memo(MemoTest, propsAreEqual);\r\n```\r\n\r\n# 2. React.memo()는 언제 사용해야 하는가?\r\n\r\n### - 함수형 컴포넌트가 같은 props로 자주 렌더링 될거라 예상될 경우\r\n\r\nprops가 변경되지 않는 경우에도 상위 컴포넌트의 지속적인 렌더링에 의해 하위 컴포넌트의 불필요한 렌더링이 예상되는 경우라면 React.memo()를 통해 오직 props의 변화에만 반응시켜주는 것이 효율적이다.\r\n\r\n### - 무겁고 비용이 큰 연산이 있는 경우\r\n\r\n한 번 렌더링 될 때 큰 연산이 발생한다고 했을때 불필요한 렌더링이 일어난 경우 연산에 사용되는 비용이 낭비될 수 있기 때문에 이러한 경우 또한 React.memo()를 통한 memoization이 적절하다고 볼 수 있다.\r\n\r\n# 3. React.memo()를 언제 사용하지 말아야 하는가?\r\n\r\n### - 위에 언급한 상황과 맞지 않는 경우 React.memo()를 사용할 필요가 없을 가능성이 높다.\r\n\r\n경험적으로 ㅅ어능적인 이점을 얻지 못한다면 memoization을 사용하지 않는 것이 좋다. 성능 관련 변경이 잘못 적용된다면 성능이 오히려 악화될 수 있다.\r\n\r\n### - 기술적으로는 가능하지만 클래스 기반의 컴포넌트를 React.memo()로 래핑하는 것은 적절하지 않다.\r\n\r\n클래스 기반의 컴포넌트에서 memoization이 필요하다면, pureComponent를 확장하여 사용하거나, shouldComponentUpdate() 메서드를 구현하는 것이 적절하다.\r\n\r\n### - props가 자주 바뀌는 경우\r\n\r\nprops가 자주 바뀌는 경우도 React.memo()로 래핑하더라도 이전 props와 다음 props를 비교 함수를 통해 비교할때 거의 false를 반환할 것이기 때문에 props가 자주 바뀌는 경우도 React.memo()의 사용이 적절하지 않다.\r\n\r\n## 결론\r\n\r\n\u003e React.memo는 memoization의 장점을 얻게 해주는 좋은 도구이지만, 렌더링 방지를 위해 memoization에만 의존하면 안된다.\r\n\r\n---\r\n\r\n## 참조\r\n\r\nhttps://dmitripavlutin.com/use-react-memo-wisely/\r\n\r\nhttps://ui.toast.com/weekly-pick/ko_20190731\r\n"},{"title":"react usecallback","description":"useCallback을 이용한 컴포넌트 최적화하기","category":"react","date":"2023-03-16","content":"\r\n# useCallback이란?\r\n\r\n\u003e 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용하는 함수 메모이제이션용 React hook이다.\r\n\r\n```javascript\r\nconst memoFn = useCallback(() =\u003e {}, [dep]);\r\n```\r\n\r\n첫번째 인자의 함수를 두번째 인자의 종속성 배열 내의 값이 변경될 때까지 저장하여 재사용할 수 있도록 해준다.\r\n\r\njavascript에서 함수(function () {} or () =\u003e {})는 객체 리터럴( {...} )이 항상 새 객체를 생성하는 것과 유사하게 항상 다른 함수를 생성한다. 그렇다면 함수를 props 로 내려준다고 하면 하위 컴포넌트는 props가 변경되었다고 인식하게 된다.\r\n\r\n그렇게되면 React.memo를 이용한 최적화가 원하는대로 작동하지 않을 수 있기 때문에 이러한 점을 useCallback이 메꿔줄 수 있게 된다.\r\n\r\n\u003e 종속성 배열이 없는 경우 매번 새 함수를 반환하기 때문에 항상 dependencises 배열을 포함해줘야 한다. (특정 상황에서 빈 배열 [] 은 있을 수 있지만, 배열 자체가 없으면 의미가 없어진다.)\r\n\r\n## 사용예\r\n\r\n```javascript\r\nconst add = useCallback(() =\u003e x + y, [x, y]);\r\n```\r\n\r\n# useCallback과 React.memo를 통한 최적화\r\n\r\n```javascript\r\n// 최상단 (1번) 컴포넌트\r\nimport { useState } from \"react\";\r\nimport { UseCallbackChildren } from \"./UseCallbackChildren\";\r\n\r\nexport const UseCallbackTest = () =\u003e {\r\n  const [isDark, setIsDark] = useState(false);\r\n  return (\r\n    \u003c\u003e\r\n      \u003clabel\u003e\r\n        \u003cinput\r\n          type=\"checkbox\"\r\n          checked={isDark}\r\n          onChange={e =\u003e setIsDark(e.target.checked)}\r\n        /\u003e\r\n        Dark mode\r\n      \u003c/label\u003e\r\n      \u003chr /\u003e\r\n      \u003cUseCallbackChildren\r\n        productId={123}\r\n        referrer=\"wizard_of_oz\"\r\n        theme={isDark ? \"dark\" : \"light\"}\r\n      /\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n\r\n// 중간 (2번) 컴포넌트\r\nimport React, { useCallback } from \"react\";\r\nimport { CallbackForm } from \"./UseCallbackForn\";\r\n\r\nexport const UseCallbackChildren = ({ referrer, productId, theme }) =\u003e {\r\n  const post = (url, data) =\u003e {\r\n    console.log(\"POST /\" + url);\r\n    console.log(data);\r\n  };\r\n\r\n  const handleSubmit = useCallback(\r\n    orderDetails =\u003e {\r\n      post(\"/product/\" + productId + \"/buy\", {\r\n        referrer,\r\n        orderDetails,\r\n      });\r\n    },\r\n    [productId, referrer],\r\n  );\r\n\r\n  return (\r\n    \u003cdiv\r\n      style={\r\n        theme === \"dark\" ? { backgroundColor: \"black\", color: \"white\" } : {}\r\n      }\r\n    \u003e\r\n      \u003cCallbackForm onSubmit={handleSubmit} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 하위 (3번) 컴포넌트\r\nimport React, { useState } from \"react\";\r\n\r\nexport const UseCallbackForm = ({ onSubmit }) =\u003e {\r\n  const [count, setCount] = useState(1);\r\n\r\n  console.log(\"강제로 느리게\");\r\n  let startTime = performance.now();\r\n  while (performance.now() - startTime \u003c 500) {\r\n    // Do nothing for 500 ms to emulate extremely slow code\r\n  }\r\n\r\n  const handleSubmit = e =\u003e {\r\n    e.preventDefault();\r\n    const formData = new FormData(e.target);\r\n    const orderDetails = {\r\n      ...Object.fromEntries(formData),\r\n      count,\r\n    };\r\n    onSubmit(orderDetails);\r\n  };\r\n\r\n  return (\r\n    \u003cform\r\n      onSubmit={handleSubmit}\r\n      style={{ display: \"flex\", flexDirection: \"column\", width: \"200px\" }}\r\n    \u003e\r\n      \u003cp\u003e\r\n        \u003cb\u003e\r\n          Note: \u003ccode\u003eShippingForm\u003c/code\u003e is artificially slowed down!\r\n        \u003c/b\u003e\r\n      \u003c/p\u003e\r\n      \u003clabel\u003e\r\n        Number of items:\r\n        \u003cbutton type=\"button\" onClick={() =\u003e setCount(count - 1)}\u003e\r\n          -\r\n        \u003c/button\u003e\r\n        {count}\r\n        \u003cbutton type=\"button\" onClick={() =\u003e setCount(count + 1)}\u003e\r\n          +\r\n        \u003c/button\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        Street:\r\n        \u003cinput name=\"street\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        City:\r\n        \u003cinput name=\"city\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        Postal code:\r\n        \u003cinput name=\"zipCode\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n};\r\n\r\nexport const CallbackForm = React.memo(UseCallbackForm);\r\n```\r\n\r\n위 코드를 보면, 최상단(1)에 있는 다크모드는 중간(2) 컴포넌트까지만 전달해주고, 중간(2) 컴포넌트는 하위(3) 컴포넌트에 useCallback 함수만 전달해주고 있다.\r\n\r\nuseCallback은 함수를 캐시해 재사용할 수 있도록 도와주기 때문에 종속성이 변하지 않으면 계속 재사용할 수 있다. 즉, 동일한 props로써 함수를 하위(3) 컴포넌트에 내려주고 있기 때문에 하위 컴포넌트의 렌더링에 영향이 없다.\r\n\r\n이 상태로 코드를 작동시키면 하위(3) 컴포넌트에 있는 count를 동작할때마다 느려지겠지만, 다크모드와 submit 이벤트에는 영향을 주지 않는다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/bEYsKw/btr4gSLc8BG/hJKpnBKbFziku3fjI6hphK/img.gif)\r\n\r\n만약 하위(3) 컴포넌트의 React.memo()를 없애게 되면 submit 이벤트에는 영향이 없지만, 최상위(1) 컴포넌트의 다크모드 state 변경에 의해 하위(3) 컴포넌트의 렌더링이 일어나게 되어 다크모드와 count의 동작이 느려지는걸 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/mfxA0/btr4iTijPZD/XNzKmFrScoUZ6qSyiCMV2K/img.gif)\r\n\r\n자세히 보면 콘솔이 먼저 찍히고 0.5초정도 뒤에 동작하는 것을 볼 수 있다.\r\n\r\n# useMemo와의 차이점\r\n\r\n\u003e useMemo는 함수의 호출 결과를 캐시하고, useCallback은 함수 자체는 캐시한다. 그러므로 useCallback은 useMemo와 달리 제공한 함수를 호출하지 않는다. 대신 사용자가 제공한 함수를 캐시하기 때문에 불필요한 렌더링 없이 함수를 전달할 수 있다.\r\n\r\n## useMemo와 useCallback의 동시 사용\r\n\r\n```javascript\r\nfunction useCallback(fn, dependencies) {\r\n  return useMemo(() =\u003e fn, dependencies);\r\n}\r\n```\r\n\r\n## useCallback이 유용한 경우\r\n\r\n- useCallback을 통해 props로 하위 컴포넌트에 넘겨줄때\r\n- useEffect 등 다른 hook의 종속성으로 이용할때\r\n- 종속성 변화가 적고 재사용이 용이할때\r\n\r\n## useCallback 남용 시 문제점\r\n\r\n\u003e 모든 함수를 useCallback으로 감싸게 되면 컴포넌트가 리렌더 될 때마다 모든 함수가 다시 재생성될 필요가 있는지 검사하는 연산이 수행된다. 따라서 보통은 특정 함수가 props로 전달되어 불필요한 컴포넌트 리렌더를 유발할 때에만 적용하는 것이 좋다.\r\n\r\n### memo, useMemo, useCallback 등 어떤 Memoization이나 부적절하게 사용할 경우 오히려 성능이 떨어질 수 있기 때문에 상황에 맞게 적절하게 사용하는 것이 좋은 것 같다.\r\n\r\n---\r\n\r\n참조: https://beta.reactjs.org/reference/react/useCallback\r\n"},{"title":"react usememo","description":"useMemo를 이용한 컴포넌트 최적화하기","category":"react","date":"2023-03-16","content":"\r\n# useMemo란?\r\n\r\n\u003e useMemo는 React.memo(), useCallback과 같이 컴포넌트를 최적화하기 위한 훅 중 하나이다.\r\n\r\n# useMemo를 사용하는 이유\r\n\r\nReact의 컴포넌트는 부모 컴포넌트가 렌더링되거나, 자신의 state변경, 상위 컴포넌트에서 내려받는 props가 변경될 때마다 다시 렌더링된다. 그런데 내려받는 props나 state가 여러 가지일때 한 개 props의 변경으로 모든 값이 다시 계산되는 경우 불필요한 비용이 누적되게 된다.\r\n\r\nuseMemo는 이러한 현상을 효율적으로 전환하기 위한 hook이다.\r\n\r\n## useMemo를 적용하기 전\r\n\r\n```javascript\r\n// 상위 컴포넌트\r\nimport { useState } from \"react\";\r\nimport { UseMemoChildren } from \"./UseMemoChildren\";\r\n\r\nexport const UseMemoTest = () =\u003e {\r\n  const [number, setNumber] = useState(0);\r\n  const [text, setText] = useState(\"\");\r\n\r\n  const changeNumber = e =\u003e {\r\n    setNumber(e.target.value);\r\n  };\r\n  const changeText = e =\u003e {\r\n    setText(e.target.value);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eUseMemoText\u003c/p\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003enumber\u003c/p\u003e\r\n        \u003cinput type=\"number\" onChange={changeNumber} value={number} /\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003etext\u003c/p\u003e\r\n        \u003cinput type=\"text\" onChange={changeText} value={text} /\u003e\r\n      \u003c/div\u003e\r\n      \u003cUseMemoChildren number={number} text={text} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 하위 컴포넌트\r\nexport const UseMemoChildren = ({ number, text }) =\u003e {\r\n  const getNumber = number =\u003e {\r\n    console.log(\"숫자 변경\");\r\n    return number;\r\n  };\r\n\r\n  const getText = text =\u003e {\r\n    console.log(\"글자 변경\");\r\n    return text;\r\n  };\r\n\r\n  const showNumber = getNumber(number);\r\n\r\n  const showText = getText(text);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eMemo Child Component\u003c/p\u003e\r\n      \u003cp\u003enumber: {showNumber}\u003c/p\u003e\r\n      \u003cp\u003etext: {showText}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n상위 컴포넌트는 각 input 값이 변경될 때마다 그 값을 저장해 하위 컴포넌트로 내려준다.\r\n\r\n하위 컴포넌트는 내려받은 props를 통해 화면에 노출시켜줄 값을 return해주는 역할을 한다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/9hqzj/btr4hQeyTmU/PzYhcCiwuZq08zOkhBqeWk/img.gif)\r\n\r\n이 상태에서 input을 업데이트하면 숫자를 바꾸든 텍스트를 바꾸든 getNumber 함수와 getText 함수 둘 다 다시 연산되는 것을 볼 수 있다.\r\n\r\n이런 경우 변경된 props에 대해서만 다시 연산될 수 있도록 useMemo를 적용해볼 수 있다.\r\n\r\n## useMemo 사용법\r\n\r\n```javascript\r\nconst cachedValue = useMemo(calculateValue, dependencies);\r\n```\r\n\r\n### 적용 예시\r\n\r\n```javascript\r\n// 하위 컴포넌트\r\n\r\nimport { useMemo } from \"react\";\r\n\r\nexport const UseMemoChildren = ({ number, text }) =\u003e {\r\n  //   console.log(\"useMemoChildren start\");\r\n  const getNumber = number =\u003e {\r\n    console.log(\"숫자 변경\");\r\n    return number;\r\n  };\r\n\r\n  const getText = text =\u003e {\r\n    console.log(\"글자 변경\");\r\n    return text;\r\n  };\r\n\r\n  const showNumber = useMemo(() =\u003e {\r\n    return getNumber(number);\r\n  }, [number]);\r\n\r\n  const showText = useMemo(() =\u003e {\r\n    return getText(text);\r\n  }, [text]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eMemo Child Component\u003c/p\u003e\r\n      \u003cp\u003enumber: {showNumber}\u003c/p\u003e\r\n      \u003cp\u003etext: {showText}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 useMemo를 적용하고 나면 다음과 같이 useMemo 적용 이후 변경된 props에 대한 연산만 처리해주는 것을 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/4Vcyh/btr4hPz1xwm/0zNRNCdyJKwpsWk2LU73KK/img.gif)\r\n\r\n\u003e useMemo 마지막의 dependencies [ ] 배열은 필수적으로 어떤 값을 변경에 반응할 것인지 포함시켜줘야 한다.\r\n\r\n# 연산 비용이 비싸다는 기준은?\r\n\r\nReact 공식 사이트에서 권장하는 useMemo 적용 기준은 연산에 소요된 시간이 1ms 이상일 경우로 안내하고 있다.\r\n\r\nconsole.time/timeEnd 등을 통해 useMemo를 적용하고자 하는 함수의 총 연산시간을 도출해볼 수 있다.\r\n\r\n```javascript\r\nconst getText = text =\u003e {\r\n  console.time(\"memo\");\r\n  console.log(\"글자 변경\");\r\n  console.timeEnd(\"memo\");\r\n  return text;\r\n};\r\n```\r\n\r\n위와 같이 코드 작성 후 text를 변경해보면 다음과 같은 콘솔을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8mGtS%2Fbtr4iU19jHE%2FH0huW2SytbAtalR3urepr0%2Fimg.png)\r\n\r\n\u003e 입력하는 계산이 눈에 띄게 느리고, 종속성이 거의 변경되지 않는 경우에는 useMemo를 이용한 최적화가 적합하지만, 컴포넌트 구조 변경과 상태 관리의 최소화, state를 업데이트하는 Effect의 불필요한 종속성을 제거하거나 특정 함수들을 별도로 관리하는 방법이 useMemo보다 적합할 수 있다.\r\n\r\n\u003e 실제로 React의 성능 문제 대부분은 Effect에서 발생하는 업데이트 체인으로 인해 발생한다고 한다.\r\n\r\n---\r\n\r\n참조 : https://beta.reactjs.org/reference/react/useMemo\r\n"},{"title":"react context api","description":"ContextAPI 사용하기","category":"react","date":"2023-03-15","content":"\r\n# ContextAPI\r\n\r\n\u003e 간단한 데이터의 변화를 props drilling 없이 전역적으로 관리해주기 위해 ContextAPI를 사용해볼 수 있다.\r\n\r\n## 사용법\r\n\r\n## 1. context component 생성\r\n\r\n```javascript\r\n// context.jsx\r\nimport { createContext, useContext, useState } from \"react\";\r\n\r\n// context 생성\r\nconst AnyContextValue = createContext();\r\nconst AnyContextUpdate = createContext();\r\n\r\n// useContext 생성\r\nexport const useContextValue = () =\u003e {\r\n  const context = useContext(AnyContextValue);\r\n  return context;\r\n};\r\nexport const useContextUpdate = () =\u003e {\r\n  const update = useContext(AnyContextUpdate);\r\n  return update;\r\n};\r\n\r\n// context Component 생성\r\n// children props를 Contextname.provider로 감싸준다.\r\nexport const SomeContext = ({ children }) =\u003e {\r\n  const [someData, setSomeData] = useState(\"someData\");\r\n  return (\r\n    \u003cAnyContextValue.Provider value={someData}\u003e\r\n      \u003cAnyContextUpdate.Provider value={setSomeData}\u003e\r\n        {children}\r\n      \u003c/AnyContextUpdate.Provider\u003e\r\n    \u003c/AnyContextValue.Provider\u003e\r\n  );\r\n};\r\n```\r\n\r\n## 2. context import\r\n\r\n```javascript\r\nimport { TestApp } from \"./components/blogtest/TestApp\";\r\nimport { SomeContext } from \"./components/context/RenderingContext\";\r\n\r\n// import된 Context를 적용하고자 하는 컴포넌트들의 최상위에 감싸준다.\r\nfunction App() {\r\n  return (\r\n    \u003cSomeContext\u003e\r\n      \u003cChildrenComponent /\u003e\r\n    \u003c/SomeContext\u003e\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n## 3. context 사용\r\n\r\n```javascript\r\nimport { useState } from \"react\";\r\n// 생성한 useContext import\r\nimport { useContextUpdate, useContextValue } from \"../context/RenderingContext\";\r\n\r\nexport const ChildrenComponent = () =\u003e {\r\n  const values = useContextValue();\r\n  const update = useContextUpdate();\r\n\r\n  const contextHandler = () =\u003e {\r\n    values === \"someData\" ? update(\"dataSome\") : update(\"someData\");\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003econtext value\u003c/p\u003e\r\n      \u003cspan\u003evalue : {values}\u003c/span\u003e\r\n      \u003cbutton onClick={contextHandler}\u003econtext 변경 버튼\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 설정이 완료된 후 정상적으로 contextAPI를 사용할 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/d0hnZa/btr35w9FvGX/zDcTOjtXxg23vMKk6LxaM0/img.gif)\r\n\r\n\u003e contextAPI는 간단하게 상태를 관리해줄 수 있지만, provider를 전역으로 감쌌을 때 컴포넌트들이 전반적으로 렌더링이 일어날 수 있기 때문에 상황과 구조에 맞게 적절하게 사용해주는 것이 좋다.\r\n\r\n---\r\n\r\n## 참고 : typescript에서의 contextAPI 사용\r\n\r\n### TypeScript에서는 context 초기값 등의 설정이 필요하다.\r\n\r\n```typescript\r\n// context component\r\n\r\nimport { createContext, useContext, useState } from \"react\";\r\nimport { PostType } from \"@/types/pages\";\r\nimport { ProviderProps, ContextType } from \".\";\r\n\r\n// context 초기화\r\nconst initialContext = {\r\n  posts: [],\r\n  setPosts: () =\u003e {},\r\n};\r\n\r\n// context 생성\r\nconst PostContextValue = createContext\u003cPostType[]\u003e(initialContext.posts);\r\nconst PostContextUpdate = createContext\u003cContextType\u003e(initialContext.setPosts);\r\n\r\n// useContext 생성\r\nexport const useMdContextValue = () =\u003e {\r\n  const context = useContext(PostContextValue);\r\n  return context;\r\n};\r\nexport const useMdContextUpdate = () =\u003e {\r\n  const update = useContext(PostContextUpdate);\r\n  return update;\r\n};\r\n\r\n// context component 생성\r\nexport const MdContext = ({ children }: ProviderProps) =\u003e {\r\n  const [posts, setPosts] = useState\u003cPostType[]\u003e([]);\r\n\r\n  return (\r\n    \u003cPostContextValue.Provider value={posts}\u003e\r\n      \u003cPostContextUpdate.Provider value={setPosts}\u003e\r\n        {children}\r\n      \u003c/PostContextUpdate.Provider\u003e\r\n    \u003c/PostContextValue.Provider\u003e\r\n  );\r\n};\r\n\r\n// 다른 컴포넌트에서의 사용\r\nimport { useEffect } from \"react\";\r\nimport { useMdContextUpdate } from \"@/context/mdContext\";\r\n\r\nexport default function Home({ posts }: { posts: PostType[] }) {\r\n  const update = useMdContextUpdate();\r\n\r\n  useEffect(() =\u003e {\r\n    if (posts) {\r\n      update(posts);\r\n    }\r\n  }, [posts, update]);\r\n```\r\n"},{"title":"react datepicker","description":"React datepicker 사용하기","category":"react","date":"2023-03-03","content":"\r\n# React Datepicker 사용하기\r\n\r\n공식 문서\r\n\r\nhttps://reactdatepicker.com/\r\n\r\n### package 설치\r\n\r\n```bash\r\nyarn add react-datepicker\r\n```\r\n\r\n패키지 설치 후 아래와 같이 import해 사용할 수 있다.\r\n\r\n```javascript\r\nimport DatePicker from \"react-datepicker\"; // 데이트픽커 import\r\nimport \"react-datepicker/dist/react-datepicker.css\"; // 데이트픽커 기본 CSS\r\nimport { ko } from \"date-fns/esm/locale\"; // 한국어 변환\r\n\r\nexport default function DatePickerTest() {\r\n  const [startDate, setStartDate] = useState(new Date());\r\n  const [endDate, setEndDate] = useState(null);\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003cDatePicker local={ko} /\u003e\r\n    \u003c/\u003e\r\n  );\r\n}\r\n```\r\n\r\n달력은 props 설정을 통해 다양한 방식의 달력을 설정해줄 수 있다.\r\n\r\n아래는 범위 지정 달력을 만드는 코드이다.\r\n\r\n```javascript\r\nexport default function DatePickerTest() {\r\n  const [startDate, setStartDate] = useState(new Date());\r\n  const [endDate, setEndDate] = useState(null);\r\n\r\n  const onChange = dates =\u003e {\r\n    const [start, end] = dates;\r\n    setStartDate(start);\r\n    setEndDate(end);\r\n  };\r\n\r\n  return (\r\n    \u003cDatePicker\r\n      elected={startDate}\r\n      onChange={onChange}\r\n      startDate={startDate}\r\n      endDate={endDate}\r\n      locale={ko}\r\n      selectsRange\r\n      inline\r\n    /\u003e\r\n  );\r\n}\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F5DkxI%2FbtrMUTz6YZb%2FpYNfcGfYjpM5GZlENLALTk%2Fimg.png)\r\n\r\n위 코드는 selectsRange라는 속성의 달력을 이용한다.\r\n다양한 속성은 상단의 공식 페이지 링크를 참고하면 좋다.\r\n\r\n## 스타일 적용\r\n\r\ncustom header 같은 props 옵션 등을 통해 css 스타일을 줄 수 있지만, 스타일이 원하는대로 입히기 어려운 점도 있었고 전체적인 코드가 보기 불편하다는 생각이 들어 styled component를 통해 css를 적용해줬다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzDzqF%2FbtrMWeKqb6T%2FkKiJfjfF1fP7vPcnWpyHOK%2Fimg.png)\r\n\r\n```javascript\r\n\r\nconst StyledDatePickerWrapper = styled.section`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 300px;\r\n  height: 380px;\r\n  border-radius: 20px;\r\n  box-shadow: 0 0 5px 0 rgb(71, 181, 255);\r\n\r\n  .react-datepicker {\r\n    background-color: white;\r\n    border-color: rgb(198, 232, 255);\r\n    border-radius: 20px;\r\n  }\r\n\r\n  /* ... */\r\n\r\n```\r\n\r\n코드가 길어지더라도 jsx와 철저하게 분리하고 싶다면 이런 방법도 나쁘지 않은 것 같다.\r\n"},{"title":"react media query","description":"React mediaQuery 사용법","category":"react","date":"2023-03-03","content":"\r\n# react-responsive 사용해보기\r\n\r\n공식 사이트 : https://yarnpkg.com/package/react-responsive\r\n\r\nCSS의 mediaQuery를 사용해볼 수도 있지만, 간편하게 적용할 수 있는 패키지가 있어서 사용해봤다.\r\n\r\n### 패키지 설치\r\n\r\n```bash\r\nyarn add react-responsive\r\n```\r\n\r\n### useMediaQuery 세팅\r\n\r\n```javascript\r\n// useMideaQuery.js\r\n\r\nimport { useMediaQuery } from \"react-responsive\";\r\n\r\nexport const Desktop = ({ children }) =\u003e {\r\n  const isDesktop = useMediaQuery({\r\n    minWidth: 481,\r\n  });\r\n  return isDesktop ? children : null;\r\n};\r\n\r\nexport const Mobile = ({ children }) =\u003e {\r\n  const isMobile = useMediaQuery({ maxWidth: 480 });\r\n  return isMobile ? children : null;\r\n};\r\n```\r\n\r\n위의 경우 모바일과 PC만 나눴지만 대략적인 분기점은 아래와 같이 설정해도 괜찮다\r\n\r\n1. 낮은 해상도의 PC, 태블릿 가로 : ~1024px\r\n2. 태블릿 가로 : 768px ~ 1023px\r\n3. 모바일 가로, 태블릿 : 480px ~ 767px\r\n4. 모바일 : ~480\r\n\r\n### useMediaQuery 사용\r\n\r\n```javascript\r\n// Responsive.jsx\r\n\r\nimport { Desktop, Mobile } from \"../../hooks/useMideaQuery\";\r\n\r\nexport const Responsive = () =\u003e {\r\n  return (\r\n    \u003c\u003e\r\n      \u003cDesktop\u003e\r\n        \u003cdiv\u003ePC화면\u003c/div\u003e\r\n      \u003c/Desktop\u003e\r\n      \u003cMobile\u003e\r\n        \u003cdiv\u003e모바일화면\u003c/div\u003e\r\n      \u003c/Mobile\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n```\r\n\r\n편의상 한 컴포넌트에 다 집어넣을 수도 있지만, 모바일과 데스크탑 환경의 view는 아예 다른 경우가 많기 때문에, 코드 관리를 편하게 하기 위해서는 모바일 컴포넌트를 따로 만드는게 더 나을 것 같다는 생각이 든다.\r\n"},{"title":"react modal non library","description":"라이브러리 없이 React Modal 만들기","category":"react","date":"2023-03-03","content":"\r\n# 라이브러리 없이 모달창 만들어보기\r\n\r\n모달 버튼이 있는 페이지\r\n\r\n```javascript\r\n// ModalTest.jsx\r\n\r\nimport ModalPage from \"./ModalPage\";\r\nimport { useState } from \"react\";\r\n\r\nexport default function ModalTest() {\r\n  // 모달을 보여줄지 말지 상태를 관리하는 state를 만들어준다.\r\n  const [showModal, setShowModal] = useState(false);\r\n\r\n  // 모달 버튼을 클릭하면 열리고\r\n  const openModal = () =\u003e {\r\n    setShowModal(true);\r\n  };\r\n  // 활성화된 모달창 밖을 클릭하면 닫힌다.\r\n  const closeModal = () =\u003e {\r\n    setShowModal(false);\r\n  };\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003cbutton onClick={openModal}\u003e모달이에옹\u003c/button\u003e\r\n      // 모달상태가 true면 ModalPage를 보여주고, 아니면 null // props로 showModal과\r\n      closeModal을 전달한다.\r\n      {showModal === true ? (\r\n        \u003cModalPage showModal={showModal} closeModal={closeModal} /\u003e\r\n      ) : null}\r\n    \u003c/\u003e\r\n  );\r\n}\r\n```\r\n\r\n모달 컴포넌트\r\n\r\n```javascript\r\nimport styled from \"styled-components\";\r\n\r\nexport default function ModalPage({ showModal, closeModal }) {\r\n  return (\r\n    // 모달 밖을 클릭하면 모달창을 닫게 만든다.\r\n    \u003cStyledModalBackground onClick={closeModal}\u003e\r\n      // stopPropagation은 부모태그로부터의 이벤트 전파를 중지시킨다. // 이\r\n      친구가 없으면 모달창 안쪽을 클릭해도 closeModal이 실행된다.\r\n      \u003cStyledModalContainer onClick={e =\u003e e.stopPropagation()}\u003e\r\n        \u003cStyledModal\u003e열린 모달창이에옹\u003c/StyledModal\u003e\r\n      \u003c/StyledModalContainer\u003e\r\n    \u003c/StyledModalBackground\u003e\r\n  );\r\n}\r\n\r\n// 위치를 대략 가운대로 정해주고\r\nconst StyledModalContainer = styled.div`\r\n  position: fixed;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n`;\r\n\r\n// 모달 밖 배경색은 우리에게 익숙한 어두운 색으로 만들어주자\r\nconst StyledModalBackground = styled.div`\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  bottom: 0;\r\n  right: 0;\r\n  background-color: rgba(0, 0, 0, 0.4);\r\n  z-index: 0;\r\n  cursor: auto;\r\n`;\r\n\r\n// 모달창 사이즈는 용도에 맞춰 설정해준다.\r\nconst StyledModal = styled.div`\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: white;\r\n`;\r\n```\r\n\r\n브라우저 화면\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOLJGf%2FbtrNjUdVndT%2FvgVskBO2xWeRwi01YQPzkk%2Fimg.png)\r\n\r\n스타일은 용도에 맞게 다양하게 변경시킬 수 있다.\r\n"},{"title":"react navigate props","description":"React navigate로 props 넘기기","category":"react","date":"2023-03-03","content":"\r\n# useNavigate를 이용한 props 전달\r\n\r\n### useNavigate로 다른 페이지의 화면으로 이동할 때, props처럼 값을 넘기는 방법을 사용해볼 수 있다.\r\n\r\n```javascript\r\n\r\n// 보내는컴포넌트.jsx\r\n\r\nimport { useNavigate } from \"react-router-dom\";\r\n\r\nconst Component1 = () =\u003e {\r\nconst navigate = useNavigate()\r\n\r\nlet someDatas = {\r\n\tname:\"hihi\"\r\n    value:\"here\"\r\n}\r\n\r\nreturn\r\n\u003cdiv onClick={() =\u003e navigate(`/다른페이지주소`,{ state: someDatas });}\u003e\r\n\t다른페이지로 이동\r\n\u003c/div\u003e\r\n}\r\n\r\n\r\n\r\n// 받는 컴포넌트.jsx\r\n\r\nimport { useLocation } from \"react-router-dom\";\r\n\r\nconst Component2 = () =\u003e {\r\n\tconst location = useLocation();\r\n\tconsole.log(location);\r\n}\r\n\r\n```\r\n\r\n위와 같이 작성은 아래와 같이 데이터를 받아오는 것을 보여준다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FedpbW9%2FbtrRGwsRGuz%2FKp5GIecYeABXw1FPbGLdsK%2Fimg.png)\r\n\r\n하지만 데이터를 받는 페이지가 직접적으로 접속할 수 있는 페이지라면 그렇게 접속한 페이지는 아무 데이터가 없는 화면으로 노출될 수 있기 때문에, 전역 상태를 관리해줄지, 데이터를 넘겨줄지 상황에 알맞는 방식을 적용하는 것이 중요하다.\r\n"},{"title":"react simple formdata code","description":"react formdata 코드간소화","category":"react","date":"2023-03-03","content":"\r\n# FormData 저장 코드 간소화하기\r\n\r\n하나의 폼에서 여러 개의 input 값을 변경하기 위해 함수를 만들어 간단하게 코드를 간소화시킬 수 있다.\r\n\r\n```typescript\r\n// form.tsx\r\n\u003cContainer onSubmit={e =\u003e onSubmitHandler(e, dispatch)}\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"profile_url\"\r\n    placeholder=\"https://picsum.photos/id/1/50/50 - 필수 X\"\r\n    value={formData.profile_url}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"author\"\r\n    placeholder=\"작성자\"\r\n    value={formData.author}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n    required\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003ctextarea\r\n    name=\"content\"\r\n    placeholder=\"내용\"\r\n    value={formData.content}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n    required\r\n  \u003e\u003c/textarea\u003e\r\n  \u003cbr /\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"createdAt\"\r\n    placeholder={`${todayDate()}`}\r\n    disabled\r\n    required\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003cbutton type=\"submit\"\u003e{isEdit ? \"수정하기\" : \"등록\"}\u003c/button\u003e\r\n\u003c/Container\u003e;\r\n\r\n// useForm.tsx\r\nconst [formData, setFormData] = useState\u003cFormData\u003e({\r\n  profile_url: \"\",\r\n  author: \"\",\r\n  content: \"\",\r\n  createdAt: todayDate(),\r\n});\r\n\r\nconst onChangeHandler = (e: InputEvent) =\u003e {\r\n  let type = e.target.name;\r\n  let value = e.target.value;\r\n  if (type === \"profile_url\")\r\n    setFormData(prev =\u003e ({ ...prev, profile_url: value }));\r\n  if (type === \"author\") setFormData(prev =\u003e ({ ...prev, author: value }));\r\n  if (type === \"content\") setFormData(prev =\u003e ({ ...prev, content: value }));\r\n  setFormData(prev =\u003e ({ ...prev, [type]: value }));\r\n};\r\n```\r\n\r\n하지만 위와 같이 if문이 많아져 코드의 성능과 가독성을 떨어뜨릴 수 있기 때문에, 아래와 같이 변경해볼 수 있다.\r\n\r\n```typescript\r\n// useForm.tsx\r\n\r\nconst [formData, setFormData] = useState\u003cFormData\u003e({\r\n  profile_url: \"\",\r\n  author: \"\",\r\n  content: \"\",\r\n  createdAt: todayDate(),\r\n});\r\n\r\nconst onChangeHandler = (e: InputEvent) =\u003e {\r\n  const { name, value } = e.target.name;\r\n  setFormData(prev =\u003e ({ ...prev, [name]: value }));\r\n};\r\n```\r\n\r\nhtml input의 name 속성을 이용해 setState 코드를 간소화시킬 수 있는 방법이다.\r\n"},{"title":"react styled components hover","description":"react에 styled-components를 이용해 hover 적용하기","category":"react","date":"2023-03-03","content":"\r\n# 리액트 스타일 컴포넌트에 hover 적용하기\r\n\r\n```typescript\r\n// \u0026:hover를 넣는다.\r\n\r\nconst ButtonStyle = styled.button`\r\n  \u0026:hover {\r\n    background-color: skyblue;\r\n    color: blue;\r\n  }\r\n`;\r\n```\r\n\r\n비슷한 상황에서 a 태그를 사용할때 자동으로 설정되는 스타일도 수정해줄 수 있다.\r\n\r\n```typescript\r\nconst LinkTag = styled.a`\r\n  /* 밑줄 제거 */\r\n  text-decoration: none;\r\n\r\n  /* 마우스를 링크에 올려뒀을 때의 스타일 */\r\n  \u0026:hover {\r\n  }\r\n  /* 아직 방문하지 않은 링크의 스타일 */\r\n  \u0026:link {\r\n  }\r\n  /* 사용자가 방문한 적이 있는(클릭한 이후) 링크의 스타일 */\r\n  \u0026:visited {\r\n  }\r\n  /* 마우스로 링크를 클릭하고 뗄 때까지의 스타일 */\r\n  \u0026:active {\r\n  }\r\n`;\r\n```\r\n"},{"title":"react submit prevent default","description":"form 태그에서 submit 이벤트 방지하기","category":"react","date":"2023-03-03","content":"\r\n# react form에서 submit 이벤트 방지하기\r\n\r\n### submit 이벤트가 발생하면 페이지가 새로고침이 된다.\r\n\r\n단순히 페이지가 리프레시 되는 것도 좋은 사용자 경험이 아닌데, 임시로 저장돼있던 데이터(회원가입 정보 등)가 날아가면 React의 작동 방식을 거스를 뿐 아니라 사용자 경험에도 치명적이다.\r\n\r\n떄문에 우리는 sumbit 이벤트를 멈춰줄 필요가 있다.\r\n\r\n```javascript\r\nconst Header = () =\u003e {\r\n  const onSubmit = e =\u003e {\r\n    e.preventDefault(); // 해당 코드로 이벤트를 멈춰줄 수 있다.\r\n  };\r\n\r\n  return (\r\n    \u003cform\u003e\r\n      \u003cinput type=\"text\" /\u003e\r\n      // 버튼 타입도 submit으로 꼭 변경해준다.\r\n      \u003cbutton type=\"submit\" onSubmit={e =\u003e onSubmit(e)}\u003e\r\n        입력\r\n      \u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 작성하면 같은 폼 안에 있는 경우에 대해 submit 방지가 잘 되는 것을 확인할 수 있다.\r\n"},{"title":"react z index error","description":"z-index가 올바르게 적용되지 않을때 적용해볼 수 있는 방법","category":"react","date":"2023-03-03","content":"\r\n# z-index 미적용시 해결방법\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2c0QV%2FbtrXD8G7Ar9%2FpCFQ6eujsGgA0bKCKx1kpk%2Fimg.png)\r\n\r\n위와 같이 z-index를 999로 적용해도 원하는대로 작동하지 않는 경우를 볼 수 있다.\r\n\r\n### MDN 공식 문서 : https://developer.mozilla.org/ko/docs/Web/CSS/z-index\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8pPBj%2FbtrXCijsq0h%2FkdCdCRUKvZIGe7dk8KPJf0%2Fimg.png)\r\n\r\n해당 사진의 마지막 줄의 \"자손의 z-index를 자기 외의 바깥 요소와 비교하지 않습니다.\" 이 부분으로 인한 문제로 생각됐다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fct1Z18%2FbtrXH8zek29%2Fjwx0ckk9YgnPRLS2sM06k0%2Fimg.png)\r\n\r\n부모 요소는 부모 요소끼리, 자식 요소는 자식 요소끼리 경쟁하기 때문에, 기존 코드는 이와 같이 HeaderNav 안에 SideMenu가 있어 HeaderNav 내에서만 z-index를 비교하고 있던 것이었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbUIap4%2FbtrXCicOSRi%2FzWiWf6wrtlUx9aK2uYKK7K%2Fimg.png)\r\n\r\n이처럼 SideMenu를 HeaderNav 밖으로 빼주니, 아래와 같이 정상적으로 작동하는 모습을 볼 수 있었다.\r\n\r\n### 정상 적용된 화면\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FwMc3x%2FbtrXFupLVFz%2FWH6kLZ1IbRxHnXK2bqkHa0%2Fimg.png)\r\n\r\n## z-index가 제대로 작동하지 않을때 참고할만한 사항\r\n\r\n1. 부모 요소는 부모 요소끼리 경쟁되고 있는지 확인한다.\r\n2. Element가 static(position 속성의 default 값)이 아닌 position 속성이 설정되어있는지 확인한다.(relative, absolute, fixed, sticky)\r\n3. opacity나 transform과 같은 css 속성이 설정돼있는지 확인한다. 해당 css요소가 설정돼있다면 1번의 기준에 맞춰 코드를 다시 작성해준다.\r\n\r\n이정도면 버그를 수정하는데 충분하지만 더 싶도 깊은 내용은 아래를 참고해보면 좋을 것 같다.\r\n\r\n참조 : https://coder-coder.com/z-index-isnt-working/\r\n"}]},"__N_SSG":true},"page":"/react","query":{},"buildId":"OV20HWrLkXuRM8jaFvyc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>