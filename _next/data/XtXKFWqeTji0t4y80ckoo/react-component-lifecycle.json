{"pageProps":{"title":"react component lifecycle","description":"React 함수형 컴포넌트와 Class형 컴포넌트 생명주기","category":"react","keyword":"react, 함수형 컴포넌트, Class형 컴포넌트","date":"2023-03-23","content":"\r\n# **React state와 LifeCycle**\r\n\r\n> 함수형 컴포넌트와 class형 컴포넌트의 LifeCycle이 어떻게 되는지 간단하게 비교해 보는 글이다.\r\n\r\n## 클래스형 컴포넌트와 생명주기 메서드\r\n\r\n### 1. Mount(컴포넌트가 처음 실행될 때)\r\n\r\n- state, context, defalutProps 저장\r\n- componentWillMount - 안전하지 않은 접근\r\n- render\r\n- componentDidMount - DOM 접근 가능\r\n\r\n### 2. Props Update(프롭스가 업데이트될때)\r\n\r\n- componentWillReceiveProps - 사용 종료\r\n- shouldComponentUpdate\r\n- componentWillUpdate - 사용 종료\r\n- render\r\n- componentDidUpdate - DOM 접근 가능\r\n\r\n### 3. State Update (스테이트가 업데이트됐을 때)\r\n\r\n- shouldComponentUpdate\r\n- componentWillUpdate - 사용 종료\r\n- render\r\n- componentDidUpdate - DOM 접근 가능\r\n\r\n**사실상 componentWillReceiveProps와 componentWillUpdate의 사용 종료로 state와 props가 업데이트될 때 동일하게 작동한다.**\r\n\r\n### 4. Unmount (컴포넌트가 제거되는 것)\r\n\r\n- componentWillUnmount\r\n\r\n사용 종료의 기준은 아래와 같다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb0qQTJ%2Fbtr5h96VtyB%2FqLpFZAk7aybC21CEWPD9H1%2Fimg.png)\r\n\r\n## 함수형 컴포넌트와 useEffect 훅\r\n\r\n### 컴포넌트의 실행\r\n\r\n- 함수형 컴포넌트 호출\r\n\r\n- 함수형 컴포넌트의 내부에서 실행\r\n\r\n- return()으로 화면에 렌더링\r\n\r\n- 생명주기 메서드 대신 useEffect를 통한 비슷한 처리 가능\r\n\r\n### dependency에 따른 useEffect의 실행\r\n\r\n- deps 값이 없는 경우 : 화면이 렌더링 된 이후 수행이 되며, 리렌더링이 발생할 때마다 다시 실행\r\n\r\n- deps 값이 빈 배열인 경우 : 첫 렌더링 완료 후 1회만 실행\r\n\r\n- deps 값이 존재하는 경우 : 첫 렌더링 완료 후 1회 실행 && deps 값이 변경되었을 경우마다 실행\r\n\r\n```javascript\r\n// dep X\r\nuseEffect(() => {\r\n  // effect\r\n  return () => {\r\n    // cleanup\r\n  };\r\n});\r\n\r\n// dep []\r\nuseEffect(() => {\r\n  return () => {};\r\n}, []);\r\n\r\n// dep [some dep...]\r\nuseEffect(() => {\r\n  return () => {};\r\n}, [dep]);\r\n```\r\n\r\n**[Mounting]** useEffect() - 컴포넌트 렌더링 이후 실행\r\n\r\n- dep 설정에 따라 실행됨\r\n\r\n**[Updating]** useEffect() - 컴포넌트 내에서 변화가 발생했을 경우 실행\r\n\r\n- 부모 컴포넌트의 리렌더링, 부모로부터의 props값 변화, 해당 컴포넌트 내에서 state 변경 등\r\n\r\n**[Unmounting]** useEffect() - 컴포넌트 내에서 DOM을 제거할 때 실행되는 메서드\r\n\r\n- 컴포넌트의 DOM이 제거될 때 수행되며 useEffect 내부의 return 값이 사용됨\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbryvuq%2Fbtr5pFcEsKC%2FIUUp45qfkl3kWGMGsXLoF0%2Fimg.png)\r\n\r\n**위와 같이 컴포넌트를 여닫는 페이지가 있다고 가정했을 때, console을 통해 대략적인 흐름을 확인해 볼 수 있다.**\r\n\r\n### **Class형 컴포넌트**\r\n\r\n**컴포넌트가 처음 실행될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOvMHN%2Fbtr5nGi34Pf%2Fr7cGOBhis0thuYoKgE5Y81%2Fimg.png)\r\n\r\n**state가 변경될 때 (props가 변경될 때와 동일)**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FD45Ra%2Fbtr5gtxPbHC%2FBcyreT9Rmknfdukr6PuUMK%2Fimg.png)\r\n\r\n**컴포넌트가 제거될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6mDAw%2Fbtr5qsKSrcJ%2FSzo6Rjkm0liLDy3wCZZ27k%2Fimg.png)\r\n\r\n### **함수형 컴포넌트**\r\n\r\n**컴포넌트가 처음 실행될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3fXKy%2Fbtr5paDZhii%2FxGLf5vByXzPMT1jphHzBkK%2Fimg.png)\r\n\r\n**컴포넌트가 업데이트될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7vKwD%2Fbtr5paYhomj%2F5iPCpcpuRTIKbpr0dFNNO1%2Fimg.png)\r\n\r\n> 콘솔에 출력된 것과 같이, useEffect의 return 이후 부분은 componentWillUnmount와 비슷하지만, 컴포넌트가 다시 렌더링 되기 전마다 다시 실행된다.\r\n\r\n**컴포넌트가 제거될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5feUj%2Fbtr5sdzGrHx%2F1FTXMaZBnR6FmKQmslJRK1%2Fimg.png)\r\n\r\n컴포넌트가 제거될 때는 componentWillUnmount처럼 useEffect의 return 부분이 실행되는 것을 볼 수 있다.\r\n\r\n사용된 코드\r\n\r\n```javascript\r\n// Lifecycle.jsx\r\n\r\nimport { useState } from \"react\";\r\nimport { FunctionComponent } from \"./FunctionComponent\";\r\nimport { ClassComponent } from \"./ClassComponent\";\r\n\r\nexport const Lifecycle = () => {\r\n  const [fnOpen, setFnOpen] = useState(false);\r\n  const [classOpen, setClassOpen] = useState(false);\r\n  const effectComponentHandler = num => {\r\n    if (num) {\r\n      setFnOpen(!fnOpen);\r\n    } else {\r\n      setClassOpen(!classOpen);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>Fn component / Class component</p>\r\n      <button onClick={() => effectComponentHandler(1)}>함수 open/close</button>\r\n      <button onClick={() => effectComponentHandler(\"\")}>\r\n        클래스 open/close\r\n      </button>\r\n      {fnOpen ? <FunctionComponent some1={1} some2={2} some3={3} /> : null}\r\n      {classOpen ? <ClassComponent some1={1} some2={2} some3={3} /> : null}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n```javascript\r\n// FunctionComponent.jsx\r\n\r\nimport { useState, useEffect } from \"react\";\r\n\r\nexport const FunctionComponent = props => {\r\n  console.log(\"컴포넌트 렌더링\", props);\r\n  const [count, setCount] = useState(0);\r\n  useEffect(() => {\r\n    // effect\r\n    if (count === 0) {\r\n      console.log(`useEffect 첫 등장`);\r\n    } else {\r\n      console.log(`useEffect 다시 등장 count: ${count}`);\r\n    }\r\n    return () => {\r\n      // cleanup\r\n      console.log(\r\n        \"useEffect 퇴장 --- componentWillUnmount와 비슷하지만 리렌더링마다 사용됨\",\r\n      );\r\n    };\r\n  }, [count]);\r\n\r\n  const plus = () => {\r\n    setCount(prev => prev + 1);\r\n  };\r\n  const minus = () => {\r\n    setCount(prev => prev - 1);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>함수형 컴포넌트</p>\r\n      <span>{count}</span>\r\n      <button onClick={plus}>+</button>\r\n      <button onClick={minus}>-</button>\r\n      <p>Props 받기</p>\r\n      <div>props1 = {props.some1}</div>\r\n      <div>props2 = {props.some2}</div>\r\n      <div>props3 = {props.some3}</div>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n```javascript\r\n// ClassComponent.jsx\r\n\r\nimport { Component } from \"react\";\r\n\r\nexport class ClassComponent extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    // Class형 컴포넌트의 state는 무조건 객체 형태여야 한다.\r\n    this.state = {\r\n      counter: 0,\r\n    };\r\n    console.log(\r\n      \"Mount - 컴포넌트가 처음 실행될 때 state, context, defalutProps 저장\",\r\n      props,\r\n    );\r\n  }\r\n  plus = () => {\r\n    this.setState(state => ({ counter: state.counter + 1 }));\r\n  };\r\n  minus = () => {\r\n    this.setState(state => ({ counter: state.counter - 1 }));\r\n  };\r\n\r\n  componentWillMount() {\r\n    console.log(\"componentWillMount\");\r\n  }\r\n  componentDidMount() {\r\n    console.log(\"componentDidMount - DOM 접근 가능\");\r\n  }\r\n  componentDidUpdate() {\r\n    console.log(\"componentDidUpdate\");\r\n  }\r\n  shouldComponentUpdate() {\r\n    console.log(\"shouldComponentUpdate - state or props 업데이트\");\r\n    return true;\r\n  }\r\n  componentWillUnmount() {\r\n    console.log(\"componentWillUnmount\");\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <p>Class형 컴포넌트</p>\r\n        <span>{this.state.counter}</span>\r\n        <button onClick={this.plus}>+</button>\r\n        <button onClick={this.minus}>-</button>\r\n        <p>Props 받기</p>\r\n        <div>props1 = {this.props.some1}</div>\r\n        <div>props2 = {this.props.some2}</div>\r\n        <div>props3 = {this.props.some3}</div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n참조\r\n\r\nhttps://ko.reactjs.org/docs/state-and-lifecycle.html\r\n\r\nhttps://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html\r\n"},"__N_SSG":true}