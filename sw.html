<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Rain Sugar BangBang Front-End</title><meta name="description" content="developer&#x27;s blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta http-equiv="subject" content="정보처리기사"/><meta property="og:title" content="Rain Sugar BangBang"/><meta property="og:description" content="welcome to developer&#x27;s blog"/><meta property="og:image" content="/images/cards/sw.png"/><meta name="naver-site-verification" content="af9c8049662a7c6c85ea946e9eb561086e70062c"/><meta name="google-site-verification" content="Zgp7rA3RAdcRnhPPsGLK-t4KVTO86AejlDIQQIGpvLg"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4077287316160146" crossorigin="anonymous"></script><link rel="icon" href="/favicon.ico"/><link rel="preload" as="image" href="/images/cards/SW.png"/><meta name="next-head-count" content="13"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/f9bc783e634631d2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f9bc783e634631d2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7d0bddee48749f95.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-b0c8bcfd40968c52.js" defer=""></script><script src="/_next/static/chunks/pages/_app-60ff9b108ca99c3d.js" defer=""></script><script src="/_next/static/chunks/789-6e729330f76e9f3d.js" defer=""></script><script src="/_next/static/chunks/pages/sw-98436a4025967e60.js" defer=""></script><script src="/_next/static/XtXKFWqeTji0t4y80ckoo/_buildManifest.js" defer=""></script><script src="/_next/static/XtXKFWqeTji0t4y80ckoo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-c845a976-0 icUnkm"><header class="sc-fe6a8-0 fZHroo"><span style="display:none" class="sc-fe6a8-1 kOlYBJ"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 17 17" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g></g><path d="M16 3v2h-15v-2h15zM1 10h15v-2h-15v2zM1 15h15v-2h-15v2z"></path></svg></span><h1><a href="/">Rain Sugar BangBang</a></h1><span style="display:none" class="sc-fe6a8-1 kOlYBJ"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg></span></header><section class="sc-c845a976-1 bePtAz"><aside class="sc-226f6af7-0 jzKfYm"><div class="sc-226f6af7-1 eudLNA"><a target="_blank" href="https://portfolio-sigma-wheat-63.vercel.app/"><img alt="profile" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" src="/images/profileImage/cat.png"/><span>Go Profile!</span></a><p>Hanbbi</p></div><div class="sc-226f6af7-2 fEJwOM"><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0 0 68.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"></path></svg><span>yhl0078@gmail.com</span></a><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>Github</span></a></div></aside><article class="sc-c845a976-2 jRRSKe"><div class="sc-b797c1b7-0 jSiudw"><div class="sc-b797c1b7-1 ctQsiT"><span>전체 글<!-- --> (<!-- -->6<!-- -->)</span><form><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg><input type="text" style="opacity:0" placeholder="키워드 입력 후 엔터를 눌러주세요" class="sc-15314a72-0 bDAivC"/></form></div><ul class="sc-b797c1b7-2 dwTYwt"><a href="/sw-last-test"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 실기</p><span>2023. 12. 29</span></div></li></a><a href="/sw-first-test5"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(5) - 정보처리시스템 구축 관리</p><span>2023. 12. 28</span></div></li></a><a href="/sw-first-test4"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(4) - 프로그래밍 언어 활용</p><span>2023. 12. 27</span></div></li></a><a href="/sw-first-test3"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(3) - DB 구축</p><span>2023. 12. 26</span></div></li></a><a href="/sw-first-test2"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(2) - 소프트웨어 개발</p><span>2023. 12. 25</span></div></li></a><a href="/sw-first-test1"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(1) - 소프트웨어 설계</p><span>2023. 12. 24</span></div></li></a></ul><ul class="sc-4a3f34e2-0 dBfZty"><li class="noPrev"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z"></path></svg></li><li id="1" class="activePage">1</li><li class="noNext"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z"></path></svg></li></ul></div></article><aside class="sc-7eadfa91-0 cYGwoY"><nav class="sc-d66ac83e-0 kaIpxc"><ul class="sc-d66ac83e-1 leEYE"><p>Category</p><div><p class="sc-d66ac83e-2 hFnDjA">FE</p><li class="sc-d66ac83e-3 dIOnlb"><a href="/html">HTML</a></li><li class="sc-d66ac83e-3 dIOnlb"><a href="/css">CSS</a></li><li class="sc-d66ac83e-3 dIOnlb"><a href="/javascript">JavaScript</a></li><li class="sc-d66ac83e-3 dIOnlb"><a href="/typescript">TypeScript</a></li><li class="sc-d66ac83e-3 dIOnlb"><a href="/redux">Redux</a></li><li class="sc-d66ac83e-3 dIOnlb"><a href="/react">React</a></li><li class="sc-d66ac83e-3 dIOnlb"><a href="/nextjs">Nextjs</a></li></div><div><p class="sc-d66ac83e-2 hFnDjA">BE</p><li class="sc-d66ac83e-3 dIOnlb"><a href="/nestjs">Nestjs</a></li></div><div><p class="sc-d66ac83e-2 hFnDjA">CS</p><li class="sc-d66ac83e-3 dIOnlb"><a style="color:white;font-weight:bold" href="/sw">정보처리기사</a></li></div><div><p class="sc-d66ac83e-2 hFnDjA">ETC</p><li class="sc-d66ac83e-3 dIOnlb"><a href="/gtihub">Simple Memo</a></li></div></ul></nav></aside></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"sw last test","description":"정보처리기사 실기","category":"sw","date":"2023-12-29","content":"\r\n## 실기 시험 공략\r\n\r\n실기 시험도 필기와 마찬가지로 정보 보안이나 테스트 기법, GoF, 프로토콜 외에도 다양한 문제가 많이 분포돼있어서 기출 문제를 많이 풀어보면 도움은 된다.\r\n\r\n그러나 최근 복원 문제들을 봤을 때 프로그래밍 언어, DB(SQL 등) 문제가 많이 출제되는 경향이 있기 때문에 프로그래밍 언어와 어느정도 친해진 후에 시험을 보면 좋을 것 같다.\r\n\r\n나의 경우 javascript가 베이스여서 C, Java, Python은 잘 몰랐지만 언어 특성만 알면 구조는 비슷하다고 느껴졌다. (그래도 C의 포인터, Java의 메소드 오버라이딩/오버로딩 문제는 많이 봐두면 좋을 것 같다.)\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n[실기 기출 종합 키워드](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C)\r\n\r\n---\r\n\r\n# 실기 기출 종합 키워드 2020-2022\r\n\r\n# SW 기본\r\n\r\n## 인터페이스 전송 데이터\r\n\r\n- JSON(JavaScript Object Notation)\r\n  - Javascript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷\r\n  - JSON 데이터는 이름과 값의 쌍으로 이루어진다.\r\n- XML(eXtensible Markup Language)\r\n  - 웹에서 구조화한 문서를 표현하고 전송하도록 설계한 마크업 언어\r\n- CSV(Comma Separated Values)\r\n  - 몇 가지 필드를 쉼표(,)로 구분한 텍스트 데이터 및 텍스트 파일\r\n- YAML\r\n  - XML, C, 파이썬, 펄, RFC2822에서 정의된 e-mail 양식에서 개념을 얻어 만들어진 '사람이 쉽게 읽을 수 있는' 데이터 직렬화 양식\r\n\r\n## REST\r\n\r\n- 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것\r\n- HTTP URI를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.\r\n- RESTful : REST라는 아키텍처를 구현하는 웹 서비스\r\n\r\n## 시맨틱 웹\r\n\r\n- 의미론적인 웹, 즉 문서의 의미에 맞게 애플리케이션의 의미에 맞게 구성된 웹\r\n- 컴퓨터가 사람을 대신하여 정보를 읽고, 이해하고 가공하여 새로운 정보를 만들어 낼 수 있도록 이해하기 쉬운 의미를 가진 차세대 지능형 웹\r\n\r\n## SSO(통합 인증)\r\n\r\n\u003e SSO(Same Sign-on - 통합 인증)란 한 번의 인증 과정으로 여러 컴퓨터 상의 자원을 이용 가능하게 하는 인증 기능이다. 싱글 사인온, 단일 계정 로그인, 단일 인증이라고 한다.\r\n\r\n## 프로토콜의 기본 3요소\r\n\r\n- 구문 : 데이터의 구조나 형태와 포맷을 정의한다.\r\n- 타이밍 : 어떤 데이터를 보낼 것인지, 얼마나 빨리 보낼 것인지를 결정한다.\r\n- 의미 : 데이터의 각 부분이 무엇을 뜻하는지 알 수 있게 미리 정해둔 규칙이다.\r\n\r\n## 프로세스 스케줄링 ★★★\r\n\r\n- **비선점 스케줄링**\r\n  - FCFS(First Come First Service)\r\n    - 먼저 들어간 것을 먼저 실행한다.\r\n  - SJF(Shortest Job First)\r\n    - 진행 중인 프로세스를 멈추지는 않는다.\r\n    - CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식으로, 평균 대기시간을 최소로 만드는 것을 최적으로 두고 있는 알고리즘이다.\r\n  - HRN(Highest Response Ratio Next)\r\n    - 최고응답률 계산식 : (대기시간 + 서비스시간) / 서비스시간\r\n    - 최고응답률의 값이 큰 순으로 우선순위를 정하는 방식\r\n  - 기한부(Deadline)\r\n    - 작업들이 명시된 기간이나 기한 내에 완료되도록 계획\r\n  - 우선순위(Priority)\r\n    - 우선순위 스케줄링은 각 프로세스의 우선순위가 정해지면, 우선순위가 제일 높은 프로세스에게 CPU를 할당하되, 우선순위가 같은 경우에는 FCFS 방식을 적용한다.\r\n    - 일반적인 연산 위주 프로세스보다 입출력 위주 프로세스에게 높은 우선순위를 부여하여 대화성을 증진시킨다.\r\n- **선점 스케줄링**\r\n  - SRT(Shortest Remaining Time Scheduling)\r\n    - 최단 잔여시간을 우선으로 하는 스케줄링 기법으로, 진행 중인 프로세스가 있어도, 최단 잔여시간인 프로세스를 위해 sleep 시키고 짧은 프로세스를 먼저 할당한다.\r\n  - RR(Round Robin Scheduling)\r\n    - 시분할 시스템을 위해 설계되었다.\r\n    - FCFS(FIFO) 알고리즘을 선점 형태로 변형한 기법이다.\r\n    - 준비 큐를 원형 큐로 간주하고 순환식으로 각 프로세스에게 작은 단위의 시간량(타임 퀀텀)만큼씩 CPU를 할당하는 방식이다.\r\n    - FCFS 기법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만, 각 프로세스는 시간 할당량(Time Slice, Quantum) 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치된다.\r\n    - 이론상 n개의 프로세스가 1/n의 속도로 동시에 실행된다.\r\n    - 일반적으로 평균 반환시간이 SJF보다 크지만, 프로세스가 공정하게 기회를 얻게 되어 기아상태가 발생하지는 않는다.\r\n    - 타임 퀀텀의 크기가 작으면 잦은 문맥 교환 오버헤드 증가로 처리율이 감소할 수 있으며, 성능은 타임 퀀텀의 크기에 많은 영향을 받는다.\r\n    - 할당되는 시간의 크기가 작으면 작은 프로세스들에게 유리하다.\r\n  - MLQ(Multi-Level Queue - 다단계 큐)\r\n  - MLFQ(Multi-Level Feedback Queue - 다단계 피드백 큐)\r\n\r\n# SW 설계/개발\r\n\r\n## 형상관리 절차\r\n\r\n- 형상 식별 -\u003e 형상 통제 -\u003e 형상 감사 -\u003e 형상 기록\r\n\r\n※ 버전 관리 도구 분류\r\n\r\n- 공유 폴더 방식\r\n  - SCCS, RCS, PVCS\r\n- 클라이언트/서버 방식\r\n  - CVS, SVN, Clear Case\r\n- 분산 저장소 방식\r\n  - Git, Gnu arch, Bazaar, Bitkeeper\r\n\r\n## 형상 관리/형상 통제\r\n\r\n- 소프트웨어 형상 변경 요청을 검토하고 승인하여 현재의 베이스라인에 반영될 수 있도록 통제하는 것을 의미한다.\r\n- 형상관리 절차 : 형상 식별 -\u003e 형상 통제 -\u003e 형상 감사 -\u003e 형상 기록\r\n- 통제 : 소프트웨어 형상 변경 요청을 검토하고 승인하여 현재의 베이스라인에 반영될 수 있도록 통제\r\n\r\n## UI의 설계 원칙\r\n\r\n| 설계 원칙 |                              설명                              |\r\n| :-------: | :------------------------------------------------------------: |\r\n|  직관성   |          누구나 쉽게 이해하고 사용할 수 있어야 한다.           |\r\n|  유효성   |           사용자의 목적을 정확하게 달성하여야 한다.            |\r\n|  학습성   |            누구나 쉽게 배우고 익힐 수 있어야 한다.             |\r\n|  유연성   | 사용자의 요구사항을 최대한 수용하며, 오류를 최소화하여야 한다. |\r\n\r\n## 객체지향 설계원칙(SOLID)\r\n\r\n- 단일 책임 원칙(SRP, Single Responsibility Principle)\r\n  - 한 클래스는 하나의 책임만을 가져야 한다.\r\n- 개방 폐쇄 원칙(OCP, Open-Close Principle)\r\n  - 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.\r\n- 리스코프 치환 원칙(LSP, Liskov substitution principle)\r\n  - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.\r\n- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)\r\n  - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.\r\n- 의존성 역전 원칙(DIP, Dependency Inversion Principle)\r\n  - 의존 관계를 맺을 때 자주 변화하는 것보다, 변화가 거의 없는 것에 의존해야 한다.\r\n\r\n## 릴리즈 노트 작성 항목\r\n\r\n|                 |                                                                                        |\r\n| :-------------: | -------------------------------------------------------------------------------------- |\r\n| 머리말 (Header) | 릴리즈 노트명, 제품 이름, 작성일, 릴리즈 노트 버전 등의 정보 고지                      |\r\n|      개요       | 소프트웨어 및 변경사항에 관한 간략하고 전반적인 내용                                   |\r\n|      목적       | 해당 릴리즈 버전에서의 새로운 기능, 수정된 기능, 릴리즈 노트의 목적에 대한 간략한 개요 |\r\n| 이슈(문제) 요약 | 발견된 문제에 대한 요약                                                                |\r\n|    재현 항목    | 버그 발견에 대한 재현 단계 기술                                                        |\r\n| 수정/개선 내용  | 발견된 버그의 수정/개선 사항을 간단히 기술                                             |\r\n\r\n## UML 관계\r\n\r\n- 일반화 관계(Generalization)\r\n  - 한 클래스가 다른 클래스를 포함하는 상위 개념일 때의 관계\r\n- 연산 관계(Accociation)\r\n  - 2개 이상 사물이 서로 관련된 관계\r\n  - 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때의 표시\r\n- 의존 관계(Dependency)\r\n  - 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때 표시\r\n  - 클래스의 관계가 한 메서드를 실행하는 동안과 같이 매우 짧은 시간만 유지\r\n- 실체화 관계(Realization)\r\n  - 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정\r\n  - 인터페이스를 구현받아 추상 메서드를 오버라이딩하는 의미\r\n- 집합 관계-집약 관계(Aggregation)\r\n  - 한 객체가 다른 객체를 소유하는 'has a'관계\r\n  - 전체 객체의 라이프타임과 부분 객체의 라이프타임은 독립적\r\n- 집합 관계-합성관계(Composition)\r\n  - 부분 객체가 전체 객체에 속하는 관계로 긴밀한 필수적 관계\r\n\r\n## 유스케이스 다이어그램 관계\r\n\r\n- 연관관계(Association)\r\n  - 유스케이스와 액터 간의 상호작용이 있음을 표현\r\n- 포함관계(Include)\r\n  - 유스케이스를 수행할 때 반드시 실행되어야 하는 경우\r\n- 확장 관계(Extend)\r\n  - 유스케이스를 수행할 때 특정 조건에 따라 확장 기능 유스케이스를 수행하는 경우\r\n\r\n## 결합도 유형\r\n\r\n|                       구분                        |                                                  설명                                                  |\r\n| :-----------------------------------------------: | :----------------------------------------------------------------------------------------------------: |\r\n|  자료 결합도 (Data Coupling) (결합도 가장 낮음)   |                                모듈간의 인터페이스로 값이 전달되는 경우                                |\r\n|          스탬프 결합도 (Stamp Coupling)           |                 모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우                  |\r\n|          제어 결합도 (Control Coupling)           |     단순 처리할 대상인 값만 전달되는게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우      |\r\n|          외부 결합도 (External Coupling)          |                 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조하는 경우                 |\r\n|           공통 결합도 (Common Coupling)           | 파라미터가 아닌 모듈 밖에서 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호 작용하는 경우 |\r\n| 내용 결합도 (Content Coupling) (결합도 가장 높음) |                    다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우                     |\r\n\r\n## 응집도 유형\r\n\r\n|                      구분                       |                                            설명                                            |\r\n| :---------------------------------------------: | :----------------------------------------------------------------------------------------: |\r\n| 우연적 응집도 (Coincidental) (응집도 가장 낮음) |                       모듈 내부의 각 구성 요소들이 연관이 없을 경우                        |\r\n|             논리적 응집도 (Logicla)             |     유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우      |\r\n|            시간적 응집도 (Temporal)             |    연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우    |\r\n|           절차적 응집도 (Procedural)            | 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우 |\r\n|          통신적 응집도 (Communication)          |         동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있는 경우         |\r\n|           순차적 응집도 (Sequential)            |             모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우              |\r\n|  기능적 응집도 (Functional) (응집도 가장 높음)  |                  모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우                  |\r\n\r\n# 테스트\r\n\r\n## 소프트웨어 테스트의 원리\r\n\r\n- 테스팅은 결함이 존재함을 밝히는 활동이다.\r\n- 완벽한 테스팅은 불가능하다.\r\n- 테스팅은 개발 초기에 시작해야 한다.\r\n- 결함 집중(파레토 원칙)\r\n  - 많은 성과에서 결과의 약 80%가 20%의 원인에서 발생한다\r\n- 살충제 패러독스\r\n  - 동일한 테스트로 동일한 절차를 반복 수행하면 새로운 결함을 찾을 수 없다.\r\n- 테스팅은 정황(Context)에 의존한다.\r\n- 오류 - 부재의 궤변\r\n  - 결함이 없어도, 요구사항을 충족시켜주지 못한다면 해당 소프트웨어의 품질이 높다고 할 수 없다\r\n\r\n## 애플리케이션 테스트 유형 분류\r\n\r\n- 프로그램 실행 여부\r\n  - 정적 테스트(실행하지 않고 행하는 테스트)\r\n  - 동적 테스트(실행하면서 확인하는 테스트)\r\n- 테스트 기법\r\n  - 화이트박스 테스트\r\n    - 소스코드를 보면서 실행시킴\r\n    - 제어흐름(조건문, 반복문), 데이터 흐름(변수, 자료구조), 분기, 경로 테스트 등이 있음\r\n  - 블랙박스 테스트\r\n    - 기능/부분적인 코드 실행을 통한 테스트\r\n    - 원인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법\r\n    - 경계값 검사 : 입력 조건의 경계값을 테스트 케이스로 선정하는 방법\r\n    - 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법\r\n    - 동등 분할 기법 : 입력 자료에 초점을 맞춰 테스트 케이스를 만들어 검사하는 방법\r\n    - 오류 예측 검사 : 과거의 경험이나 테스터의 감각으로 테스트하는 기법\r\n- 테스트에 대한 시각\r\n  - 검증 테스트(개발자 테스트)\r\n  - 확인 테스트(사용자 테스트)\r\n- 테스트 목적\r\n  - 회복 테스트 : 소프트웨어가 다양한 방법으로 실패하도록 유도하고 회복이 적절하게 수행되는지를 검증하면서 회복이 시스템에 의해 자동으로 수행되면 재초기화, 데이터회복, 재시작 방법 등에 의해 정상적으로 회복되는지를 평가\r\n  - 안전 테스트 : 안전성 검증\r\n  - 강도 테스트 : stress test - 과다한 정보량 투입\r\n  - 성능 테스트 : 응답속도, 처리량 등을 측정\r\n  - 구조 테스트 : 내부 논리경로, 복잡도 평가\r\n  - 회귀 테스트 : 변경 또는 교정이 새로운 오류를 발생시키는지 여부 확인\r\n  - 병행 테스트 : 변경 전과 변경 후 프로그램을 동등한 데이터로 테스트하여 결과 비교\r\n- 테스트 기반\r\n  - 명세 기반 테스트\r\n  - 구조 기반 테스트\r\n  - 경험 기반 테스트\r\n\r\n## 코드 커버리지(Code Coverage)\r\n\r\n- 구문 커버리지\r\n  - 코드 구조 내의 모든 구문에 대해 한 번 이상 수행하는 테스트 커버리지\r\n- 조건 커버리지\r\n  - 결정 포인트 내의 모든 개별 조건식에 대해 수행하는 테스트 커버리지\r\n- 결정 커버리지\r\n  - 결정 포인트 내의 모든 분기문에 대해 수행하는 테스트 커버리지\r\n- 조건/결정 커버리지\r\n  - 결정포인트 T/F, 개별조건식 T/F를 가져야 한다.\r\n- 변경/조건 커버리지\r\n  - 모든 결정 포인트 내의 개별 조건식은 적어도 한 번 T, F를 가져야 한다.\r\n- 다중 조건 커버리지\r\n  - 결정 포인트 내 모든 개별 조건식의 가능한 조합을 100% 보장해야 한다.\r\n\r\n## V 모델과 테스트 레벨\r\n\r\n![V Model Image](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-5.png)\r\n\r\n# 데이터베이스\r\n\r\n## 반정규화의 유형\r\n\r\n|     구분      |       유형       | 설명                    |\r\n| :-----------: | :--------------: | ----------------------- |\r\n|  테이블 분할  |     수평분할     | 레코드 단위로 분할      |\r\n|               |     수직분할     | 컬럼 단위로 분할        |\r\n|  테이블 중복  | 통계 테이블 추가 | DW,OLAP 데이터용        |\r\n|               | 진행 테이블 추가 | 업무 프로세스 상태      |\r\n| 컬럼기반 분할 |  조회 빈도 기반  | 고빈도 컬럼 분리        |\r\n|               |  크기 기반 분할  | 일정 용량 컬럼 분리     |\r\n|   컬럼 중복   |  중복 컬럼 추가  | 자주 조회되는 컬럼 추가 |\r\n|               |  파생 컬럼 추가  | 연산 결과 별도 저장     |\r\n\r\n## 데이터베이스 스키마\r\n\r\n- 외부 스키마\r\n  - VIEW와 연계돼있으며 여러 개가 존재할 수 있다.\r\n- 개념 스키마\r\n  - 데이터베이스의 전체적인 구조와 제약조건을 의미한다.\r\n- 내부 스키마\r\n  - 저장장치 입장에서 본 구조\r\n- 논리적 독립성 : 개념 스키마나 내부 스키마가 바뀌어도 외부 스키마에 영향을 주지 않는다.\r\n- 물리적 독립성 : 내부 스키마가 바뀌어도 개념 스키마와 외부 스키마에 영향을 주지 않는다.\r\n\r\n## SQL 기본문법\r\n\r\nSELECT\r\n\r\n\\*, a, b\r\n\r\nFROM [테이블명]\r\n\r\nWHERE ~~\r\n\r\nAND/OR ~~\r\n\r\nGROUP BY [속성]\r\n\r\nhaving ~~\r\n\r\nORDER BY [컬럼] ASC/DESC\r\n\r\n## SQL ALTER\r\n\r\n- 속성 추가\r\n  - ALTER TABLE [테이블 이름] ADD [속성명] [데이터 타입];\r\n- 속성 변경\r\n  - ALTER TABLE [테이블 이름] MODIFY [속성명] [데이터 타입];\r\n- 속성 삭제\r\n  - ALTER TABLE [테이블 이름] DROP [속성명] [데이터 타입];\r\n\r\n## 관계대수 연산자\r\n\r\n|                  |                                                            |\r\n| :--------------: | ---------------------------------------------------------- |\r\n| 순수 관계 연산자 | SELECT(∑-시그마), PROJECT(π - 파이), JOIN(▶◀), DIVISION(÷) |\r\n| 일반 집합 연산자 | 합집합(∪), 교집합(∩), 차집합(-), 카티션 프로덕트(×)        |\r\n\r\n- SELECT(∑) : 릴레이션에서 조건을 만족하는 수평적 부분 집합(튜플)을 구하기 위한 연산\r\n\r\n![select](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-1.png)\r\n\r\n- PROJECT(π) : 릴레이션에서 수직적 부분으로 집합(속성의 값)을 구하는 연산으로 원하는 속성을 추출하기 위한 연산.\r\n\r\n![project](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-2.png)\r\n\r\n- JOIN(▶◀) : 두 테이블로부터 조건에 맞는 관련된 튜플들을 하나의 튜플로 결합하여 하나의 테이블로 만드는 연산\r\n\r\n![join](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-3.png)\r\n\r\n- DIVISION(÷) : A, B 두 테이블에 대해 'A DIVISION B'는 B 테이블의 조건을 만족하는 튜플들을 테이블 A에서 추출하는 연산\r\n\r\n![division](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-4.png)\r\n\r\n![연산자](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-10.png)\r\n\r\n### 관계 대수\r\n\r\n![관계 대수](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-7.png)\r\n\r\n- 시그마 = ∑\r\n\r\n## 구조적 다이어그램(Structure Diagram)\r\n\r\n- 클래스 다이어그램\r\n  - 시스템을 구성하는 클래스들 사이의 관계를 표현한다.\r\n- 패키지 다이어그램\r\n  - 클래스나 유스케이스 등을 포함한 여러 모델 요소들을 그룹화하여 패키지를 구성하고 패키지들 사이의 관계를 표현한다.\r\n- 복합체 구조 다이어그램\r\n  - 복합 구조의 클래스와 컴포넌트 내부 구조를 표현한다.\r\n- 객체 다이어그램\r\n  - 객체 정보를 보여준다.\r\n- 컴포넌트 다이어그램\r\n  - 컴포넌트 구조 사이의 관계를 표현한다.\r\n- 배치 다이어그램\r\n  - 소프트웨어, 하드웨어, 네트워크를 포함한 실행 시스템의 물리 구조를 표현한다.\r\n\r\n## 행위 다이어그램(Behavior Diagram)\r\n\r\n- 유스 케이스 다이어그램\r\n  - 사용자 관점에서 시스템 행위를 표현한다.\r\n- 활동 다이어그램\r\n  - 업무 처리 과정이나 연산이 수행되는 과정을 표현한다.\r\n- 콜라보레이션 다이어그램\r\n  - 순차 다이어그램(Sequence Diagram)과 같으며, 모델링 공간에 제약이 없어 구조적인 면을 중시한다.\r\n- 상태 머신 다이어그램\r\n  - 객체의 생명주기를 표현한다.\r\n- 순차 다이어그램\r\n  - 시간 흐름에 따른 객체 사이의 상호작용을 표현한다.\r\n- 통신 다이어그램\r\n  - 객체 사이의 관계를 중심으로 상호작용을 표현한다.\r\n- 상호작용 개요 다이어그램\r\n  - 여러 상호작용 다이어그램 사이의 제어 흐름을 표현한다.\r\n- 타이밍 다이어그램\r\n  - 객체 상태 변화와 시간 제약을 명시적으로 표현한다.\r\n\r\n## 테스트 오라클\r\n\r\n- 휴리스틱(Heuristic) 오라클\r\n  - 임의의 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리\r\n- 참(True) 오라클\r\n  - 모든 입력값에 적합한 결과를 생성하여, 발생한 오류를 모두 검출\r\n- 일관성 검사(Consistent) 오라클\r\n  - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 같은지 확인\r\n- 샘플링(Sampling) 오라클\r\n  - 임의로 선정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공\r\n\r\n## 데이터베이스 정규화\r\n\r\n비정규 릴레이션\r\n\r\n↓ 도메인이 원자값\r\n\r\n제1정규형\r\n\r\n↓ 부분적 함수 종속 제거\r\n\r\n제2정규형\r\n\r\n↓ 이행적 함수 종속 제거\r\n\r\n제3정규형\r\n\r\n↓ 결정자이면서 후보키가 아닌 것 제거\r\n\r\nBCNF\r\n\r\n↓ 다치 종속 제거\r\n\r\n제4정규형\r\n\r\n↓ 조인 종속성 이용\r\n\r\n제5정규형\r\n\r\n## 데이터베이스 회복 기법\r\n\r\n- 즉시 갱신 기법\r\n  - 트랜잭션이 실행(활동) 상태에서 변경되는 내용을 그때그때 바로 데이터베이스에 적용하는 기법\r\n  - 변경되는 모든 내용은 로그(Log)에 기록하여 장애 발생 시 로그(Log)의 내용을 토대로 회복\r\n  - Redo, Undo 모두 수행\r\n- 지연 갱신 기법\r\n  - 트랜잭션이 수행되어 부분완료 될 때까지 데이터베이스에 적용하지 않고 지연시킨 후 부분완료가 되면 로그(Log)의 내용을 토대로 데이터베이스에 적용하는 기법\r\n  - Redo만 수행\r\n- 검사점 회복 기법(Checkpoint Recovery)\r\n  - 트랜잭션이 실행되는 중간에 검사 시점(Check Point)을 지정하여 검사 시점까지 수행 후 완료된 내용을 데이터베이스에 적용하는 기법\r\n- 그림자 페이징(Shadow Paging) 기법\r\n  - 로그(Log)를 사용하지 않고, 데이터베이스를 동일한 크기의 단위인 페이지로 나누어 각 페이지마다 복사하여 그림자 페이지를 보관\r\n  - 데이터베이스의 변경되는 내용은 원본 페이지에만 적용하고, 장애가 발생되는 경우 그림자 페이지를 이용해 회복\r\n\r\n## 데이터베이스에서의 이상현상\r\n\r\n- 삽입 이상 : 릴레이션에서 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들로 함께 삽입되는 현상\r\n- 삭제 이상 : 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들로 함께 삭제되는 연쇄 삭제 현상\r\n- 갱신 이상 : 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상\r\n\r\n## 트랜젝션의 특성\r\n\r\n\u003e 트랜젝션이란, 데이터베이스에서 하나의 그룹으로 처리되어야 하는 명령문들을 모아 놓은 논리적인 작업 단위이다. 여러 개의 명령어의 집합이 정상적으로 처리되면 정상 종료되며, 하나의 명령어라도 잘못되면 전체가 롤백된다.\r\n\r\n### 트랜잭션을 사용하는 이유\r\n\r\n- 데이터의 일관성을 유지하면서 안정적으로 데이터를 복구하기 위해 사용한다.\r\n- 데이터베이스에서는 테이블에서 데이터를 읽어 온 후 다른 테이블에 데이터를 입력하거나 갱신, 삭제하는데 처리 도중 오류가 발생하면 모든 작업을 원상태로 되돌린다. 처리 과정이 모두 성공했을 때만 최종적으로 데이터베이스에 반영한다.\r\n\r\n### 트랜잭션의 특징(ACID)\r\n\r\n- 원자성(Atomicity)\r\n  - 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력\r\n  - 트랜잭션이 DB에 모두 반영되거나 전혀 반영되지 않는 것. (All or Nothing)\r\n- 일관성(Consistency)\r\n  - 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.\r\n  - 만약 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.\r\n- 독립성(Isolation)\r\n  - 트랜잭션 수행 시 다른 트랜잭션의 연산 적업이 끼어들지 못하도록 보장하는 것을 의미한다.\r\n  - 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 제 3자가 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽 데이터에 접근할 수 없다.\r\n- 지속성(Durability)\r\n  - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 즉, 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다.\r\n  - 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.\r\n\r\n## 데이터베이스 무결성\r\n\r\n- 개체 무결성(Entity Integrity)\r\n  - 고유 키(유일 키)의 개념과 관련되며, 개체 무결성은 모든 테이블이 기본 키(primary key)를 가져야 하며 기본 키로 선택된 열은 고유하여야 하며 빈 값은 허용하지 않음을 규정한다.**(Not Null 제약조건)**\r\n- 참조 무결성(Referential Integrity)\r\n  - 외래 키(외부 키)의 개념과 관련되며, 참조 무결성 규칙은 모든 외래 키 값은 두 가지 상태 가운데 하나에만 속함을 규정한다.\r\n  - 일반적인 상태는 외래 키 값이 데이터베이스의 특정 테이블의 기본 키 값을 참조하는 것이다. 이는 비즈니스의 규칙에 따라 달라질 수 있으며 외래 키 값은 빈 값을 허용한다.\r\n  - **릴레이션 R1에 속성 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 한다. 이때 참조할 수 없는 외래키 값을 가질 수 없다는 제약조건이다.**\r\n- 도메인 무결성(Domain Integrity)\r\n  - **릴레이션 중 하나의 속성은 반드시 원자 값**이어야 한다는 것을 보장하는 제약조건이다.\r\n\r\n# SW 보안/암호\r\n\r\n## IPSec의 헤더 프로토콜\r\n\r\n- AH(Authentication Header)\r\n  - 무결성을 보장하기 위한 프로토콜이며, IP패킷이 전송중에 변조되지 않았음을 보장하는 서비스를 제공한다.\r\n- ESP(Encapsulation Security Payload)\r\n  - IP 페이로드를 암호화하여 데이터 기밀성을 제공함으로써 제3자에게 데이터가 노출되는 것을 차단한다.\r\n\r\n## LINUX 파일 보안\r\n\r\n예문 : d rwx1 rwx2 rwx3\r\n\r\n- d\r\n  - 파일 종류\r\n  - d : 디렉토리\r\n  - \\- : 일반 파일\r\n  - | : 심볼릭 링크\r\n  - b : 블록형 장치\r\n  - c : 글자형 장치\r\n- rwx1 : 소유자(owner)의 권한\r\n- rwx2 : 그룹(group)의 권한\r\n- rwx3 : 기타 사용자(others)의 권한\r\n\r\n## 암호화 방식의 분류\r\n\r\n- 대칭키(비밀키)\r\n  - Stream - LFSR, RC4\r\n  - Block 방식 - DES, AES, IDEA\r\n- 비대칭키(공개키)\r\n  - 인수분해 이용 - RSA, Robin\r\n  - 이산대수 - Elgamal, DSA\r\n  - 타원곡선 - ECC\r\n\r\n\u003e 대칭키(비밀키)란, 암호화/복호화에 사용하는 키가 동일한 암호화 방식으로, 비대칭키(공개키)에 비해 빠르지만 키를 교환해야 한다는 문제(키 배송 문제)가 발생한다. 키를 교환하는 중 키가 탈취될 가능성도 있고, 사람이 증가할수록 따로 키 교환을 해야하기 때문에 관리해야 할 키가 방대하게 많아진다.\r\n\r\n\u003e 비대칭(공개키)키란, 암호화/복호화에 사용하는 키가 서로 다른 것으로, 송수신자 모두 한 쌍의 키(개인키, 공개키)를 갖고 있게 된다. 일종의 인증 기능을 통해 보안에 용이하나 속도가 느리다.\r\n\r\n### 비밀키(대칭키) 알고리즘\r\n\r\n- DES(Data Encryption Standard - 최근에는 잘 사용되지 않음)\r\n  - 블록 암호의 일종으로, 미국 NBS 에서 국가 표준으로 정한 암호\r\n- AES(DES 보완)\r\n- ARIA(Academy Research Institute Agency,- 학계, 연구소, 정부기관이 공동으로 개발했다는 함축적 의미)\r\n  - 대한민국의 국가보안기술연구소에서 개발한 블록 암호 체계\r\n- SEED\r\n  - 한국정보보호진흥원의 기술진이 개발한 128비트 및 256비트 대칭 키 블록 암호 알고리즘으로, 미국에서 수출되는 웹 브라우저 보안 수준이 40비트로 제한됨에 따라 128비트 보안을 위해 별도로 개발된 알고리즘\r\n- IDEA(International Data Encrption Algorithm)\r\n  - 스위스에서 1990년 Xuejia Lai, James Messey가 만든 PES를 개량하여, 1991년에 제작된 블록 암호 알고리즘이다. 현재 가장 안전하고 최고라고 여겨지는 알고리즘으로, 블록 초당 177Mbit의 빠른 처리가 가능\r\n\r\n### 공개키(비대칭키) 알고리즘\r\n\r\n- RSA(Ron **R**ivest, Adi **S**hamir, Leonard **A**dleman 세 사람의 성을 따서 RSA 라고 이름이 붙은 암호 방식)\r\n  - 2023년 기준 SSL/TLS에 가장 많이 사용되는 공개키 암호화 알고리즘으로, 소인수분해하기 어려움을 이용한다.\r\n- ELGamal(엘가말 알고리즘)\r\n  - 이산대수 문제의 어려움에 근거해 만든 시스템\r\n  - 디지털 서명, 암호화, 키 교환에 사용될 수 있는 공개키 알고리즘\r\n  - 단점은 타 알고리즘에 비해 가장 느림\r\n\r\n### 해시 알고리즘\r\n\r\n- SHA(Secure Hash Algorithm)\r\n  - 미 국가안보국(NSA)이 설계한 암호학적 해시 함수들의 모음으로, MD5를 수정한 버전\r\n- MD5(최근에는 잘 사용되지 않음)\r\n  - 프로그램이 위변조 되었는지를 확인하는 무결성 검사에 사용되며, 입력받은 메시지를 128비트로 압축하는 방식\r\n- HAS-16\r\n  - 한국의 국산 알고리즘으로, 임의의 입력값을 160비트의 고정된 출력값으로 변환하는 알고리즘\r\n  - SHA-1과 출력값의 길이는 같으며, 512비트 단위가 한 블록이다.\r\n\r\n## 암호 방식에 따른 분류\r\n\r\n![암호 방식에 따른 분류](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-8.png)\r\n\r\n## 서비스 공격 유형의 종류\r\n\r\n**※ 보안의 3요소**\r\n\r\n\u003e 정보보안 3원칙\r\n\r\n- 기밀성\r\n  - 타인에게 노출되면 안된다.\r\n  - 인가된 사용자만 정보 자산에 접근할 수 있다.\r\n  - 방화벽, 암호\r\n- 무결성\r\n  - 타인에게 수정되면 안된다.\r\n  - 시스템 내의 정보는 오직 인가된 사용자가 인가된 방법으로만 수정할 수 있다.\r\n- 가용성\r\n\r\n  - 인가된 사용자에게는 언제든지 사용되어야 한다.\r\n  - 사용자가 필요할 때 데이터에 접근할 수 있는 능력을 말한다.\r\n\r\n- DoS(Denial Of Service, 서비스 거부) : DDoS와 마찬가지로 가용성을 해침\r\n  - Smurf Attack\r\n    - IP, ICMP를 사용하는 공격으로 나의 IP 주소를 속여 다른 IP로 데이터를 전송하여 다른 IP를 소유한 기기에 장애를 일으킨다.\r\n    - ICMP : 인터넷 제어 메시지 프로토콜(Internet Control Message Protocol, ICMP)은 네트워크 내 장치가 데이터 전송과 관련된 문제를 전달하기 위해 사용하는 프로토콜\r\n    - EX : 공격자의 ip가 1인 경우 발신 header의 발신 ip를 2로 변경해 2번 ip를 가진 서버의 가용성을 해치는 경우\r\n  - SYN flooding\r\n    - 직역 : SYN 패킷이 흘러 넘친다.\r\n    - 과도한 SYN 패킷을 서버에 서버에 부하를 일으킨다.\r\n    - ![런잇메이트 이미지](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image.png)\r\n  - UDP 플러딩\r\n    - 대량의 UDP 패킷을 이용하여 대상 호스트의 네트워크 자원을 소모시키는 공격\r\n  - Ping 플러딩\r\n    - 네트워크가 정상적으로 작동하는지 여부를 확인하기 위해 사용하는 Ping Test를, 해커가 해킹을 하기 위한 대상 컴퓨터를 확인하기 위한 방법으로 사용한다.\r\n    - 대상 시스템에 ICMP 패킷을 지속적으로 보내서 대상 시스템이 Request에 응답하느라 다른 일을 하지 못하도록 하는 공격이며, 해당 시스템은 끊임없는 응답에 내부 Queue Counter 자원의 고갈로 서비스 불능에 빠진다.\r\n    - 네트워크에 Over Load를 발생시키는 치명적인 공격이 될 수도 있다.\r\n  - Ping of Death\r\n    - 규정 크기 이상의 ICMP(Internet Control Message Protocol) 패킷으로 시스템을 마비시키는 공격\r\n  - Teardrop Attack\r\n    - 구형 컴퓨터 시스템에서 대량의 데이터를 처리할 때 사용하는 코드에 내재하는 버그를 이용하는 공격 방식으로, 시스템이 모든 비트를 올바른 순서대로 결합하여 정상적으로 이용하지 않고, 비트가 수신될 때까지 기다리기만 하여 결국 비트가 영원히 수신되지 않고 시스템 전체가 마비될 수 있다.\r\n  - Land Attack\r\n    - 출발지 IP와 목적지 IP가 같은 패킷을 만들어 보내는 공격 방법\r\n    - 수신자가 응답을 보낼 때, 목적지 주소가 자기 자신이므로 SYN 신호가 계속 자신의 서버를 돌게 되어 서버의 자원을 고갈시켜 가용성을 파괴한다.\r\n- DDoS(Distributed Denial of Service, 분산 서비스 거부)\r\n  - 피싱(Phishing) : 개인정보(Private Data)를 낚는다(Fishing) 라는 의미의 합성어로, 이메일 또는 메신저를 사용해 신뢰할 수 있는 사람 또는 기업이 보낸 메시지인 거처럼 가장함으로써 중요 정보를 얻어내는 소셜 엔지니어링의 한 종류\r\n  - 파밍(Pharming) : 악성코드에 감염된 PC를 조작해 이용자 자신의 브라우저에 정확한 웹 페이지 주소를 입력해도 가짜 웹 페이지에 접속하게 하여 개인정보를 훔치는 것\r\n  - 스니핑(Sniffing) : 네트워크 상에서 자신이 아닌 다른 사용자들의 패킷 교환을 엿듣는 것\r\n  - 스미싱(Smishing) : 문자 메시지를 이용한 피싱으로, SMS와 피싱의 합성어이다. 신뢰할 수 있는 사람 또는 기업이 보낸 것처럼 가정하여 개인정보를 요구하거나 휴대 전화의 소액 결제를 유도한다.\r\n  - 큐싱(Qshing) : QR코드를 이용한 피싱으로, 사용자를 속이기 위한 진화된 금융사기 수법이다.\r\n  - 랜섬웨어(RansomWare) : 데이터를 암호화하고 암호화된 파일의 잠금 해제를 위해 대금을 요구하는 일종의 멜웨어이다.\r\n  - 키 로거(Key Logger) : 사용자의 키보드를 통해 입력한 내용을 몰래 가로채는 기술이나 행위를 의미한다.\r\n  - SQL 삽입(SQL Injection) : 응용 프로그램 보안 상의 허점을 의도적으로 이용해 악의적인 SQL문을 실행되게 함으로써 DB를 비정상적으로 조작하는 코드 인젝션 공격이다.\r\n  - XSS(Cross Site Scripting) : 웹사이트 관리자가 아닌 자가 웹 페이지에 악성 스크립트를 삽입할 수 있는 취약점이다.\r\n\r\n### 기타 서비스 공격 유형의 종류\r\n\r\n- 무작위 대입 공격(Brute-Force Attack) : 무차별 암호 대입 공격으로 모든 경우의 수를 입력함으로써 해킹을 시도하는 공격 방식\r\n- 스피어 피싱(Spear Phising) : 조직의 특정 개인 또는 그룹을 대상으로 한 피싱 공격의 유형으로, 공격자는 피해자가 알거나 신뢰하는 사람으로 가장해 피해자가 민감한 정보를 유출하거나 멜웨어를 다운로드하거나, 공격자에 대한 지급을 승인하거나 송금하도록 시키는 등의 행위를 하도록 조종한다.\r\n- APT(Advanced Persistent Threat, 지능적 지속 위협) : 지능적인 방법을 사용해 지속적으로 특정 대상을 공격하는 것으로, 하나의 대상을 정해 성공할 때까지 공격을 멈추지 않는 것이 특징이다. 기업이나 기관의 시스템은 보안이 단단해 침투가 어렵기 때문에, 회사 개인 PC를 먼저 장악한 후, 합법적인 권한을 획득해 내부로 들어가는 방법을 주로 사용한다.\r\n- 제로데이(Zero - day) 공격 : 특정 소프트웨어의 패치되거나 공표되지 않은 보안 취약점을 이용한 해킹의 통칭이다.\r\n- 백도어(Back Door) : 정상적인 보안 조치를 우회하여 시스템에 액세스할 수 있는 모든 경로를 의미한다. 소프트웨어는 엔지니어와 개발자가 자체 방어를 우회하여 사용자의 문제를 해결할 수 있도록 코드에 백도어가 내장되어 있는 경우가 많다.\r\n- Rainbow Table Attack : 패스워드 별로 해시 값을 미리 생성해 크래킹 하고자 하는 해시 값을 테이블에서 검색하여 역으로 패스워드를 찾는 방법\r\n- CSRF(Cross Site Request Forgery - 사이트 간 요청 위조) : 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격이다.\r\n- TOCTOU(Time Of Check To Time Of Use) : 두 시점 사이의 타이밍을 노리는 공격이나 그런 공격을 가능하게 하는 버그 유형이다.\r\n\r\n## 스푸핑(Spoofing)\r\n\r\n- IP 스푸핑\r\n  - IP 자체의 보안 취약성을 악용한 것으로 자신의 IP 주소를 속여서 접속하는 공격\r\n  - IP 스푸핑을 통해 서비스 거부 공격(DoS)도 수행 가능하며, 공격 대상 컴퓨터와 서버 사이의 연결된 세션을 끊을 수도 있다.\r\n  - 종단 인증(end point authentication) 같은 방법으로 해결한다.\r\n- DNS 스푸핑\r\n  - 공격대상에게 전달되는 DNS IP 주소를 조작하여 의도치 않는 주소로 접속하는 공격\r\n  - 공격대상은 정상적인 URL을 통해서 접속하지만, 실제로 가짜 사이트로 접속된다.\r\n- ARP 스푸핑\r\n  - MAC 주소를 속여 랜에서의 통신 흐름을 왜곡시키는 공격.\r\n  - 공격 대상 컴퓨터로부터 정보를 빼낸다.\r\n\r\n## 블록암호 알고리즘\r\n\r\n- AES\r\n  - 128bit 평문을 128/192/256bit로 암호화\r\n  - 키 크기에 따라 10/12/14회 Round 수행\r\n  - 1997년 NIST에 의해 제정\r\n  - 레인달(Rijndeal)에 기반한 암호화 방식\r\n  - SPN 암호 방식을 사용한다.\r\n- SEED\r\n  - 순수 국내기술로 개발한 128비츠 및 256비트 대칭키 블록 암호 알고리즘\r\n- ARIA\r\n  - 국가 보안 기술 연구소(NSRI) 필두로 학계, 국가 정보원 등의 암호 기술 전문가들이 개발한 국가 암호화 알고리즘\r\n  - AES 알고리즘과 똑같이 128/192/256비트 암호화키를 지원한다.\r\n  - SPN 암호 방식을 사용한다.\r\n- IDEA\r\n  - 1990년 스위스에서 만들어진 PES를 개량하여 만들어진 블록 암호 알고리즘\r\n  - 키길이가 128bit, 블록길이가 64bit\r\n  - Feistel 방식과 SPN의 중간형태 구조\r\n\r\n## 보안 솔루션\r\n\r\n- 방화벽(Firwall)\r\n  - 네트워크 간에 전송되는 정보를 선별하는 기능을 가진 침입 차단 시스템\r\n- 웹 방화벽(Web Firewall)\r\n  - 웹 기반 공격을 방어할 목적으로 만들어진 웹서버 특화 방화벽\r\n- 침입탐지 시스템(IDS - Intrusion Detection System)\r\n  - 컴퓨터 시스템의 비정상적인 사용, 오용 등을 실시간으로 탐지하는 시스템\r\n  - 이상탐지, 오용탐지\r\n- 침입방지 시스템(IPS - Intrusion Prevention System)\r\n  - 방화벽과 침입탐지 시스템을 결합한 것\r\n- 데이터유출방지(DLP - Data Leakage/Loss Prevention)\r\n  - 내부 정보의 유출을 방지하기 위한 보안솔루션\r\n- NAC(Network Access Control)\r\n  - 네트워크에 접속하는 내부 PC의 MAC 주소(고유랜카드주소)를 IP관리 시스템에 등록한 후 일관된 보안관리 기능을 제공하는 보안솔루션\r\n- ESM(Enterprise Security Management)\r\n  - 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합관리 하는 보안 솔루션\r\n\r\n## SIEM(Security Information and Event Management) 보안\r\n\r\n\u003e SIEM란? 소프트웨어 제품 및 서비스가 보안 정보 관리와 보안 이벤트 관리를 결합하는 컴퓨터 보안의 한 분야로, 애플리케이션 및 네트워크 하드웨어에서 생성된 보안 경고에 대한 실시간 분석을 제공한다. 빅데이터 수준의 데이터를 장시간 심층 분석한 인덱싱 기반이며 주요기능은 데이터 통합, 상관관계, 알림, 대시보드 등이 있다.\r\n\r\n# 네트워크\r\n\r\n## IPv4/IPv6 전환 기술\r\n\r\n|                                 |                                                                                                                    |\r\n| :-----------------------------: | ------------------------------------------------------------------------------------------------------------------ |\r\n|     듀얼 스택 (Dual Stack)      | IPv4/IPv6를 동시에 지원 (IPv4/IPv6 패킷을 주고받을 수 있음)                                                        |\r\n|       터널링 (Tunneling)        | 두 IPv6 네트워크 간에 터널을 이용하는 기술 (IPv4/IPv6 호스트와 라우터에서 IPv6 패킷을 IPv4 패킷에 캡슐화하여 전송) |\r\n| 주소 변환 (Address Translation) | IPv4와 IPv6 간에 주소를 변환하여 두 버전을 연동                                                                    |\r\n\r\n# 프로토콜 및 기타\r\n\r\n## 라우팅 프로토콜\r\n\r\n![라우팅 프로토콜](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-9.png)\r\n\r\n## RIP(Routing Information Protocol)\r\n\r\n- 가장 널리 사용되는 라우팅 프로토콜로, 최단 경로 탐색에 Bellman-Ford 알고리즘이 사용된다.\r\n- 소규모 동종의 자율 시스템 내에서 효율적인 방법이며, 최대 홉 수가 15로 제한된다.\r\n\r\n## EAI(Enterprise Architecture Integration - 기업 어플 통합) 구축 유형\r\n\r\n|          유형          |                                                                         설명                                                                         |\r\n| :--------------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------: |\r\n|     point to point     |         중간에 미들웨어를 두지 않고 각 애플리케이션 간 직접 연결 솔루션 구매 없이 통합, 상대적으로 저렴하게 통합 가능 (변경, 재사용 어려움)          |\r\n|      hub \u0026 spoke       |      단일 접점이 허브 시스템을 통해 데이터를 전송하는 중앙 집중적 방식 - 모든 데이터 전송 보장, 확장 및 유지 보수 용이 (허브 장애 시 전체 영향)      |\r\n| Message Bus (ESB 방식) | 애플리케이션 사이 미들웨어(버스)를 두어 처리하며 미들웨어를 통한 통합함. 어댑터가 각 시스템과 버스를 두어 연결하므로 뛰어난 확장성, 대용량 처리 가능 |\r\n|         Hybrid         |                                          유연한 통합 작업이 가능 (표준 통합 기술, 데이터 병목 현상 최소화)                                           |\r\n\r\n## 라우팅 영역에 따른 분류\r\n\r\n|                                 |                                                        |\r\n| :-----------------------------: | ------------------------------------------------------ |\r\n| IGP (Interior Gateway Protocol) | AS(Autonomous System) 내부 라우터 간 (RIP, OSPF, IGRP) |\r\n| EGP (Exterior Gateway Protocol) | AS(Autonomous System) 외부 라우터 상호간 (EGP, BGP)    |\r\n\r\n### IGP(Interior Gateway Protocol)\r\n\r\n- RIP(Routing Information Protocol - 라우팅 정보 프로토콜)\r\n  - RIP는 경유할 가능성이 있는 라우터를 홉수로 수치화하여, DVA(Distance Vector Algorithm - 거리 벡터 알고리즘)라는 알고리즘으로 인접 호스트와의 경로를 동적으로 교환하는 일이다.\r\n  - **홉 카운트의 제한은 15개**로 제한한다.\r\n- OSPF(Open Shortest Path First - 동적 라우팅 프로토콜)\r\n  - 최단 경로 탐색에 다익스트라 알고리즘 기반 방식을 사용하며, 최적 경로 선택을 위해 홉수, 대역폭, 지연시간 등을 고려한다.\r\n  - 링크상태 변화시에만 라우팅정보를 전송한다.\r\n- IGRP(Internet Gateway Routing Protocol - 인터넷 게이트웨이 라우팅 프로토콜)\r\n  - RIP의 단점을 보완하기 위한 프로토콜로, 최대 홉 수를 255로 늘렸다.\r\n\r\n### EGP\r\n\r\n- EGP(Exterior Gateway Protocol - 게이트웨이 역외 프로토콜)\r\n- 다른 그룹과 라우팅 정보를 교환하는 프로토콜\r\n- 시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜\r\n- 다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 EGP의 본래 목적이다.\r\n- BGP(Boarder Gateway Protocol - 종속 게이트웨이 프로토콜)\r\n  - AS 간에 라우팅 정보를 전달하는데 사용되고 있는 대규모 라우팅 프로토콜\r\n  - 인터넷 코어 라우터, 중간 ISP 라우터, ISP CPE(Customer Premises Equipment) 또는 소규모 개인 BGP 네트워크의 라우터 등 다양한 토폴로지 설정으로 배치될 수 있다.\r\n  - 작동 원리 =\u003e 통신에 TCP 포트 179를 사용한다. Path-Vector 프로토콜로 간주되며 대상에 대한 전반적인 경로 설명을 포함한다. iBGP은 인접 항목이 동일한 AS에 있고eBGP는 인접 항목이 다른 AS에 있다.\r\n\r\n## RARP\r\n\r\n- RARP(Reverse Address Resolution Protocol - 역순 주소 결정 프로토콜)\r\n  - IP호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우, 서버로부터 IP주소를 요청하기 위해 사용한다.\r\n\r\n## AC와 DAC\r\n\r\n- AC(Access Control - 접근 통제)\r\n  - 디렉토리나 파일, 네트워크 소켓 같은 시스템 자원을 적절한 권한을 가진 사용자나 그룹이 접근하고 사용할 수 있게 통제하는 것\r\n- DAC(Discretionary Access Control - 임의 접근 통제)\r\n  - 시스템 객체에 대한 접근을 사용자 또는 그룹의 신분을 기준으로 제한하는 방법\r\n  - 사용자나 그룹이 객체의 소유자라면 다른 주체에 대해 이 객체에 대한 접근 권한을 설정할 수 있다.\r\n- MAC(Mandatory Access Control - 강제 접근 통제)\r\n  - 미리 정해진 정책과 보안 등급에 의거하여 주체에게 허용된 접근 권한과 객체에게 부여된 허용 등급을 비교하여 접근을 통제하는 모델\r\n  - 높은 보안을 요구하는 정보는 낮은 보안 수준의 주체가 접근할 수 없으며, 소유자라고 할지라도 정책에 어긋나면 객체에 접근할 수 없으므로 강력한 보안을 제공한다.\r\n\r\n## WSDL (Web Service Description Language)\r\n\r\n\u003e WSDL은 웹 서비스 기술언어 또는 기술된 정의 파일의 총징으로 XML로 기술된다. 웹 서비스의 구체적 내용이 기술되어 있어 서비스 제공 장소, 서비스 메시지 포맷, 프로토콜 등이 기술된다.\r\n\r\n## SOAP (Simple Object Access Protocol)\r\n\r\n\u003e SOAP는 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. SOAP는 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다.\r\n\r\n## IPC(Inter-Process Communication - 프로세스 간 통신)\r\n\r\n\u003e IPC란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다. IPC는 마이크로커널과 나노커널의 디자인 프로세스에 매우 중요하다. 마이크로커널은 커널이 제공하는 기능의 수를 줄여준다.\r\n\r\n## 파일의 구조\r\n\r\n- 순차 파일(Sequential File, 순서 파일)\r\n  - 순차 파일은 레코드를 논리적인 처리 순서에 따라 연속된 물리적 공간으로 기록하는 것\r\n- 직접 파일(Direct File)\r\n  - 파일을 구성하는 레코드를 임의의 물리적 저장공간에 기록하는 것\r\n- 색인 순차 파일(Indexed Sequential File)\r\n  - 순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 상태\r\n\r\n## 빅데이터 관련 용어\r\n\r\n- Big Data\r\n  - 대량의 정형 또는 비정형 데이터 집합 및 이러한 데이터로부터 가치를 추출하고 결과를 분석하는 기술\r\n- Hadoop (하둡)\r\n  - 오픈 소스 기반 분산 컴퓨팅 기술\r\n  - 현재 정형/비정형 빅 데이터 분석에 가장 선호되는 솔루션\r\n- NoSQL\r\n  - 전통적인 관계형 데이터베이스 RDBMS와 다르게 설계된 비관계형 데이터베이스\r\n  - 대규모의 유연한 데이터 처리를 위해서 적합\r\n- Data Mining(데이터 마이닝)\r\n  - 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 것\r\n- 데이터 웨어하우스\r\n  - 기간 시스템의 데이터베이스에 축적된 데이터를 공통의 형식으로 변환하여 관리하는 데이터베이스\r\n- 데이터 마트\r\n  - 데이터의 한 부분으로서 특정 사용자가 관심을 갖는 데이터들을 담은 비교적 작은 규모의 데이터 웨어하우스\r\n- OLAP\r\n  - 이용자가 직접 데이터베이스를 검색, 분석해서 문제점이나 해결책을 찾는 분석형 애플리케이션 개념\r\n- Mashup\r\n  - 웹에서 제공하는 정보 및 서비스를 이용하는 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술\r\n\r\n## 컴퓨터 환경\r\n\r\n1. 온-프레미스\r\n   - 온-프레미스 컴퓨팅은 기업이나 조직이 자체적으로 하드웨어, 소프트웨어 등의 모든 컴퓨팅 환경을 구축하는 것으로, 전통적인 서버나 데이터 센터를 의미하기도 한다.\r\n   - 초기에 큰 투자가 필요하지만, 서비스 제공자인 아마존, 구글 등의 외부 사업자에게 종속될 우려가 있는 클라우드 컴퓨팅과는 달리 시스템의 모든 설정을 사용자의 필요에 따라 제어핧 수 있다는 장점이 있다.\r\n2. 클라우드\r\n   - 클라우드 컴퓨팅은 사용자의 직접적인 활발한 관리 없이 특히, 데이터 스토리지(클라우드 스토리지)와 컴퓨팅 파워와 같은 컴퓨터 시스템 리소스를 필요로 할 때 바로 제공(on-demand availability)하는 것을 말한다.\r\n   - 일반적으로는 인터넷 기반 컴퓨팅의 일종으로 정보를 자신의 컴퓨터가 아닌 클라우드에 연결된 다른 컴퓨터로 처리하는 기술을 의미한다.\r\n   - 공유 컴퓨터 처리 자원과 데이터를 컴퓨터와 다른 장치들에 요청 시 제공해준다.\r\n   - 구성 가능한 컴퓨팅 자원(ex. 컴퓨터 네트워크, 데이터베이스, 서버, 스토리지, 애플리케이션, 서비스, 인텔리전스)에 대해 어디서나 접근할 수 있는, 주문형 접근을 가능케하는 모델이며, 최소한의 관리 비용으로 빠르게 릴리스를 가능하게 한다.\r\n3. 하이브리드\r\n   - 하이브리드 클라우드는 하나 이상의 프라이빗 클라우드와 하나 이상의 퍼블릭 클라우드의 조합을 사용하는 클라우드 컴퓨팅 모델이다.\r\n   - 이러한 클라우드 조합이 함께 작동하여 유연하게 혼합된 클라우드 컴퓨팅 서비스를 제공한다.\r\n   - 인프라와 운영을 일관되게 확장하여 두 환경 모두에서 애플리케이션 워크로드를 관리하는 단일 운영 모델을 제공하므로, 비즈니스 요구 사항에 따라 프라이빗 클라우드와 퍼블릭 클라우드 간에 워크로드의 원활한 마이그레이션이 가능하다.\r\n\r\n## RAID(Redundant Array of Inexpensive/Independent Disk - 복수 배열 저가/독립 디스크) 형태\r\n\r\n- RAID 1 (미러링)\r\n  - 두 개 이상의 디스크를 미러링을 통해 하나의 디스크처럼 사용\r\n- RAID 2 (해밍코드)\r\n  - 오류 정정을 위한 해밍코드를 사용하는 방식\r\n- RAID 3 (1:M)\r\n  - 하나의 디스크를 패리티(Parity) 정보를 위해 사용하고 나머지 디스크에 데이터를 균등하게 분산 저장\r\n- RAID 4 (RAID 3 upgrade)\r\n  - RAID 3과 같은 방식이나, 블록 단위로 분산 저장한다.\r\n- RAID 5 (3 이상)\r\n  - 3개 이상의 디스크를 붙여서 하나의 디스크처럼 사용하고 각각의 디스크에 패리티 정보를 가지고 있는 방식\r\n- RAID 6 ( 1 : 2(분산) )\r\n  - 하나의 패리티를 두 개의 디스크에 분산 저장하는 방식\r\n\r\n## OSI7 참조 모델\r\n\r\n![OSI7](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-6.png)\r\n\r\n## WAF(Web application firewall - 웹 애플리케이션 방화벽)\r\n\r\n- 웹 서버로 들어오는 웹 트래픽을 검사하여 악의적인 코드나 공격 유형이 포함된 웹 트래픽을 차단해 주는 방화벽으로, SQL Injection이나 XSS 등과 같은 웹 공격을 탐지하고 차단한다.\r\n- 일반 방화벽과는 달리 패킷의 페이로드를 직접 확인하기 때문에 외부의 공격뿐만 아니라 사전에 발견하지 못했던 내부의 위험 요소에 대한 방어가 가능하다.\r\n\r\n## VDW(Virtual Data Warehouse - 가상 데이터 웨어하우스)\r\n\r\n- 물리적으로 데이터 웨어하우스를 구축하지 않아도 실제 구축한 것과 같은 가상 시스템으로, 비교적 낮은 비용으로 빠른 시간 안에 데이터를 분석할 수 있고, 데이터의 추출 및 로딩 과정이 생략되어 실제 데이터 웨어하우스를 구축하는 것에 비해 노력과 시간이 절감된다.\r\n- 하지만 온라인 트랜잭션 처리(OLTP) 작업이 대량으로 수행되거나 일정 시간 대에 집중되는 경우에는 시스템의 성능이 저하되거나 신뢰성 및 안정성에 문제가 발생할 수 있다.\r\n\r\n## 프로토콜 주요 포트 번호\r\n\r\n[참조링크](https://ko.wikipedia.org/wiki/TCP/UDP%EC%9D%98_%ED%8F%AC%ED%8A%B8_%EB%AA%A9%EB%A1%9D)\r\n\r\n- FTP(20) : File Transfer Protocol(파일 전송 프로토콜) - 데이터 포트\r\n- FTP(21) : File Transfer Protocol(파일 전송 프로토콜) - 제어 포트\r\n- SSH(22) : Secure SHell 원격지 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜\r\n- Telnet(23) : 멀리 떨어져 있는 컴퓨터에 접속해 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스로, 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널(Virtual Terminal) 기능을 수행한다.\r\n- SMTP(25) : Simple Mail Transfer Protocol(이메일 전송 프로토콜)\r\n- HTTP(80) : Hyper Text Transfer Protocol(웹 페이지 전송 프로토콜)\r\n\r\n# C언어 및 기타\r\n\r\n## C 비트연산자(연산자 \u0026, |, ^, ~, \u003c\u003c, \u003e\u003e, and, or, xor, 비트 반전, 비트 이동)\r\n\r\n| 연산자 |                                                                          연산자의 기능                                                                           |\r\n| :----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------: |\r\n|   \u0026    |                                                      비트단위로 AND 연산을 한다. (논리합 - 둘 다 1이어야 1)                                                      |\r\n|   \\|   |                                                    비트단위로 OR 연산을 한다. (논리곱 - 둘 중 하나가 1이면 1)                                                    |\r\n|   ^    |                                              비트단위로 XOR 연산을 한다. (두 개의 비트가 서로 다른 경우에 1을 반환)                                              |\r\n|   ~    |                                       단항 연산자로서 피연자의 모든 비트를 반전시킨다 . (00001111 =\u003e 11110000) - NOT 연산                                        |\r\n|   \u003c\u003c   |                                피연산자의 비트 열을 왼쪽으로 이동시킨다. (00001100 \u003c\u003c 2 == 00110000, 00001100 \u003c\u003c 3 == 01100000 )                                 |\r\n|   \u003e\u003e   | 비연산자의 비트 열을 오른쪽으로 이동시킨다. (00011000 \u003e\u003e 2 == 00000110, 00011000 \u003e\u003e 3 == 00000011 ) 단 시프트 연산 대상이 음수인 경우 CPU에 따라 달라질 수 있다. |\r\n\r\n참조 :\r\n\r\n[Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84)\r\n\r\n[TTA 정보통신 용어사전](https://terms.tta.or.kr/)\r\n\r\n[위키백과](https://ko.wikipedia.org/)\r\n\r\n[유튜브 홍달쌤](https://www.youtube.com/@HeungSsaem)\r\n\r\n[런잇메이트 블로그](https://runit-mate.tistory.com/)\r\n"},{"title":"sw first test5","description":"정보처리기사 필기(5) - 정보처리시스템 구축 관리","category":"sw","date":"2023-12-28","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 소프트웨어 개발 방법론 활용\r\n\r\n### 소프트웨어 개발 생명주기 모형(SDLC - Software Development Life Cycle Model)\r\n\r\n- 소프트웨어 개발 조직이 담당하는 작업 종류와 순서, 그리고 각 단계에서 생성되는 결과물을 정리한 것이다.\r\n- 소프트웨어 프로세스 모형이라고도 한다.\r\n- 소프트웨어의 종류, 시스템의 규모, 난이도, 신뢰도, 조직의 규모 등에 따라 적합한 생명주기 모형이 다르다.\r\n- 소프트웨어 생명주기 모형에 따라 소프트웨어의 품질을 높이고, 개발 기간과 비용을 줄일 수 있다.\r\n- 소프트웨어 생명주기 모형에는 구축 및 수정 모형, 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 등이 있다.\r\n\r\n### 프로토타입 모형(Prototype Model)\r\n\r\n- 실제 개발될 소프트웨어에 대한 시제품(Prototype)을 만들어 최종 결과물을 예측하는 모형이다.\r\n- 요구 수집, 빠른 설계, 프로토타입 구축, 고객 평가, 프로토타입 조정, 구현의 단계를 통해 소프트웨어를 개발하는 모형이다.\r\n- 최종 결과물이 만들어지기 전에 의뢰자가 최종 결과물의 일부 또는 모형을 볼 수 있다.\r\n- 발주자(의뢰자)나 개발자 모두에게 공동의 참조 모델을 제공한다.\r\n- 구축하고자 하는 시스템의 요구사항이 불명확한 경우 가장 적절하게 적용될 수 있다.\r\n- 사용자 요구사항을 정확하게 파악하고 충실히 반영할 수 있다.\r\n- 개발 단계 안에서 유지보수가 이루어지는 것으로 볼 수 있다.\r\n\r\n### 폭포수 모형(Waterfall Model)\r\n\r\n- 보헴(Boehm)이 제안한 고전적 생명주기 모형으로, 선형 순차적 모형이라고도 한다.\r\n- 타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수의 단계를 통해 소프트웨어를 개발하는 모형이다.\r\n- 순차적인 접근 방법을 이용하며, 단계적 정의와 산출물이 명확하다.\r\n- 각 단계의 결과가 확인되어야지만 다음 단계로 넘어간다.\r\n- 개발 중 발생한 요구사항은 반영하기 어렵다.\r\n- 가장 오래된 모형으로 모형의 적용 경험과 성공 사례가 많다.\r\n\r\n### 나선형 모형(Spiral Model)\r\n\r\n- Boehm이 제시하였으며, 반복적인 작업을 수행하는 모형으로 점증적 모형, 집중적 모형이라고도 한다. 완성도 높은 소프트웨어를 만들 수 있다.\r\n- 여러 번의 개발 과정을 거쳐 완벽한 최종 소프트웨어를 개발하는 점진적 모형이다.\r\n- 가장 큰 장점인 위험 분석 단계에서 기술과 관리의 위험 요소들을 하나씩 제거해 나감으로써 위험성 평가에 크게 의준하기 때문에 이를 발견하지 않으면 문제가 발생할 수 있다.\r\n- 대규모 시스템의 소프트웨어 개발에 적합하다.\r\n\r\n#### 나선형 모형의 개발 단계\r\n\r\n1. 계획 수립(Planning) : 위험 요소와 타당성을 분석하여 프로젝트의 추진 여부를 결정한다.\r\n2. 위험 분석(Risk Analysis) : 개발 목적과 기능 선택, 제약 조건 등을 결정하고 분석한다.\r\n3. 개발 및 검증(Development) : 선택된 기능을 수행하는 프로토타입을 개발한다.\r\n4. 고객 평가(Evaluation) : 개발된 프로토타입을 사용자가 확인하고 추가 및 수정될 요구사항이 있으면 이를 반영한 개선 프로토타입을 만든다.\r\n\r\n# 소프트웨어 개발 방법론\r\n\r\n- 소프트웨어 개발 생명주기에 소프트웨어 공학 원리를 적용한 것으로 소프트웨어 개발 전 과정에 지속적으로 작용할 수 있는 방법, 절차, 기법 등을 의미하며, 시스템 개발 주기라고도 한다.\r\n- 소프트웨어 개발 과정을 정리하고 표준화하여 프로그래머 개인이 개발 과정에서의 일관성을 유지하고 프로그래머들 간의 효과적인 협업이 이루어질 수 있게 한다.\r\n\r\n### 구조적 방법론(Structured Development Methodolohy)\r\n\r\n- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 체계적인 방법론이다.\r\n- 요구사항 분석, 구조적 분석, 구조적 설계, 구조적 프로그래밍 단계로 구성된다.\r\n- 쉽게 이해할 수 있고 검증할 수 있는 프로그램의 부호를 생성하는 것이 목적이다.\r\n- 1970년대까지 가장 많이 적용된 방법론이다.\r\n- 시스템 분석을 위해 데이터 흐름 다이어그램(Data Flow Diagram)이 주로 사용된다.\r\n- 시스템 설계를 위해 구조도(Structured Chart) 기획, 분석, 설계, 구축하는 데이터 중심의 방법론이다.\r\n- 구조적 방법론의 거시적 관점 부재에서 등장하였다.\r\n- 자료에 중점을 두어 자료와 프로세스를 별개의 작업으로 병행 진행한 후 서로 간의 오류를 상관 분석하여 검증한다.\r\n- 정보 전략 계획(ISP), 업무 영역 분석(BAA), 업무 시스템 설계(BSD), 시스템 구축(SC) 단계로 구성된다.\r\n\r\n### 객체지향 방법론(Object-oriented Engineering Methodolohy)\r\n\r\n- 분석, 설계, 개발 단계에 객체지향 기법을 활용하는 방법론이다.\r\n- 구조적 프로그래밍 기법의 한계와 소프트웨어 개발의 위기에서 등장하였다.\r\n- 요구분석, 설계, 수현, 테스트 및 검증 단계로 구성된다.\r\n- 객체지향의 기본 원칙은 캡슐화(Encapsulation), 정보 은닉(Information Hiding), 추상화(Abstraction), 상속(Inheritance), 다형성(Polymorphism)이다.\r\n- 시스템 분석을 위해 유스케이스 다이어그램(UseCase Diagram)이 주로 사용된다.\r\n- 시스템 설계를 위해 시퀀스 다이어그램(Sequence Diagram)이 주로 사용된다.\r\n\r\n### 컴포넌트 기반 개발 방법론(CBD : Component Based Development)\r\n\r\n- 재사용이 가능한 컴포넌트의 개발 또는 상용 컴포넌트들을 조합하여 애플리케이션 개발 생산성과 품질을 높이고, 시스템 유지보수 비용을 최소화할 수 있는 개발 방법 프로세스이다.\r\n- 컴포넌트 단위의 개발 및 조립을 통해 정보 시스템의 신속한 구축, 변경, 확장의 용이성과 타 시스템과의 호환성을 달성하고자 하는 소프트웨어 공학 프로세스, 방법론 및 기술의 총체적 개념이다.\r\n\r\n#### CBD 방법론의 특징\r\n\r\n- 개발 준비, 분석, 설계, 구현, 테스트, 전개, 인도 순으로 반복, 점진적 개발 프로세스를 제공하고, 시스템 설계를 위해 컴포넌트 설계서가 주로 사용된다.\r\n- 컴포넌트(Component)는 DB와 SW의 모듈 단위로, 재사용이 가능하다.\r\n- 시스템 분석을 위해 유스케이스 다이어그램(UseCase Diagram)이 주로 사용된다.\r\n- 개발 기간 단축으로 인한 생산성이 향상되며 새로운 기능 추가가 쉬워 확장성이 높다.\r\n\r\n### 소프트웨어 재사용(Software Reuse)\r\n\r\n- SW 개발의 품질과 생산성을 높이기 위한 방법으로, 이미 개발되어 안정화된 SW의 전체 혹은 일부분을 다른 SW 개발이나 유지에 사용하는 것이다.\r\n- 기존에 개발된 SW와 경험, 지식 등을 새로운 SW에 적용한다.\r\n- 클래스, 객체 등의 소프트웨어 요소는 소프트웨어 재사용성을 크게 향상했다.\r\n- 소프트웨어 부품(모듈)의 크기가 작고 일반적인 설계일수록 재사용률이 높다.\r\n  - 합성 중심(Composition-Based)\r\n    - 전자칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법으로, 블록 구성 방법이라고도 한다.\r\n  - 생성 중심(Generation-Based)\r\n    - 추상화 형태로 쓰여진 명세를 구체화하여 프로그램을 만드는 방법으로, 패턴 구성 방법이라고도 한다.\r\n\r\n# 비용 산정 모델\r\n\r\n- 전문가 감정 기법, 델파이(Delphi) 기법, LOC(Line Of Code) 기법, COCOMO(COnstructive CostMOdel) 모델, Putnam 모델, 기능 점수(FP: Functional Point) 등이 있다.\r\n\r\n### 전문가 감정 기법\r\n\r\n- 개발 조직 내에 경험이 많은 2인 이상의 전문가에게 비용 산정을 의뢰하는 기법이다.\r\n- 의뢰자의 신뢰도가 높고 편리하게 비용을 산정할 수 있다.\r\n- 과거 프로젝트와의 유사성이 낮을 수 있다.\r\n- 전문가에 따라 감정의 편차가 클 수 있다.\r\n\r\n### 델파이(Delph) 기법\r\n\r\n- 산정 요원과 조정자에 의해 산정하는 기법이다.\r\n- 전문가가 독자적으로 감정할 때 발생할 수 있는 편차를 줄이기 위해 단계별로 전문가들의 견해를 조정자가 조정하여 최종 견적을 결정한다.\r\n- 유사한 프로젝트 경험을 가진 전문가 집단을 구성하여 규모, 공수, 비용의 산정 의견을 구한다.\r\n- 의견 일치가 이뤄지지 않을 경우 의견의 근거를 익명으로 집단 내에 배포하고 자신들의 산정을 수정할 수 있도록 한다.\r\n\r\n### LOC(Line of Code) 기법 ★★★\r\n\r\n- 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법이다.\r\n\r\n```\r\n예측치 = a + (4 X C) + b / 6 (단 a는 낙관치, b는 비관치, c는 기대치임)\r\n```\r\n\r\n- ex. 규모 추정이 a: 60, b: 200, c:100인 경우 LOC는 다음과 같다.\r\n\r\n```\r\nLOC = 60 + (4 X 100) + 200 / 6 = 660 / 6 =  110\r\n```\r\n\r\n- 개발 기간 = 예측된 LOC / (개발자 수 X 1인달 월 평균 생산 LOC)\r\n\r\nLOC 기법에 의해 예측된 총 라인 수가 36,000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간은 아래와 같다.\r\n\r\n```\r\n개발 기간 = 36,000 / (6 X 300)\r\n         = 36,000 / 1,800\r\n        = 20[개월]\r\n```\r\n\r\n# 프레임워크\r\n\r\n### 소프트웨어 프레임워크(Framework)의 개념\r\n\r\n- 비슷한 유형의 응용 프로그램들을 위해 재사용이 가능한 아키텍처와 협력하는 소프트웨어 산출물의 통합된 집합이다.\r\n- 특정 클래스의 재사용뿐만 아니라 응용 프로그램을 위한 핵심 아키텍처를 제공하여 설계의 재사용을 지원한다.\r\n\r\n### 소프트웨어 개발 프레임워크의 개념\r\n\r\n- 소프트웨어 개발을 도와주는 재사용이 가능한 클래스와 패턴의 집합이다.\r\n- 소프트웨어 개발의 효율성을 높이고 소프트웨어 품질을 높이기 위한 반제품 성격의 소프트웨어이다.\r\n- 소프트웨어의 틀과 구조를 결정하고, 이를 바탕으로 개발된 개발자의 코드를 제어한다.\r\n\r\n#### 소프트웨어 개발 프레임워크 적용 시 이점\r\n\r\n- 개발 용이성\r\n  - 공통 기능은 프레임워크가 제공한다.\r\n  - 패턴 기반 개발과 비즈니스 로직에만 집중한 개발이 가능하다.\r\n- 시스템 복잡도 감소\r\n  - 시스템의 복잡한 기술은 프레임워크에 의해 숨겨진다.\r\n  - 미리 잘 정의된 기술 셋을 적용할 수 있다.\r\n- 이식성\r\n  - 플랫폼 연동을 프레임워크가 제공한다.\r\n  - 플랫폼의 독립적인 개발이 가능하다.\r\n- 품질 보증\r\n  - 검증된 개발 기술과 패턴에 따른 개발이 가능하다.\r\n  - 개발자의 경험과 능력 차이를 줄여준다.\r\n- 운영 용이성\r\n  - 소프트웨어 변경이 용이하다.\r\n  - 비즈니스 로직 및 아키텍처 파악이 용이하다.\r\n- 개발 코드 최소화\r\n  - 공통 컴포넌트와 서비스를 활용한다.\r\n  - 반복적인 코드 개발을 최소화한다.\r\n- 변경 용이성\r\n  - 잘 구조화된 아키텍처를 적용한다.\r\n  - 플랫폼에 독립적이다.\r\n- 설계 및 코드의 재사용성\r\n  - 프레임워크의 서비스와 패턴을 재사용한다.\r\n  - 이미 개발된 컴포넌트를 재사용한다.\r\n\r\n### 스프링 프레임워크(Spring Framework)\r\n\r\n- 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크이다.\r\n- 동적인 웹 사이트 개발을 위해 여러 가지 서비스를 제공하고 있다.\r\n- 전자정부 표준 프레임워크 기반 기술로 사용된다.\r\n- 스프링 프레임워크의 주요 모듈\r\n  - 제어 반전 컨테이너\r\n  - 관점 지향 프로그래밍 프레임워크\r\n  - 데이터 액세스 프레임워크\r\n  - 트랜잭션 관리 프레임워크\r\n  - 모델 - 뷰 - 컨트롤러(MVC) 패턴\r\n  - 배치 프레임워크\r\n\r\n### 전자정부 표준 프레임워크\r\n\r\n- 공공부문 정보화 사업 시 플랫폼별 표준화된 개발 프레임워크를 말한다.\r\n- 공공기관의 웹 서비스 개발 시 사용을 권장하고 있다.\r\n- 전자정보 표준 프레임워크 적용 시 기대효과\r\n  - 전자정부 서비스 품질 향상\r\n  - 정보화 투자 효율성 향상\r\n  - 국가 정보화 투자 효율성 재고\r\n  - 중소 SI 업체 경쟁력 확보\r\n  - 선진 국가정보화 추진 기반 환경 재고\r\n\r\n### 닷넷 프레임워크(.NET Framework)\r\n\r\n- Microsoft사에서 개발한 윈도우 프로그램 개발 및 실행 환경이다.\r\n- 네트워크 작업, 인터페이스 등의 많은 작업을 캡슐화하였고, 공통 언어 런타임(CLR : Common Language Runtime) 가상 머신 위에서 작동한다.\r\n- 오픈소스 버전으로 닷넷 코어가 있다.\r\n\r\n# 네트워크 구성\r\n\r\n### 성형(Star Topology)\r\n\r\n- 중앙에 호스트 컴퓨터(Host Computer)가 있고 이를 중심으로 터미널(Terminal)들이 연결되는 중앙 집중식의 네트워크 구성 형태이다.\r\n- 중앙 컴퓨터와 직접 연결되어 응답이 빠르고 통신 비용이 적게 소요되지만, 중앙 컴퓨터에 장애가 발생하면 전체 시스템이 마비되는 분산 시스템의 위상 구조이다.\r\n\r\n```\r\n            단말기\r\n    단말기 \\   |   / 단말기\r\n            중계기\r\n    단말기 /   |   \\ 단말기\r\n            단말기\r\n\r\n```\r\n\r\n### 링형(Ring Topology)\r\n\r\n- 서로 이웃한 컴퓨터와 노드끼리 연결한 네트워크 구성 형태이다.\r\n- 각 노드가 공평한 서비스를 받으며, 전송 매체와 노드의 고장 발견이 쉽다.\r\n- 데이터가 한 방향으로 전송되기 떄문에 충돌(Collision) 위험이 없다.\r\n\r\n```\r\n        단말기 ↘\r\n      ↗        단말기\r\n단말기          ↙\r\n      ↖단말기\r\n```\r\n\r\n### 버스형(Bus Topology)\r\n\r\n- 한 개의 통신 회선에 여러 개의 노드가 연결된 형태이다.\r\n- 한 사이트의 고장은 나머지 사이트 간의 통신에 아무런 영향을 주지 않는다.\r\n- 네트워크 트래픽이 많을 경우 네트워크 효율이 떨어진다.\r\n\r\n```\r\n단말기  단말기  단말기  단말기\r\n   |      |      |       |\r\nㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ\r\n```\r\n\r\n### 트리형(Tree Topology)\r\n\r\n- 하나의 노드에 여러 개의 노드를 연결한 네트워크 구성 형태로 네트워크 관리가 용이하다.\r\n- 각 노트가 계층적으로 구성되어 있어 계층형 또는 분산형이라고도 한다.\r\n\r\n```\r\n          단말기\r\n        /       \\\r\n   단말기         단말기\r\n  /      \\      /       \\\r\n단말기  단말기  단말기  단말기\r\n```\r\n\r\n### 망형(Mesh Topology)\r\n\r\n- 모든 컴퓨터와 노드들이 서로 연결된 네트워크 구성 형태로 그물형이라고도 한다.\r\n- 응답 시간이 빠르고 노드의 연결성이 우수하다.\r\n- 일반적으로 많은 단말기로부터 많은 양의 통신을 필요로 하는 경우에 유리하다.\r\n- n 개의 노드를 망형으로 구성 시 n(n-1)/2 개의 회선이 필요하다.\r\n\r\n```\r\n       단말기\r\n      /  |   \\\r\n단말기 ㅡ + ㅡ 단말기\r\n      \\  |  /\r\n       단말기\r\n```\r\n\r\n### 브릿지(Bridge)\r\n\r\n- 데이터 링크 계층(Data Link Layer)에서 동작하며 같은 MAC(Midea Access Control) 프로토콜을 사용하는 근거리 통신망 사이를 연결하는 통신 장치이다.\r\n\r\n### 스위치(Switch)\r\n\r\n- 브릿지와 같이 두 개 이상의 LAN을 연결하여 하나의 네트워크로 만드는 장치이다.\r\n- 보안 및 트래픽 관리 기능도 제공할 수 있다.\r\n- 스위치 분류\r\n  - L2 스위치\r\n    - OSI 2계층에 속하는 네트워크 장비\r\n    - 가장 기본적인 스위치로, 단순히 스위치라고도 한다.\r\n    - Adress Learning, Filtering, Forwarding 등의 기능을 수행한다.\r\n  - L3 스위치\r\n    - OSI 3계층에 속하는 네트워크 장비\r\n    - L2 스위치에 라우팅 기능이 추가되었다.\r\n    - 서로 다른 네트워크를 연결할 수 있다.\r\n  - L4 스위치\r\n    - OSI 4계층에 속하는 네트워크 장비\r\n    - L3 스위치에 로드밸런서(Load Balancer)가 추가되었다.\r\n  - L7 스위치\r\n    - OSI 7계층에 속하는 네트워크 장비이다.\r\n    - 세밀한 로드밸런싱이 가능하다.\r\n    - 보안 기능을 대폭 강화하였다.\r\n\r\n### 라우터(Router)\r\n\r\n- 네트워크 계층(Network Layer)에서 동작하며 동일 전송 프로토콜을 사용하는 분리된 2개 이상의 네트워크를 연결해주는 통신 장치이다.\r\n- 네트워크상에서 가장 최적의 IP 경로를 설정하여 전송하는 장비이다.\r\n\r\n### 게이트웨이(Gateway)\r\n\r\n- 서로 다른 통신 프로토콜을 사용하는 네트워크 사이를 연결하여 데이터를 교환할 수 있도록 하는 역할을 한다.\r\n- 두 개의 서로 다른 형태의 네트워크를 상호 연결시켜 주는 관문 역할을 하는 장치이다.\r\n- 필요한 경우 프로토콜 변환을 수행한다.\r\n\r\n### VLAN(Virtual Local Area Network)\r\n\r\n- 물리적 배치와 상관없이 논리적으로 LAN을 구성하여 Broadcast Domain을 구분할 수 있게 해주는 기술로 접속된 장비들의 성능 향상 및 보안성 증대 효과를 목표로 한다.\r\n\r\n# 네트워크 관련 신기술 ★★★\r\n\r\n### RIP(Routing Information Protocol)\r\n\r\n- 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜이다.\r\n- 최적의 경로를 산출하기 위한 정보로서 홉(거릿값)만을 고려하므로, RIP를 선택한 경로가 최적의 경로가 아닌 경우가 많이 발생할 수 있다.\r\n- 최대 홉 카운트를 15홉 이하로 한정한다.\r\n- 소규모 네트워크 환경에 적합하다.\r\n\r\n### OSPF(Open Shortest Path First)\r\n\r\n- 대표적인 링크 상태(Link State) 라우팅 프로토콜로, IP 패킷에서 89번 프로토콜을 사용하여 라우팅 정보를 전송하며 안정되고 다양한 기능으로 가장 많이 사용되는 것은 IGP(Interior Gateway Protocol)이다.\r\n\r\n### MATT(Message Queuing Telemetry Transport)\r\n\r\n- IBM이 주도하여 개발한 기술로 사물 인터넷과 같이 대역폭이 제한된 통신 환경에 최적화하여 개발된 푸시 기술 기반의 경량 메시지 전송 프로토콜이다.\r\n- TCP/IP 기반 네트워크에서 동작하는 발생-구독 기반의 메시징 프로토콜로 최근 IoT 환경에서 자주 사용되고 있는 프로토콜이다.\r\n\r\n### 사물 인터넷(IoT : Internet of Things)\r\n\r\n- 인터넷에 연결된 기기가 사람의 개입 업이 상호 간에 알아서 정보를 주고받아 처리한다.\r\n- 사물은 물론이고 현실과 가상세계의 모든 정보와 상호 작용하는 개념이다.\r\n\r\n### WSN(Wireless Sensor Network)\r\n\r\n- 센서를 네트워크로 구성한 것이다.\r\n- 사물에 부착된 센서를 통해 탐지된 사물의 인식 정보는 물론 주변의 온도, 습도와 같은 환경 정보를 실시간으로 네트워크와 연결하여 수집하고 관리하는 네트워크 시스템이다.\r\n\r\n### 클라우드 컴퓨팅(Cloud Computing)\r\n\r\n- 사용자가 인터넷 등을 통해 하드웨어, 소프트웨워 등의 컴퓨팅 자원을 원격으로 필요한 만큼 빌려서 사용하는 방식의 서비스 기술로서 서비스 모델은 IaaS, PaaS, SaaS로 구분한다.\r\n- 가상화 기술, 서비스 프로비저닝(Provisioning) 기술, 과금 체계 등을 필요로 한다.\r\n- PaaS-TA : 국내 IT 서비스 경쟁력 강화를 목표로 개발, 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼이다.\r\n\r\n### 그리드 컴퓨팅(Grid Computing)\r\n\r\n- 인터넷상에서 사용하지 않는 시간대의 연결된 수많은 컴퓨터를 하나의 고성능 컴퓨터처럼 활용할 수 있는 기술이다.\r\n\r\n### RFID(Radio Frequency IDentification)\r\n\r\n- 전자 태그가 부착된 IC 칩과 무선 통신 기술을 이용하여 다양한 개체들의 정보를 관리할 수 있는 센서 기술이다.\r\n\r\n### NFC(Near Field Communication)\r\n\r\n- RFID 기술 중 하나로, 10cm 정도로 가까운 거리에서 장치 간에 양방향 무선 통신을 가능하게 해주는 기술이다. 13.56MHz의 주파수 대역을 사용하는 비접촉식 통신 기술이다.\r\n- 데이터 읽기와 쓰기 기능을 모두 사용할 수 있다.\r\n\r\n### WPAN(Wireless Personal Area Network)\r\n\r\n- 사용자를 줒심으로 작은 지역에서 주로 블루투스 헤드셋, 스마트 워치 등과 같은 개인화 장치들을 연결시키는 무선 통신 규격이다.\r\n- IEEE 802.15 규격의 범주에 속한다.\r\n\r\n### PICONET(피코넷)\r\n\r\n- 여러 개의 독립된 통신 장치가 UWB(Ultra Widebacn) 기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술이다.\r\n\r\n### 스마트 그리드(Smart Grid)\r\n\r\n- 전기 및 정보통신 기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력 서비스를 제공하고 에너지 이용 효율을 극대화하는 전력망 시스템이다.\r\n- 기존의 전력망에 정보 기술을 접목하여 전력 공급자와 소비자가 쌍방향으로 실시간 정보를 교환함으로써 에너지 효율을 최적화하고 새로운 부가가치를 창줄한다.\r\n\r\n### 비콘(Beacon)\r\n\r\n- 블루투스 4.0(BLE) 프로토콜 기반의 근거리 무선 통신 장치로 최대 70m 이내의 장치들과 교신할 수 있는 차세대 스마트폰 근거리 통신 기술이다.\r\n- 저전력으로 모방리 결제 등을 가능하게 해주는 스마트폰 근거리 통신 기술이다.\r\n- NFC보다 가용거리가 길고 5~10cm 단위 구별이 가능해 정확성이 높다.\r\n\r\n### 포스퀘어(Foursquare)\r\n\r\n- 스마트폰에 탑재된 GPS를 활용해 위치 정보를 수집한다.\r\n- 쇼핑 관광 등에 활용하는 위치 기반 소셜 네트워크 서비스이다.\r\n\r\n### ZigBee\r\n\r\n- IEEE 802.15.4 기반 PAN 기술이다.\r\n- 낮은 전력을 소모하면서 저가의 센서 네트워크 구현에 최적의 방안을 제공한다.\r\n- 빌딩 자동화나 홈 보안 시스템 등의 자동화에 적절한 통신 기술이다.\r\n\r\n### Mesh Network\r\n\r\n- 기존 무선 랜의 한계 극복을 위해 등장하였다.\r\n- 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신 홈네트워킹, 공공 안전 등의 특수 목적을 위한 새로운 방식의 네트워크 기술이다.\r\n\r\n### Wavelength Division Multiplexing(WDM, 파장 분할 다중화)\r\n\r\n- 레이저 빛이 다른 파장(다른 색)을 사용하여 여러 반송파 신호를 단일 광섬유에 적용하는 기술이다.\r\n- 파장이 서로 다른 복수의 광신호를 동시에 이용하는 것으로 광섬유를 다중화하는 방식이다.\r\n- 빛의 파장 축과 파장이 다른 광선은 서로 간섭을 일으키지 않는 성질을 이용한다.\r\n\r\n# 소프트웨어 관련 신기술\r\n\r\n### 소프트웨어 정의 데이터 센터(SDDC : Software Defined Data Center)\r\n\r\n- 가상 데이터 센터(Virtual Data Center : VDC)라고도 하며, 추상화, 풀링(Pooling), 자동화 등을 통해 인프라를 가상화하는 데이터 센터를 의미한다.\r\n- 컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의한다.\r\n- 인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리한다.\r\n- 데이터 센터 내 모든 자원을 가상화하여 서비스한다.\r\n\r\n### 텐서플로우(TensorFlow)\r\n\r\n- 구글에서 개발해서 공개한 인공지능 응용 프로그램 개발용 오픈소스 프레임워크이다.\r\n- 텐서플로우를 사용할 때 인공지능 소프트웨어가 이미지 및 음성을 인식하기 위해서는 신경망의 합성곱 신경망 모델을 주로 사용한다.\r\n\r\n### 머신 러닝(Machine Learning)\r\n\r\n- 컴퓨터 프로그램이 데이터와 처리 경험을 이용한 학습을 통해 정보 처리 능력을 향상시키는 기술로 컴퓨터에게 많은 데이터를 주고 거기에서 일반적인 패턴을 찾아내게 한다.\r\n- 자율 주행 자동차, 필기체 문자 인식 등과 같이 알고리즘 개발이 어려운 문제의 해결에 유용하다.\r\n\r\n### 딥 러닝(Deep Learning)\r\n\r\n- 일반적인 머신 러닝 모델보다 더 싶은 신경망 계층 구조를 이용하는 머신 러닝이다.\r\n- 주로 여러 개의 은닉층(Hidden Layer)으로 구성된 인공 신경망을 활용한다.\r\n\r\n### 디지털 트윈(Digital Twin)\r\n\r\n- 물리적인 사물과 컴퓨터에 동일하게 표현되는 가상 모델이다.\r\n- 실제 물리적인 자산 대신 소프트웨어로 가상화한 자산의 디지털 트윈을 만들어 시뮬레이션함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있다.\r\n\r\n### HMD(Head Mounted Display)\r\n\r\n- 머리에 착용하는 형태의 디스플레이로 HMD 장치를 머리에 쓰면 양쪽 눈에 근접한 위치에 소형 디스플레이가 있어 시차를 이용한 3D 영상이 투영된다.\r\n\r\n### 블록체인(Blockchain)\r\n\r\n- 공공 거래 장부로, 가상 화폐로 거래할 때 발생할 수 있는 해킹을 막는 기술이다.\r\n- 하나의 블록은 트랜잭션의 집합과 헤더(Header)로 이루어져 있고 한 블록에는 앞의 블록에 대한 정보가 포함되어 있어, 앞 블록의 내용을 변경하면 뒤에 이어지는 블록도 변경해야 한다.\r\n\r\n### BaaS(Backend as a Service)\r\n\r\n- 블록체인(Blockchain) 개발 환경을 클라우드로 서비스하는 개념으로 블록체인 네트워크에 노드의 추가 및 제거가 용이하다.\r\n- 블록체인의 기본 인프라를 추상화하여 블록체인 응용 프로그램을 만들 수 있는 클라우드 컴퓨팅 플랫폼이다.\r\n\r\n### 분산 원장 기술(Distributed Ledger Technology)\r\n\r\n- 분산 네트워크 참여자가 암호화 기술을 사용하여 거래 정보를 검증하고 합의한 원장(Ledger)을 공동으로 분산/관리하는 기술이다.\r\n- 수많은 사적 거래 정보를 개별적 데이터 블록으로 만들고, 이를 체인처럼 연결하는 블록체인 기술이다.\r\n\r\n### 증강현실(AR : Augmented Reality)\r\n\r\n- 현실을 기반으로 가상 정보를 실시간으로 결합하여 보여주는 기술이다.\r\n- 예를 들어 스마트폰 카메라로 주변을 비추면 인근에 있는 상첨의 위치, 전화번호 등의 정보가 입체 영상으로 표시된다.\r\n\r\n### 매시업(Meshup)\r\n\r\n- 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술이다.\r\n- 다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공한다.\r\n- 구글 지도에 부동산 매물 정보를 결합한 구글의 하우징 맵스(HousingMaps)가 대표적이다.\r\n\r\n### 양자 암호(Quantum Cryptography)\r\n\r\n- 양자 역학의 특성을 이용하여 안전하게 정보를 보호하기 위한 알고리즘 또는 정보 이론적/수학적 방법론이다.\r\n- 양자 컴퓨터가 등장하면서 기존의 대칭키 암호 기법과 비대칭키 암호 기법은 안전성을 보장할 수 없게 되었다.\r\n- 대표적인 양자 암호 기법으로 양자 암호키 분배(QKD : Quntum Key Distribution) 기법이다.\r\n\r\n# 하드웨어 관련 신기술\r\n\r\n### 양자 컴퓨터(Quantum Computer)\r\n\r\n- 양자 역학적 현상을 이용하여 연산을 수행하는 컴퓨터이다.\r\n- 양자 정보의 최소 단위인 큐비트(Qubit)의 상태를 제어하여 연산과 양자 알고리즘을 수행한다.\r\n\r\n### 4D 프린팅\r\n\r\n- 미리 설계된 시간이나 임의환경 조건이 충족되면 스스로 모양을 변경 또는 제조하여 새로운 형태로 바뀌는 제품을 3D 프린팅하는 기술이다.\r\n- 온도, 습도, 진동 등 에너지에서 자극을 받으면 모양이 변하는 스마트 소재가 사용된다.\r\n\r\n### N-Screen\r\n\r\n- 동일한 콘텐츠를 PC, 스마트TV, 스마트폰, 태블릿 PC 등 다양한 디지털 정보기기에서 자유롭게 이용할 수 있는 서비스이다.\r\n\r\n# 데이터베이스 관련 기술 용어\r\n\r\n### RAID(Redundant Array of Indexpensive Disks)\r\n\r\n- 데이터를 복수 또는 분할 저장하여 병렬로 데이터를 읽는 보조 기억 장치 또는 그 방법으로 디스크의 고장에 대비하여 데이터의 안정성을 높이는 기술이다.\r\n- 한 개의 데이터를 여러 디스크에 저장하여 데이터 안정성을 향상시키기 위해 사용한다.\r\n- 다수의 디스크에 데이터를 분할하여 전송함으로써 전체적인 데이터 전송 속도 향상을 위해 사용한다.\r\n- RAID 1 : 디스크 스트라이핑(Disk Striping) 방식으로 중복 저장과 오류 검출 및 교정이 없다.\r\n- RAID 2 : 비트 단위로 분산 저장하고 여러 개의 해밍코드 검사 디스크를 사용한다. 디스크 미러링(Disk Mirroring) 방식으로 높은 신뢰도를 갖는다.\r\n- RAID 3 : 데이터를 다수의 디스크에 스트라이핑하여 저장하며, 하나의 드라이브에 패리티를 저장한다. 패리티 드라이브를 사용한다.\r\n- RAID 4 : 각 디스크에 데이터를 블록 단위로 분산 저장하고 하나의 패리티 검사 디스크를 사용한다.(블록 인터리브된 패리티(Block-Interleaved Striping with Parity)).\r\n- RAID 5 : 별도의 패리티 디스크 대신 모든 디스크에 패리티 정보를 나누어 기록하는 방식으로 3개 이상의 디스크 어레이를 요구하며 쓰기 작업이 많지 않은 다중 시스템에 적합하다.\r\n\r\n### 웨어러블 컴퓨팅(Wearable Computing)\r\n\r\n- 컴퓨터를 옷이나 안경처럼 착용할 수 있게 해주는 기술이다.\r\n- 소형화, 경량화를 비롯해 음성과 동작 인식 등 다양한 기술이 적용되어 장소에 구애받지 않고 컴퓨터를 활용할 수 있다.\r\n\r\n### 멤리스터(Memristor)\r\n\r\n- 메모리와 레지스터의 합성어로, 전류의 방향과 크기 등 기준의 상태를 모두 기억하는 소자이다.\r\n- 레지스터, 커패시터, 인덕터에 이어 네 번째 전자회로 구성 요소로 차세대 기억 소자, 회로 등에 응용될 수 있다. 에너지 소모와 부팅 시간을 획기적으로 줄일 수 있다.\r\n\r\n### 직접 연결 저장 장치(DAS : Direct-Attached Storage)\r\n\r\n- 하드디스크와 같은 데이터 저장 장치를 호스트 버스 어댑터에 직접 연결하는 방식이다.\r\n- 저장 장치와 호스트 기기 사이에 네트워크 디바이스가 있지 말아야 한다.\r\n\r\n### SAN(Storage Area Network)\r\n\r\n- 네트워크상에 광 채널 스위치의 이점인 고속 전송과 장거리 연결 및 멀티 프로토콜 기능을 활용하여 각기 다른 운영체제를 가진 여러 기종이 네트워크상에서 동일 저장 장치의 데이터를 공유하게 함으로써, 여러 개의 저장 장치나 백업 작비를 단일화시킨 시스템이다.\r\n\r\n### NAS(Network Attached Storage)\r\n\r\n- 컴퓨터에 직접 연결하지 않고 네트워크를 통해 데이터를 주고받는 저장 장치이다.\r\n- 구조적으로는 스토리지 서버를 단순화, 소형화한 것이다.\r\n\r\n### Software Defined Storage\r\n\r\n- 가상화를 적용하여 필요한 공간만큼 나눠 사용할 수 있도록 하며, 서버 가상화와 유사하다.\r\n- 컴퓨팅 소프트웨어로 규정하는 데이터 스토리지 체계이며, 일정 조직 내 여러 스토리지를 하나처럼 관리하고 운용하는 컴퓨터 이용 환경으로 스토리지 자원을 효율적으로 나누어 쓰는 방법이다.\r\n\r\n### 데이터웨어하우스(Data Warehouse)\r\n\r\n- 기간 업무 시스템에서 추출되어 새로이 생성된 데이터베이스로서 의사결정지원시스템을 지원하는 주제적, 통합적, 시간적 데이터의 집합체이다.\r\n- 통합된 데이터에 대한 OLAP(On-Line Analytical Processing) 연산을 효율적으로 지원할 수 있다.\r\n\r\n### 데이터 마트(Data Mart)\r\n\r\n- 데이터웨어하우스와 사용자 사이의 중간층에 위치하며 데이터웨어하우스보다 규모나 비용 측면에서 축소된 개념이다.\r\n\r\n### 빅데이터(Big Data)\r\n\r\n- 많은 양의 정형 또는 비정형 데이터들로부터 가치를 추출하고 결과를 분석하는 기술이다.\r\n- 빅데이터의 특성은 Volume(규모), Velocity(속도), Variety(다양성)이다.\r\n- 구글 및 페이스북, 아마존의 경우 이용자의 성향과 검색 패턴, 구매패턴을 분석해 맞춤형 광고를 제공하는 등 빅데이터의 활용을 증대시키고 있다.\r\n\r\n### 데이터마이닝(Data Mining)\r\n\r\n- 대량의 데이터를 분석하여 데이터 속에 있는 변수 사이의 상호관계를 규명하여 일정한 패턴을 찾아내는 기법이다.\r\n- 데이터웨어하우징에서 수집되고 분석된 자료를 사용자에게 제공하기 위해 분류 및 가공되는 요소 기술이다.\r\n\r\n### 디지털 아카이빙(Digital Archiving)\r\n\r\n- 디지털 정보 자원을 장기적으로 보존하기 위한 작업이다.\r\n- 아날로그 콘텐츠는 디지털로 변환해 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화하는 작업이다.\r\n\r\n### 하둡(Hadoop)\r\n\r\n- 오픈소스를 기반으로 한 분산 컴퓨팅 플랫폼으로 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고, 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 빅데이터 분산 처리를 돕는 자바 소프트웨어 오픈소스 프레임워크이다.\r\n- 다양한 소스를 통해 생성된 빅데이터를 효율적으로 저장하고 처리한다.\r\n- 하둡의 필수 핵심 구성 요소는 맵리듀스와 하둡 분산 파일 시스템이다.\r\n- Sqoop : 하둡과 관계형 데이터베이스 간에 데이터를 전송할 수 있도록 설계된 도구이다.\r\n\r\n### 맵리듀스(MapReduce)\r\n\r\n- Hadoop의 핵심 구성 요소로서 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델이다.\r\n- Google에 의해 고안된 기술로써 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법을 제공한다.\r\n- 임의의 순서로 정렬된 데이터를 분산 처리하고 이를 다시 합치는 과정을 거친다.\r\n\r\n# 정보 보안의 3대 요소 ★★★\r\n\r\n- 기밀성(Confidentiality)\r\n  - 인가된 사용자만 정보 자산에 접근할 수 있다.\r\n  - 일반적인 보안의 의미와 가장 가깝다.\r\n  - 방화벽, 암호 패스워드 등이 대표적인 예이다.\r\n  - 신분 위장(Masquerading) 등과 같은 공격에 의해 위협받을 수 있다.\r\n- 무결성(Integrity)\r\n  - 시스템 내의 정보는 오직 인가된 사용자가 인가된 방법으로만 수정할 수 있다.\r\n  - 변경, 가장, 재전송 등과 같은 공격에 의해 위협받을 수 있다.\r\n- 가용성(Availability)\r\n  - 사용자가 필요할 때 데이터에 접근할 수 있는 능력을 말한다.\r\n  - 인가된 사용자가 조직의 정보 자산에 적시에 접근하여 업무를 수행할 수 있도록 유지하는 것을 목표로 한다.\r\n  - 가용성을 유지하기 위해 데이터 백업, 위협 요소 제거 등의 기술을 사용할 수 있다.\r\n  - 서비스 거부(Denial of Service) 등과 같은 공격에 의해 위협받을 수 있다.\r\n\r\n## 보안 약점의 종류\r\n\r\n- SQL Injection\r\n  - 검증되지 않은 외부 입력값이 SQL 쿼리문에 삽입되어 공격할 수 있는 보안 약점이다.\r\n  - DB에 컴파일된 SQL 쿼리문을 전달함으로써 방지할 수 있다.\r\n  - SQL Injection 취약점이 발생하는 곳을 주로 웹 애플리케이션과 데이터베이스가 연동되는 부분이다.\r\n  - 로그인과 같이 웹에서 사용자의 입력값을 받아 데이터베이스 SQL문으로 데이터를 요청하는 경우 SQL Injection을 수행할 수 있다.\r\n- 경로 조작 및 자원 삽입\r\n  - 검증되지 않은 외부 입력값이 시스템 자원 접근 경로를 조작하거나 시스템 자원에 삽입되어 공격할 수 있는 보안 약점이다.\r\n- 크로스 사이트 스크립트(XSS, Cross Site Scripting)\r\n  - 게시판의 글에 원본과 함께 악성 코드를 삽입하여 글을 읽으면 악성코드가 실행되도록 하여 클라이언트의 정보를 유출하는 공격 방법이다.\r\n  - 웹페이지에 악의적인 스크립트를 포함시켜 사용자 측에서 실행되게 유도함으로써, 정보 유출 등의 공격을 유발할 수 있는 취약점이다.\r\n  - 외부 입력값에 스크립트가 삽입되지 못하도록 문자열 치환 함수를 사용하거나 JSTL이나 크로스사이트 스크립트 방지 라이브러리를 사용함으로써 방지할 수 있다.\r\n- XQuery 삽입\r\n  - XQuery를 사용하여 XML 데이터에 대한 동적 쿼리 생성 시 검증되지 않은 외부 입력값이 쿼리문 구조 변경에 사용될 수 있는 보안 약점이다.\r\n  - XQuery에 사용되는 외부 입력값에 대하여 특수문자 및 쿼리 예약어 필터링을 통해 방지할 수 있다.\r\n- XPath 삽입\r\n  - 검증되지 않은 외부 입력값으로 XPath 쿼리문을 생성하여 쿼리문의 의미나 구조가 변경될 수 있는 보안 약점이다.\r\n- LDAP 삽입\r\n  - 외부 입력값이 올바르게 처리되지 못하여 LDAP(Lightweight Directory Access Protocol) 쿼리문의 구성 변경에 사용될 수 있는 보안 약점이다.\r\n  - DN(Distinguished Name)과 필터에 사용되는 외부 입력값에 특수문자를 제거함으로써 방지할 수 있다.\r\n\r\n# 암호화 알고리즘\r\n\r\n- 평문을 암호문으로 바꾸고, 암호문을 다시 평문으로 바꿀 때 사용되는 알고리즘을 의미한다.\r\n- 평문을 암호문으로 바꾸는 과정을 암호화(Encryption)라고 하고, 암호문을 다시 평문으로 바꾸는 과정을 복호화(Decryption)라고 한다.\r\n- 암호화 및 복호화 과정에 암호키(Cryptographic key)가 필요하다.\r\n\r\n### 암호 방식의 분류\r\n\r\n- 암호화 방식\r\n  - 단방향\r\n    - 해시\r\n  - 양방향\r\n    - 비밀키\r\n      - 스트림 방식\r\n      - 블록 방식\r\n    - 공개 키\r\n\r\n### 공개키(Public Key, 비대칭키) 암호화 기법\r\n\r\n- 암호키와 해독키가 서로 다른 기법으로 키 개수는 2N개가 필요하다.\r\n- 비대칭키 암호화 기법 또는 공중키 암호화 기법이라고도 한다.\r\n- 키 분배가 비밀키 암호화 기법보다 쉽고, 암호화/복호화 속도가 느리며 알고리즘이 복잡하다.\r\n- RSA, ElGama 기법 등이 있다.\r\n  - RSA(Rivest Shamir Adieman)\r\n    - 소인수 분해의 어려움에 기초를 둔 알고리즘\r\n    - 1978년 MIT에 의해 제안됨\r\n    - 전자문서에 대한 인증 및 부인 방지에 활용된다.\r\n  - ElGama\r\n    - 이산대수 문제의 어려움에 기초를 둔 알고리즘\r\n    - 동일한 메시지라도 암호화가 이루어질 때마다 암호문이 변경되고 암호문의 길이가 2개로 늘어나는 특징이 있다.\r\n\r\n### 비밀키(Private Key, 대칭키) 암호화 기법\r\n\r\n- 동일한 키로 암호화하고 복호화하는 기법으로 키 개수는 N(N-1)/2 개가 필요하다.\r\n- 대칭키 암호화 기법 또는 개인키 암호화 기법이라고도 한다.\r\n- 암호화/복호화 속도가 빠르고 알고리즘이 단순하다.\r\n- 키 분배가 공개키 암호화 기법보다 어렵다.\r\n- 스트림 방식과 블록 방식으로 분류된다.\r\n  - 스트림 방식\r\n    - 평문의 길이와 동일한 스트림(Stream)을 생성하여 비트 단위로 암호화하는 대칭키 암호화 방식이다. 암호화할때 XOR 연산을 수행한다.\r\n    - 종류 : RC4, A5/1, LSFR, SEAL, WEP, OFB\r\n  - 블록 방식\r\n    - 평문을 블록 단위로 암호화하는 대칭키 암호화 방식이다.\r\n    - 종류\r\n      - DES(Data Encryption Standard)\r\n        - 1970년대 초 IBM이 개발한 알고리즘이다.\r\n        - 16라운드 Feistel 구조를 가진다.\r\n        - 평문을 64비트로 블록화를 하고, 실제 키의 길이는 56비트를 이용한다.\r\n        - 전사 공격(Brute-Force Attack)에 취약하다.\r\n      - AES(Advanced Encryption standard)\r\n        - DES를 대신하여 새로운 표준이 되었다.\r\n        - 블록 크기는 128비트이고, 키 길이는 128/192/256 비트이다.\r\n        - SPN(Substitution-Permutation Network) 구조이다.\r\n      - ARIA\r\n        - 국내 기술로 개발된 암호 알고리즘이다.\r\n        - 경량 환경 및 하드웨어 구현에서의 효율성 향상을 위해 개발되었다.\r\n        - 우리나라 국가 표준으로 지정되었다.\r\n        - 블록 크기와 키 길이가 AES와 동일하다.\r\n      - SEED\r\n        - 국내 기술로 개발된 128비트 블록 암호 알고리즘이다.\r\n        - Feistel 구조이다.\r\n        - 2005년 국제 표준으로 제정되었다.\r\n      - IDEA\r\n        - DES를 대체하기 위해서 스위스에서 개발한 알고리즘이다.\r\n        - 상이한 대수 그룹으로부터의 세 가지 연산을 혼합하는 방식이다.\r\n\r\n### 해시(HASH) 암호화 방식\r\n\r\n- 임의의 길이의 메시지를 입력으로 하여 고정된 길이의 출력값을 변환하는 시법이다.\r\n- 주어진 원문에서 고정된 길이의 의사난수를 생성하며, 생성된 값을 해시값이라고 한다.\r\n- 해시 함수라고도 한다.\r\n- 디지털 서명에 이용되어 데이터 무결성을 제공한다.\r\n- 블록체인에서 체인 형태로 사용되어 데이터의 신뢰성을 보장한다.\r\n- SHA, SHA1, SHA256, MD5, RMD160, HAS-160, HAVAL 기법 등이 있다.\r\n\r\n### SHA(Secure Hash Algorithm)\r\n\r\n- 1993년에 미국 NIST에 의해 개발되었고 가장 많이 사용되고 있는 방식이다.\r\n- SHA-1은 DSA에서 사용하게 되어 있으며 많은 인터넷 응용에서 Default 해시 알고리즘으로 사용된다.\r\n- SHA-256, SHA-384, SHA-512는 AES의 키 길이인 128, 192, 256bit에 대응하도록 출력 길이를 늘린 해시 알고리즘이다.\r\n\r\n### SALT\r\n\r\n- 시스템에 저장되는 패스워드들은 Hash 또는 암호화 알고리즘의 결과값으로 저장된다. 이때 암호 공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값을 의미한다.\r\n\r\n# 서비스 공격 유형\r\n\r\n### Dos(Denial of Service, 서비스 거부)\r\n\r\n- 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격 방법이다.\r\n- 정보보호의 3대 목표 중 가용성(Availability)을 위협하는 행위로서 공격자가 임의로 자신의 IP 주소를 속여서 다량으로 서버에 보낸다.\r\n- 헤더가 조작된 일련의 IP 패킷 조각들을 전송한다.\r\n- 라우터, 웹, 전자 우편, DNS 서버 등 모든 네트워크 장비를 대상으로 이루어질 수 있다.\r\n\r\n### DDOS(Distributed Denial of Service, 분산 서비스 거부)\r\n\r\n- 여러 대의 공격자를 분산 배치하여 동시에 서비스 거부 공격함으로써 공격 대상이 되는 시스템이 정상적인 서비스를 할 수 없도록 방해하는 공격 방법이다.\r\n- 공격용 도구 : Trinoo, TFN(Tribe Flood Network), TFN2K, Stacheldraht 등이 있다.\r\n\r\n### ETC ...\r\n\r\n# 보안 솔루션\r\n\r\n### IDS(Intrusion Detection System, 침입 탐지 시스템)\r\n\r\n- 침입 공격에 대하여 탐지하는 것을 목표로 하는 보안 솔루션이다.\r\n- 외부 침입에 대한 정보를 수집하고 분석하여 침입 활동을 탐지해 이에 대응하도록 보안 담당자에게 통보하는 기능을 수행하는 네트워크 보안 시스템이다.\r\n- 예방적이고 사전에 조처를 하는 기술로서 HIDS와 NIDS로 구분한다.\r\n\r\n### 방화벽(Firewall)\r\n\r\n- 내부-외부 네트워크 사이에 위치하여, 보안 정책을 만족하는 트래픽만 통과할 수 있다.\r\n- 방화벽이 제공하는 기능에는 접근 제어, 인증, 감사 추적, 암호화 등이 있다.\r\n- 불법 사용자의 침입 차단을 위한 정책과 이를 지원하는 하드웨어 및 소프트웨어를 제공한다.\r\n- 방화벽 하드웨어 및 소프트웨어 자체의 결함에 의해 보안상 취약점을 가질 수 있다.\r\n- 내부 네트워크에서 외부 네트워크로 나가는 패킷을 그대로 통과시키므로 내부 사용자에 의한 보안 침해는 방어하지 못한다.\r\n\r\n## 정보보호 대책\r\n\r\n### IPS(Intrusion Prevention System, 침입 방지 시스템)\r\n\r\n- 사후에 조치를 취하는 기술로서 침입 공격에 대하여 방지하는 것을 목표로 하는 보안 솔루션이다.\r\n- IDS와 방화벽의 장점을 결합한 네트워크 보안 시스템이다.\r\n- 호스트의 IP 주소, 포트 번호, 사용자 인증에 기반을 두고 외부 침입을 차단한다.\r\n- 허용되지 않는 사용자나 서비스에 대해 사용을 거부하여 내부 자원을 보호한다.\r\n\r\n### DMZ(DeMilitarized Zone, 비무장지대)\r\n\r\n- DMZ는 보안 조치가 취해진 네트워크 영역이다.\r\n- 메모리, 네트워크 연결, 접근 포인트 등과 같은 자원에 대한 접근을 제한하기 위한 구축된다.\r\n- 내부 방화벽과 외부 방화벽 사이에 위치할 수 있다.\r\n- 웹 서버, DNS 서버, 메일 서버 등이 위치할 수 있다.\r\n\r\n### IPSec(IP security)\r\n\r\n- 통신 세션의 각 IP 패킷을 암호화하고 인증하는 안전한 인터넷 프로토콜(IP)이다.\r\n- ESP(Encapsulation Security Payload)는 발신지 인증, 데이터 무결성, 기밀성 모두를 보장한다.\r\n- 운영 보드는 Tunnel 모드와 Transport 모드로 분류된다.\r\n- AH(Authentication Header)는 발신지 호스트를 인증하고, IP 패킷의 무결성을 보장한다.\r\n\r\n### DLP(Data Loss Prevention)\r\n\r\n- 기업 데이터 유출을 방지하는 것을 목표로 하는 보안 솔루션이다.\r\n- 사용자의 PC에서 기업 내 기밀 데이터가 외부로 반출되는 것을 항시 감시하고 기록하며, 정책에 따라 유출을 차단시킨다.\r\n\r\n### ESM(Enterprise Security Management, 통합 보안 관리)\r\n\r\n- 방화벽, 침입 탐지 시스템, 가상 사설망 등의 보안 솔루션을 하나로 모은 통합 보안 관리 시스템으로 서로 다른 보안 장비에서 발생한 각종 로그를 통합적으로 관리하여 통합 보안 관제 서비스를 제공한다.\r\n- 전사적 차원의 보안 정책 통합 관리와 적용을 통해 정보 시스템 보안성을 향상시키고 안정성을 높인다.\r\n\r\n### VPN(Virtual Private Network, 가상 사설망)\r\n\r\n- 이용자가 인터넷과 같은 공중망에 사설망을 구축하여 마치 전용망을 사용하는 효과를 가지는 보안 솔루션이다.\r\n- 안전하지 않은 공용 네트워크를 이용하여 사설 네트워크를 구성하는 기술이다.\r\n- 전용선을 이용한 사설 네트워크에 비해 저렴한 비용으로 안전한 망을 구성할 수 있다.\r\n- 공용 네트워크로 전달되는 트래픽은 암호화 및 메시지 인증 코드 등을 사용하여 기밀성과 무결성을 제공한다.\r\n- 인터넷과 같은 공공 네트워크를 통해서 기업의 재택근무자나 이동 중인 직원이 안전하게 회사 시스템에 접근할 수 있도록 해준다.\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n"},{"title":"sw first test4","description":"정보처리기사 필기(4) - 프로그래밍 언어 활용","category":"sw","date":"2023-12-27","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 모듈화와 결합도/응집도 ★★★\r\n\r\n### 모듈화\r\n\r\n- 모듈화는, 거대한 문제를 작은 조각의 문제로 나누어 다루기 쉽도록 하는 과정으로, 작게 나누어진 각 부분을 모듈이라고 한다.\r\n- 소프트웨어의 모듈은 프로그래밍 언어에서 Subroutine, Function 등으로 표현될 수 있다.\r\n- 모듈화는 시스템을 지능적으로 관리할 수 있도록 해주며, 복잡도 문제를 해결하는데 도움을 준다.\r\n- 모듈화는 시스템의 유지보수와 수정을 용이하게 한다.\r\n\r\n#### 모듈의 개념\r\n\r\n- 하나의 프로그램을 몇 개의 작은 부분으로 분할한 단위이다.\r\n- 모듈의 독립성은 결합도와 응집도에 의해 측정된다.\r\n- 각 모듈은 논리적 또는 기능적으로 분리되어 격리되고 독립적인 일을 수행한다.\r\n- 특성 : Unity(한 가지 일만 수행), Smallness(간단 명료), Simplicity(단순성), Independency(독십성) 등\r\n\r\n### 결합도(Coupling)\r\n\r\n- 한 모듈과 다른 모듈 간의 상호 의존도 또는 두 모듈 사이의 연관 관계를 의미한다.\r\n- 모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상된다.\r\n- 인터페이스가 정확히 설정되어 있지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도는 높아지고 결합도가 증가한다.\r\n- 다른 모듈과 데이터 교류가 필요한 경우 전역 변수(Global Variable)보다는 매개 변수(Parameter)를 사용하는 것이 결합도를 낮추는데 도움이 된다.\r\n- 결합도 정도 : 데이터 결합도 \u003c 스탬프 결합도 \u003c 제어 결합도 \u003c 외부 결합도 \u003c 공통 결합도 \u003c 내용 결합도\r\n\r\n- 데이터 결합도(Data Coupling)\r\n  - 한 모듈이 파라미터나 인수로 다른 모듈에 데이터를 넘겨주고 호출받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 경우의 결합도.\r\n- 스탬프 결합도(Stamp Coupling)\r\n  - 두 모듈이 동일한 자료 구조를 조회하는 경우의 결하볻\r\n- 제어 결합도(Control Coupling)\r\n  - 한 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우의 결합도\r\n- 외부 결합도(External Coupling)\r\n  - 한 모듈에서 외부로 선언한 변수를 다른 모듈에서 참조할 경우의 결합도\r\n- 공통 결합도(Common Coupling)\r\n  - 한 모듈이 다른 모듈에 제어 요소를 전달하고 여러 모듈이 공통 자료 영역을 사용하는 경우의 결합도\r\n- 내용 결합도(Content Coupling)\r\n  - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도\r\n\r\n### 응집도(Cohesion)\r\n\r\n- 한 모듈 내부의 처리 요소 간의 기능적 연관도를 의미한다.\r\n- 모듈 내부 요소는 명령어, 명령어의 모임, 호출문, 특정 작업 수행 코드 등이다.\r\n- 응집도 정도 : 기능적 응집도 \u003e 순차적 응집도 \u003e 교환적 응집도 \u003e 절차적 응집도 \u003e 시간적 응집도 \u003e 논리적 응집도 \u003e 우연적 응집도\r\n\r\n- 기능적 응집도(Functional Cohesion)\r\n  - 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로써 제공되는 경우의 응집도\r\n- 순차적 응집도(Sequential Cohesion)\r\n  - 모듈의 구성 요소가 하나의 활동으로부터 나온 출력 자료를 그다음 활동의 입력 자료로 사용하는 같은 모듈 내에서의 응집도\r\n- 교환적 응집도(Communicational Cohesion)\r\n  - 동일한 입력과 출력을 사용하는 소 작업들이 모인 모듈에서 볼 수 있는 응집도.\r\n- 절차적 응집도(Procedural Cohesion)\r\n  - 모듈이 다수의 관련 기능을 가질 때 모듈 내부의 기능 요소들이 그 기능을 순차적으로 수행할 경우의 응집도\r\n- 시간적 응집도(Temporal Cohesion)\r\n  - 특정 시간에 처리되는 여러 기능을 모아 한 개의 모듈로 작성할 경우의 응집도\r\n- 논리적 응집도(Logical Cohesion)\r\n  - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도\r\n- 우연적 응집도(Coincidental Cohesion)\r\n  - 서로 간에 어떠한 의미 있는 연관 관계도 지니지 않은 기능 요소로 구성되는 경우의 응집도\r\n\r\n### 효과적인 모듈화 설계 방법\r\n\r\n- 응집도는 강하게, 결합도는 약하게 설계한다.\r\n- 복잡도와 중복성을 줄이고 일관성을 유지할 수 있도록 설계한다.\r\n- 유지보수가 용이하도록 설계한다.\r\n- 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 설계한다.\r\n- 모듈 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.\r\n\r\n# C 언어\r\n\r\n### C언어의 기본 구조\r\n\r\n- main 함수를 반드시 포함해야 하며, main 함수에서 실행이 시작된다.\r\n- 영문 대/소문자를 엄격하게 구별한다.\r\n- 문장을 끝마칠 때는 세미콜론(;)을 사용한다.\r\n- 여러 개의 문장을 묶어 하나의 블록으로 구성할 때 중괄호({})를 사용한다.\r\n- 주석문은 /_ ~ _/로 표기한다.\r\n\r\n### 기본 자료형\r\n\r\n| 자료형 | 예약어 | 크기  |\r\n| :----: | :----: | :---: |\r\n| 정수형 |  int   | 2Byte |\r\n|        |  long  | 4Byte |\r\n| 실수형 | float  | 4Byte |\r\n|        | double | 8Byte |\r\n| 문자형 |  char  | 1Byte |\r\n\r\n### 입/출력 함수\r\n\r\n- 표준 입/출력 함수\r\n  - scanf() : 표준 입력 함수\r\n  - printf() : 표준 출력 함수\r\n  - getchar() : 문자 입력 함수\r\n  - putchar() : 문자 출력 함수\r\n  - gets() : 문자열 입력 함수\r\n  - puts() : 문자열 출력 함수\r\n- 변환 문자(출력 형식 지정 문자)\r\n  - %d : 10진 정수\r\n  - %o : 8진 정수\r\n  - %x : 16진 정수\r\n  - %f : 실수형\r\n  - %e : 지수형\r\n  - %c : 문자\r\n  - %s : 문자열\r\n\r\n### 탈출문(Escape Sequence)\r\n\r\n| 문자 |      의미       |               기능                |\r\n| :--: | :-------------: | :-------------------------------: |\r\n|  \\n  |    new line     | 커서를 다음 줄 처음으로 이동한다. |\r\n|  \\r  | carriage return | 커서를 현재 줄 처음으로 이동한다. |\r\n|  \\t  |       tab       |   커서를 일정 간격만큼 띄운다.    |\r\n|  \\b  |    backspace    |    커서를 뒤로 한 칸 이동한다.    |\r\n|  \\f  |    form feed    |        한 페이지를 넘긴다.        |\r\n|  \\0  | null character  |        널 문자를 출력한다.        |\r\n|  \\'  |  single quote   |      작은 따옴표를 출력한다.      |\r\n|  \\\"  |  double quote   |       큰따옴표를 출력한다.        |\r\n| \\ \\\\ |    backslash    |       역슬래시를 출력한다.        |\r\n|  \\a  |      alert      |        벨 소리를 발생한다.        |\r\n\r\n### C언어 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 숫자로 시작할 수 없고, 영문자나 \"\\_\"로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- auto, beak, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register,return, short, signed, sizeof, static, struct, switch, typedef, union, unsigend, void, volatile, while 32개 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 포인터 변수\r\n\r\n- 다른 변수의 주소값을 저장할 수 있다.\r\n- 표인터 변수는 자료형에 상관없이 메모리 크기가 동일하다.\r\n- 가리키고 있는 변수값을 읽기 위해서는 포인터 연산자를 사용한다.\r\n- 포인터 변수에 일반 변수의 주소를 대입하기 위해서는 \u0026(주소) 연산자를 사용한다.\r\n- 포인터 변수를 가리키는 포인터 변수를 선언할 수 있다.\r\n\r\n### 표준 라이브러리 함수\r\n\r\n- stdio.h : C언어의 표준 입/출력 라이브러리(Standard Input and Output Library)이다.\r\n- stdlib.h : C 표준 유틸리티 함수를 모아놓은 헤더 파일이다. 문자형 변환, 수치를 문자형으로 변환, 동적 할당 관련 함수, 난수 생성 함수, 정수의 연산 함수, 검색 및 정렬 함수 등이다.\r\n- stdlib.h 함수 종류\r\n  - atoi() : 문자열을 정수형으로 변환\r\n  - atof() : 문자열을 실수형으로 변환\r\n  - atol() : 문자열을 log형 정수로 변환\r\n  - itoa() : 숫자를 문자열로 변환\r\n  - ceil() : 자리 올림\r\n  - floor() : 자리 버림\r\n  - rand() : 난수 발생\r\n  - div() : 정수 나눗셈\r\n\r\n### C언어 연산자의 특징\r\n\r\n#### 단항 연산자\r\n\r\n- ! : 부정(NOT)\r\n- ~ : 1의 보수(0-\u003e1, 1-\u003e0)를 구한다.\r\n- ++ : 1씩 증가를 의미한다.\r\n- \\-- : 1씩 감소를 의미한다.\r\n- \u0026 : 변수의 주소를 의미한다.\r\n- \\* : 변수의 내용을 의미한다.\r\n- sizeof : 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구한다.\r\n\r\n#### 산술 연산자\r\n\r\n- 이항 연산자는 +, -는 \\*, /, % 보다 우선순위가 낮다.\r\n- % : 정수 나눗셈 연산 후 나머지를 구한다.\r\n\r\n#### 시프트(Shift) 연산자\r\n\r\n- \u003c\u003c는 비트를 왼쪽으로 이동시킨다.\r\n- \\\u003e\u003e는 비트를 오른쪽으로 이동시킨다.\r\n\r\n#### 관계 연산자\r\n\r\n- \u003c : ~보다 작다.\r\n- \\\u003e : ~보다 크다.\r\n- \u003c= : ~보다 작거나 같다.\r\n- \\\u003e\\ : ~보다 크거나 같다.\r\n- == : ~와 같다.\r\n- != : ~와 같지 않다.\r\n\r\n#### 비트 연산자\r\n\r\n- \u0026 : 논리곱(AND)\r\n- | : 논리합(OR)\r\n- ^ : 배타적 논리합(XOR)\r\n\r\n```C\r\n\r\n#include \u003cstdio.h\u003e\r\nint main(int argc, char *argv[]) {\r\n    int a = 4;\r\n    int b = 7;\r\n    int c = a|b;\r\n    printf(\"%d\", c);\r\n    return 0;\r\n}\r\n// 1. 변수 a와 b의 4, 7을 (2진수)비트 연산자 |(OR)로 연산한다.\r\n// 2. 비트 연산자는 2진수로 변환 후 계산한다.\r\n// 3. OR 연산자는 두 비트 중 1개라도 1이면 1이 출력된다.\r\n//     0100 (10진수: 4)\r\n// OR  0111 (10진수: 7)\r\n// =   0111(둘 중 1개라도 1이면 1이기 때문에 10진수: 7)\r\n// 4. 0111는 \"%d\" 출력 형식 지정 문자에 의해 10진수로 변환하면 7이 되어 출력된다.\r\n//\r\n// 2와 5를 가정할때\r\n//     0010\r\n// OR  0101\r\n// =   0111\r\n\r\n```\r\n\r\n#### 논리 연산자\r\n\r\n- ! : 논리 부정(NOT)\r\n- \u0026\u0026 : 논리곱(AND)\r\n- || : 논리합(OR)\r\n\r\n#### 조건 연산자\r\n\r\n- C언어에서 유일하게 3개의 피연산자를 갖는 삼항 연산자이다.\r\n- 조건식 ? 참일 경우 값 : 거짓일 경우 값\r\n- ex. big = a \u003e b ? a:b; -\u003e a와 b 중에서 큰 수가 big에 저장됨\r\n\r\n# Java 언어\r\n\r\n- 객체지향 언어이다.\r\n- 추상화, 상속화, 다형성과 같은 특징을 가진다.\r\n- 네트워크 환경에서 분산 작업이 가능하도록 설계되었다.\r\n- 특정 컴퓨터 구조와 무관한 가상 바이트 머신 코드를 사용하므로 플랫폼이 독립적이다.\r\n\r\n### Garbage Collector\r\n\r\n- S/W 개발 중 유효하지 않은 가비지 메모리가 발생한다. Java에서는 C언어와 달리 JVM 가비지 컬렉터가 불필요 메모리를 알아서 정리해준다.\r\n\r\n### Java 언어의 기본 자료형\r\n\r\n|  분류  | 예약어  | 바이트 수 |                          비고                           |\r\n| :----: | :-----: | :-------: | :-----------------------------------------------------: |\r\n| 정수형 |  byte   |   1byte   |                       -127 ~ +128                       |\r\n|        |  short  |   2byte   |                    -32,768 ~ +32,767                    |\r\n|        |   int   |   4byte   |             -2,147,483,648 ~ +2,147,483,648             |\r\n|        |  long   |   8byte   | -9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,808 |\r\n| 실수형 |  float  |   4byte   |           단정도 실수형 (유효 자리는 7정도임)           |\r\n|        | double  |   8byte   |           배정도 실수형 (유효 자리는 15정도)            |\r\n| 문자형 |  char   |   2byte   |                   유니코드 문자열 1자                   |\r\n| 논리형 | boolean |   1byte   |                       true,false                        |\r\n\r\n### 이스케이프 시퀀스(Escape Sequence)\r\n\r\n| 문자 |      의미       |               기능                |\r\n| :--: | :-------------: | :-------------------------------: |\r\n|  \\n  |    new line     | 커서를 다음 줄 처음으로 이동한다. |\r\n|  \\r  | carriage return | 커서를 현재 줄 처음으로 이동한다. |\r\n|  \\t  |       tab       |   커서를 일정 간격만큼 띄운다.    |\r\n|  \\b  |    backspace    |    커서를 뒤로 한 칸 이동한다.    |\r\n|  \\f  |    form feed    |         한 페이지 넘긴다.         |\r\n|  \\'  |  single quote   |      작은따옴표를 출력한다.       |\r\n|  \\\"  |  double quote   |       큰따옴표를 출력한다.        |\r\n| \\ \\  |    backslash    |       역슬래시를 출력한다.        |\r\n\r\n### Java 접근 제한자(접근 제어자)\r\n\r\n- public : 모든 접근을 허용한다.\r\n- private : 같은 패키지에 있는 객체와 상속 관계의 객체들만 허용한다.\r\n- default : 같은 패키지에 있는 객체들만 허용한다.\r\n- protected : 현재 객체 내에서만 허용한다.\r\n\r\n### Java의 출력 함수\r\n\r\n- System.out.print() : 괄호 안을 출력하고 줄 바꿈을 안 한다.\r\n- System.out.printIn() : 괄호 안을 출력하고 줄 바꿈을 한다.\r\n- System.out.printf() : 변환 문자를 사용하여 출력한다.\r\n- 변환 문자(출력 형식 지정 문자)\r\n- %d : 10진 정수\r\n- %o : 8진 정수\r\n- %x : 16진 정수\r\n- %f : 실수형\r\n- %e : 지수형\r\n- %c : 문자\r\n- %s : 문자열\r\n\r\n### Java 언어 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_', '$'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 영문자나 '\\_', '$'로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 오버로딩(Overloading)과 오버라이딩(Overiding)\r\n\r\n#### 오버로딩(Overloading - 과적, 과부하)\r\n\r\n- 한 클래스 내에서 같은 메서드를 사용하는 것이다.\r\n- 같은 이름의 메서드를 여러 개 정의하면서 매개 변수의 유형과 개수가 달라지도록 하는 기술이다.\r\n\r\n#### 오버라이딩(Overriding - 다른 것보다 우선인)\r\n\r\n- 상속 관계의 두 클래스의 상위 클래스에서 정의한 메서드를 하위 클래스에서 변경(재정의)하는 것이다.\r\n- Java 언어에서는 static 메ㅓㅅ드의 오버라이딩을 허용하지 않는다.\r\n- 오버라이딩의 경우 하위 객체의 매개 변수 개수와 타입은 상위 객체와 같아야 한다.\r\n\r\n# 스크립트 언어\r\n\r\n- 소스 코드를 컴파일 과정을 거치지 않고 실행할 수 있는 프로그래밍 언어이다.\r\n- 스크립트 언어에 내장된 번역기에 의해 번역되어 실행된다.\r\n- 실행 단계에서 구분을 분석한다.\r\n\r\n### 스크립트 언어의 종류\r\n\r\n1. 서버 측 스크립트 언어\r\n   - ASP(Active Server Page)\r\n     - 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 Windows 계열의 운영체제에서 실행 가능하다.\r\n   - JSP(Java Server Page)\r\n     - Java를 기반으로 하고 서버 측에서 동적으로 수행하는 페이지를 만드는 언어이다.\r\n   - PHP(Professional Hypertext Preprocessor)\r\n     - 소스 코드가 HTML 파일에 포함되는 언어이다.\r\n     - 데이터베이스와의 연동이 매우 용이하다.\r\n     - Linux, UNIX, Window 등의 다양한 운영 체제에서 사용 가능하다.\r\n       - PHP 연산자\r\n         - 산술 연산자 : +, -, \\*, /, %, \\*\\*\r\n         - 할당 연산자 : =, +=, -=, \\*=, /=, %=\r\n         - 증감 연산자 : ++, --\r\n         - 관계 연산자 : ==, ===, !=, \u003c\u003e, !==, \u003e, \u003c, \u003e=, \u003c=\r\n         - 논리 연산자 : and, or, xor, \u0026\u0026, ||, !\r\n   - 파이썬(Python)\r\n     - 인터프리터 방식의 객체지향 언어이다.\r\n     - 실행 시점에 데이터 타입을 결정하는 동적 타이핑 기능을 갖는다.\r\n2. 클라이언트 측 스크립트 언어\r\n   - JavaScript\r\n     - HTML 문서에서 HTML이나 CSS로 표현하기 어렵거나 불가능한 작업을 수행하기 위해 개발되었다.\r\n     - 소스 코드가 HTML 문서에 포함되어 있다.\r\n     - 클래스가 존재하지 않으며 변수 선언도 필요 없다.(?)\r\n     - 사용자의 웹 브라우저에서 직접 번역되고 시랳ㅇ된다.\r\n   - VBScript\r\n     - 마이크로소프트가 개발한 액티브 스크립트 언어이다.\r\n     - VBScript의 구분은 비주얼 베이직(Visual Basic) 프로그래밍 언어를 일부 반영한다.\r\n\r\n# 파이썬(Python)\r\n\r\n### 파이썬 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 영문자나 '\\_'로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 문자열 추출\r\n\r\n- 하나의 문자를 추출하려면 추출하려는 문자의 인덱스(0부터 시작)을 지정한다.\r\n\r\n```python\r\n\r\nstring = 'hello python'\r\n\r\ns1 = string[0]\r\nprint(s1) # 'h'\r\n\r\ns2 = string[4]\r\nprint(s2) # 'o'\r\n\r\n# 역순으로 맨 오른쪽의 인덱스는 -1이다.\r\n\r\ns3 = string[-1]\r\nprint(s3) # 'n'\r\n\r\ns4 = string[-6]\r\nprint(s4) # 'p'\r\n\r\n# [:]는 처음부터 끝까지 추출한다.\r\n\r\ns5 = string[:]\r\nprint(s5) # 'hello python'\r\n\r\n# [x:] 인덱스 x부터 끝까지 추출한다.\r\n\r\ns6 = string[6:]\r\nprint(s6) # 'python'\r\n\r\ns7 = string[-6:]\r\nprint(s7) # 'python'\r\n\r\n# [:y] 처음부터 인덱스 y-1 까지 추출한다.\r\n\r\ns8 = string[:5]\r\nprint(s8) # 'hello'\r\n\r\n# [x:y] 인덱스 x부터 y-1까지 추출한다.\r\ns9 = string[4:7]\r\nprint(s9) # 'o p'\r\n\r\n# [x:y:z] 인덱스 x부터 y-1까지 z만큼 건너뛰면서 추출한다.\r\ns10 = string[:10:2]\r\nprint(s10) # 'hlopt'\r\n\r\ns11 = string[1:10:2]\r\nprint(s11) # 'el yh'\r\n\r\n```\r\n\r\n# 운영체제(OS : Operating System)\r\n\r\n- 운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어이다.\r\n- 운영체제는 컴퓨터를 편리하게 사용하고 컴퓨터 하드웨어를 효율적으로 사용할 수 있도록 한다.\r\n- 운영체제는 스스로 어떤 유용한 기능도 수행하지 않고 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 마련해준다.\r\n- 운영체제의 종류로는 MS-DOS, Windows 10, Linux, UNIX, OS/2, 안드로이드, IOS 등이 있다.\r\n\r\n### 운영체제의 기능\r\n\r\n- 사용자와 시스템 간의 편리한 인터페이스를 제공한다.\r\n- 컴퓨터의 시스템의 성능을 최적화시킨다.\r\n- 자원의 효과적인 경영을 위해 스케줄링 기능을 제공한다.\r\n- 자원 보호 기능을 제공한다.\r\n- 시스템에서 발생하는 오류로부터 시스템을 보호한다.\r\n- 사용자들 간에 데이터를 공유할 수 있도록 한다.\r\n\r\n### 운영체제의 목적\r\n\r\n1. 처리 능력(Throughput) 향상\r\n   - 처리 능력은 일정 시간 내에 시스템이 처리하는 일의 양이다.\r\n   - 처리 능력이 높을수록 처리하는 일의 양이 많아진다.\r\n2. 반환 시간(Turnaround Time)감소\r\n   - 반환 시간은 컴퓨터 센터에 작업을 지시하고 나서부터 결과를 받을 때까지의 경과 시간이다.\r\n   - 반환 시간이 감소될수록 처리 속도가 빨라진다.\r\n3. 신뢰도(Reliability) 향상\r\n   - 신뢰도는 시스템이 주어진 문제를 정확하게 해결하는 정도이다.\r\n   - 신뢰도가 높을수록 일을 정확하게 처리한다.\r\n4. 사용 가능도(Availability) 향상\r\n   - 사용 가능도는 한정된 자원을 여러 사용자가 요구할 때, 어느 정도 신속하고 충분히 지원해 줄 수 있는지의 정도이다.\r\n   - 사용 가능도가 높을수록 반환 시간이 감소한다.\r\n\r\n### 운영체제의 운영 방식\r\n\r\n1. 일괄 처리 시스템(Batch Processing System)\r\n   - 일정량 또는 일정 기간 동안 데이터를 한꺼번에 모아서 처리하는 방식이다.\r\n   - 운영체제 운용 방식 중 시대적으로 가장 먼저 생겨났다.\r\n   - ex. 수도요금 계산 업무, 월급 계산 업무 등\r\n2. 다중 프로그래밍 시스템(Multi programming System)\r\n   - 컴퓨터 시스템 자원 활용률을 극대화하기 위해 2개 이상의 프로그램을 주기억 장치에 기억시키고 CPU를 번갈아 사용하면서 처리하는 방식이다.\r\n3. 시분할 시스템(Time Sharing System)\r\n   - CPU의 전체 사용 시간을 작은 작업 시간량(Time Slice)으로 나누어서 그 시간량 동안만 번갈아 가면서 CPU를 할당하여 각 작업을 처리하는 방식이다.\r\n   - 실제로 많은 사용자가 하나의 컴퓨터를 공유하고 있지만 마치 자신만이 컴퓨터 시스템을 독점하여 사용하고 있는 것처럼 느끼게 된다.\r\n4. 다중 처리 시스템(Multi-Processing System)\r\n   - 동시에 프로그램을 수행할 수 있는 CPU를 두 개 이상 두고 각각 그 업무를 분담하여 처리할 수 있는 방식이다.\r\n5. 실시간 처리 시스템(Real Time Processing System)\r\n   - 데이터 발생 즉시, 또는 데이터 처리 요구가 있는 즉시 처리하여 결과를 산출하는 방식이다.\r\n   - 정해진 시간에 반드시 수행되어야 하는 작업들을 처리할 때 가장 정합하다.\r\n   - ex. 항공기 예약 업무, 은행 창구 업무, 조회 및 질의 업무 등\r\n6. 다중 모드 시스템(Multi-mode System)\r\n   - 일괄 처리 + 시분할 + 다중 처리 + 실시간 처리\r\n7. 분산 처리 시스템(Distributed Processing System)\r\n   - 여러 대의 컴퓨터로 작업을 나누어 처리하여 그 내용이나 결과를 통신망을 이용하여 상호 교환되도록 연결하는 방식이다.\r\n\r\n# 프로세스(Process)\r\n\r\n### 프로세스의 정의\r\n\r\n- 실행 중인 프로그램이다.\r\n- 실행 가능한 PCB를 가진 프로그램이다.\r\n- 프로세서가 할당되는 실체이다.\r\n- 프로시저가 활동 중인 것이다.\r\n- 비동기적 행위를 일으키는 주체이다.\r\n\r\n### 프로세스 제어 블록(PCB: Process Control Block)\r\n\r\n- 운영체제가 프로세스를 관리하기 위해 프로세스에 대한 중요한 정보를 저장해 놓은 곳이다.\r\n- 프로세스가 생성될 때마다 고유의 PCB가 생성되며, 프로세스가 소멸되면 PCB도 소멸된다.\r\n- PCB에 저장되어 있는 정보 : 프로세스의 현재 상태, 프로세스의 우선순위, 프로세스에 할당된 자원에 대한 정보, CPU 레지스터 정보\r\n\r\n### 프로세스 상태 전이\r\n\r\n```\r\n생성(New) -\u003e 준비(Ready) -(디스패치-Dispatch)-\u003e 실행(Run) -\u003e 종료(Exit)\r\n                ↑        \u003c-(Timer Runout)-    ↙\r\n             Wake Up            Block ←-------\r\n                |           ↙\r\n           대기(Blocked) ←--\r\n```\r\n\r\n- 준비 상태(Ready State)\r\n  - 프로세스가 CPU를 할당받기 위해 준비하고 있는 상태이다.\r\n- 실행 상태(Running State)\r\n  - 준비 상태의 프로세스가 CPU를 할당받아 실행 중인 상태이다.\r\n  - 디스패치(Dispatch) : 우선순위가 가장 높은 프로세스가 준비 상태에서 실행 상태로 전환되는 것이다.\r\n  - 할당 시간 종료(Time Runout) : 실행 상태의 프로세스가 할당 시간(타이머)이 종료되어 준비 상태로 전환되는 것이다.\r\n- 대기 상태(Blocked State)\r\n  - 실행 상태의 프로세스가 종료되기 전에 입/출력 등의 다른 작업이 필요할 경우 CPU를 반납하고 작업의 완료를 기다리는 상태이다.\r\n  - 블록(Block) : 실행 상태에서 대기 상태로 전환되는 것이다.\r\n  - 웨이크 업(Wake Up) : 대기 상태의 프로세스가 웨이크업(조건 만족)되면 준비 상태로 전환된다.\r\n\r\n### 스레드(Thread)\r\n\r\n- 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위를 의미한다.\r\n- 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.\r\n- 한 개의 프로세스는 여러 개의 스레드를 가질 수 있다.\r\n\r\n## 프로세스 스케줄링(Process Scheduling)\r\n\r\n- 프로세스의 생성 및 실행에 필요한 시스템의 자원을 해당 프로세스에 할당하는 작업이다.\r\n- 다중 프로그래밍 운영체제에서 자원의 성능을 향상시키고 효율적인 프로세서의 관리를 위해 작업 순서를 결정하는 것이다.\r\n\r\n### 프로세스 스케줄링 기법\r\n\r\n#### 비선점(Non-Preemptive) 스케줄링\r\n\r\n1. FIFO(First in Fist Out)\r\n   - 준비 상태 큐에 도착한 순서대로 CPU를 할당하는 기법이다.\r\n   - FCFS(Fist Come First Service)라고도 한다.\r\n2. SJF(Shortest Job First)\r\n   - 준비 상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 스케줄링 기법이다.\r\n   - 평균 대기 시간을 최소화한다.\r\n3. HRN(Highest Responseratio Next)\r\n   - 어떤 작업이 서비스받을 시간과 그 작업이 서비스를 기다린 시간으로 결정되는 우선순위에 따라 CPU를 할당하는 기법이다.\r\n   - 우선순위 계산식 = (대기 시간 + 서비스를 받을 시간) / 서비스를 받을 시간\r\n4. 우선순위(Priority)\r\n   - 준비 상태 큐에서 대기하는 프로세스에게 부여된 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법이다.\r\n   - 우선순위가 낮은 프로세스는 무한 정지(Indefinite Blocking)가 발생할 수 있으며, 에이징(Aging) 기법으로 이를 해결할 수 있다.\r\n\r\n#### 선점(Preemptive) 스케줄링\r\n\r\n- 한 프로세스가 CPU를 할당받아 실행 중이라도 우선순위가 높은 다른 프로세스가 CPU를 강제적으로 뺴앗을 수 있는 방식이다.\r\n- 긴급하고 높은 우선순위의 프로세스들이 빠르게 처리될 수 있다.\r\n- 선점을 위한 시간 배당에 대한 인터럽트용 타이머 클럭(Clock)이 필요하다.\r\n- 온라인 응용에 적합한 스케줄링이다.\r\n- 종류\r\n  - RR(Round Robin)\r\n    - 주어진 시간 할당량(Time Slice) 안에 작업을 마치지 않으면 준비 상태 큐의 가장 뒤로 배치된다.\r\n    - 시분할 시스템(Time-sharing System)을 위해 고안된 방식이다.\r\n    - 시간 할당량이 커지면 FCFS 스케줄링과 같은 효과를 얻을 수 있다.\r\n    - 시간 할당이 작아지면 프로세스 문맥 교환이 자주 일어난다.\r\n  - SRT(Shortest Remainig Time)\r\n    - 작업이 끝나기까지의 실행시간 추정치가 가장 작은 작업을 먼저 실행시키는 기법이다.\r\n    - FIFO 기법보다 평균 대기 시간이 감소된다.\r\n    - 작업 시간이 큰 경우 오랫동안 대기하여야 한다.\r\n  - 다단계 큐(Multi-Level Queue)\r\n    - 프로세스들을 우선순위에 따라 상위, 중위, 하위 단계의 단계별 준비 상태 큐를 배치하는 기법이다.\r\n  - 다단계 피드백 큐(Multi-Level Feedback Queue)\r\n    - 각 준비 상태 큐마다 부여된 시간 할당량 안에 완료하지 못한 프로세스는 다음 단계의 준비 상태 큐로 이동하는 기법이다.\r\n\r\n# OST(Open Systems Interconnection) 7계층 ★★★\r\n\r\n1. 물리 계층(Physical Layer)\r\n   - 물리적인 장치와 인터페이스가 전송을 위해 필요한 기계적, 전기적, 기능적, 절차적 기능을 정의하는 계층이다.\r\n   - 장치와 전송 매체 간의 인터페이스 특성 규정, 전송 매체의 유형 규정, 전송로의 연결, 유지 및 해제를 담당한다.\r\n   - 프로토콜 종류 : RS-232C, V.24, X.21\r\n2. 데이터 링크 계층(Data Link Layer)\r\n   - 인접한 두 개의 통신 시스템 간에 신뢰성 있는 효율적인 데이터를 전송하는 계층이다.\r\n   - 링크의 설정과 유지 및 종료를 담당한다.\r\n   - 전송 데이터의 흐름 제어, 프레임 동기, 오류 제어 등을 수행한다.\r\n   - 링크의 효율성을 향상시킨다.\r\n   - 프로토콜 종류 : HDLC, PPP, LLC, LAPB, LAPD, ADCCP\r\n3. 네트워크 계층(Network Layer)\r\n   - 통신망을 통해 패킷을 목적지까지 전달하는 계층.\r\n   - 경로 설정 및 네트워크 연결 관리를 수행.\r\n   - 과도한 패킷 유입에 대한 폭주 제어 기능을 한다.\r\n   - 프로토콜 종류 : X.25, IP, ICMP, IGMP\r\n4. 전송 계층(Transport Layer)\r\n   - 통신 종단 간(End-to-End) 신뢰성 있고 효율적인 데이터를 전송하는 계층이다.\r\n   - 투명한 데이터 전송을 제공한다.\r\n   - 에러 제어 및 흐름 제어를 담당한다.\r\n   - 프로토콜 종류 : TCP, UDP\r\n5. 세션 계층(Session Layer)\r\n   - 프로세스 간에 대한 연결을 확립, 관리, 단절시키는 수단을 제공한다.\r\n   - 논리적 동기 제어, 긴급 데이터 전송, 통신 시스템 간의 회화 기능 등을 제공한다.\r\n6. 표현 계층(Presentation Layer)\r\n   - 응용 간의 대화 제어(Dialogue Control)을 담당한다.\r\n   - 응용 계층과 세션 계층 사이에서 데이터 변환을 담당한다.\r\n   - 정보의 형식 설정, 암호화, 데이터 압축, 코드 변환, 문맥 관리 등의 기능을 수행한다.\r\n   - 긴 파일 전송 중에 통신 상태가 불량하여 트랜스포트 연결이 끊어지는 경우 처음부터 다시 전송하지 않고 어디까지 전송이 진행되었는지를 나타내는 동기점을 이용하여 오류를 복구한다.\r\n7. 응용 계층(Application Layer)\r\n   - 사용자에게 서비스를 제공한다.\r\n   - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.\r\n   - 프로토콜 종류 : HTTP, FTP, SMTP, Telnet, DNS\r\n\r\n# TCP/IP 프로토콜(Transmission Control Protocol/Internet Protocol)\r\n\r\n- 인터넷에 연결된 서로 다른 기종의 컴퓨터 간에 데이터 송/수신이 가능하도록 도와주는 표준 프로토콜이다.\r\n- TCP 프로토콜과 IP 프로토콜의 결합적 의미로서 TCP가 IP보다 상위층에 존재한다.\r\n- 접속형 서비스, 전이중 전송 서비스, 신뢰성 서비스를 제공한다.\r\n- 네트워크 환경에 따라 여러 개의 프로토콜을 허용한다.\r\n- TCP 프로토콜의 기본 헤더 크기는 20byte이고 60byte까지 확장 가능하다.\r\n- OSI 표준 프로토콜과 가까운 네트워크 구조를 가진다.\r\n  - OSI 7계층 : 물리, 데이터, 네트워크, 전송, 세션, 표현, 응용 계층\r\n  - TCP/IP 4계층 : 링크, 인터넷, 전송, 응용 계층\r\n\r\n### TCP(Transmission Control Protocol)\r\n\r\n- OSI 7계층의 전송 계층의 역할을 수행한다.\r\n- 서비스 처리를 위해 Multiplexing과 DeMultiplexing을 이용한다.\r\n- 전이중 서비스와 스트림 데이터 서비스를 제공한다.\r\n\r\n### IP(Internet Protocol)\r\n\r\n- OSI 7계층의 네트워크 계층에 해당하며 비신뢰성 서비스를 제공한다.\r\n\r\n## TCP/IP의 구조\r\n\r\n### 링크 계층(Link Layer)\r\n\r\n- 프레임을 송/수신한다.\r\n- 프로토콜의 종류 : Ethernet, IEEE 802, HDLC, X.25, RS-232C 등\r\n\r\n### 인터넷 계층(Internet Layer)\r\n\r\n- 주소 지정, 경로 설정을 제공한다.\r\n- 네트워크 계층이라고도 한다.\r\n- 프로토콜 종류 : IP, ICMP, IGMP, ARP, RARP 등\r\n  - IP(Internet Protocol)\r\n    - 비연결형 및 비신뢰성 전송 서비스를 제공한다.\r\n    - 라우팅과 단편화 기능을 수행한다.\r\n    - 데이터그램(Datagram)이라는 데이터 전송 형식을 가진다.\r\n    - 각 데이터그램이 독립적으로 처리되고 목적지까지 다른 경로를 통해 전송될 수 있어 데이터그램은 전송 순서와 도착 순서가 다를 수 있다.\r\n    - 비연결성이기 때문에 송신지가 여러 개인 데이터 그램을 보내면서 순서가 뒤바뀌어 도달할 수 있으며 IP 프로토콜의 헤더 길이는 최소 20~60byte이다.\r\n  - ICMP(Internet Control Message Protocol)\r\n    - IP 프로토콜에서는 오류 보고와 수정을 위한 메커니즘이 없기 때문에 이를 보완하기 위해 설계된 프로토콜이다.\r\n    - 메시지는 크게 오류 보고(Error-Reporting) 메시지와 질의(Query) 메시지로 나눌 수 있다.\r\n    - 메시지 형식은 8바이트의 헤더와 가변 길이의 데이터 영역으로 분리된다.\r\n    - 에코 메시지는 호스트가 정상적으로 동작하는지를 결정하는데 사용할 수 있다.\r\n    - 수신지 도달 불가 메시지는 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는데 사용한다.\r\n  - IGMP(Internet Group Management Protocol)\r\n    - 시작지 호스트에서 여러 목적지 호스트로 데이터를 전송할 때 사용되는 프로토콜이다.\r\n    - 멀티캐스트 그룹에 가입한 네트워크 내의 호스트를 관리한다.\r\n  - ARP 20.9(Address Resolution Protocol)\r\n    - 논리 주소(IP 주소)를 물리 주소(MAC 주소)로 변환하는 프로토콜이다.\r\n    - 네트워크에서 두 호스트가 성공적으로 통신하기 위해 각 하드웨워의 물리적인 주소 문제를 해결해 줄 수 있다.\r\n  - RARP(Reverse Address Resolution Protocol)\r\n    - 호스트의 물리 주소(MAC 주소)로부터 논리 주소(IP 주소)를 구하는 프로토콜이다.\r\n    - IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP 주소를 모르는 경우, 서버에게 IP 주소를 요청하기 위해 사용한다.\r\n\r\n### 전송 계층(Transport Layer)\r\n\r\n- 호스트 간 신뢰성 있는 통신을 제공한다.\r\n- 프로토콜 종류 : TCP, UDP\r\n  - TCP 20.8(Transmission Control Protocol)\r\n    - 신뢰성 있는 연결 지향형 전달 서비스를 제공한다.\r\n    - 순서 제어, 에러 제어, 흐름 제어 기능을 제공한다.\r\n    - 전이중 서비스와 스트림 데이터 서비스를 제공한다.\r\n    - 메시지를 캡슐화(Encapsulation)와 역캡슐화(Decapsulation)한다.\r\n    - 서비스 처리를 위해 다중화(Multiplexing)와 역다중화(Demultiplexing)를 이용한다.\r\n  - UDP 20.9(User Datagram Protocol)\r\n    - 비연결형 및 비신뢰성 전송 서비스를 제공한다.\r\n    - 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.\r\n    - 수신된 데이터의 순서 재조정 기능을 지원하지 않는다.\r\n    - 복구 기능을 제공하지 않는다.\r\n\r\n# IP 주소 ★★★\r\n\r\n### IPv4(Internet Protocol version 4)\r\n\r\n- 32비트 길이의 IP주소이다.\r\n- 주소의 각 부분을 8비트씩 4개로 나눠서 10진수로 표현한다.\r\n- IP 주소 = 네트워크 주소(Netid) + 호스트 주소\r\n\r\n#### IPv4의 주소 체계\r\n\r\n- 클래스 A\r\n  - 0.0.0.0 ~ 127.255.255.255\r\n  - 기본 서브넷 마스크 : 255.0.0.0\r\n  - 국가나 대형 통신망에서 사용한다.\r\n- 클래스 B\r\n  - 128.0.0.0 ~ 191.255.255.255\r\n  - 기본 서브넷 마스크 : 255.255.0.0\r\n  - 중대형 통신망에서 사용한다.\r\n- 클래스 C\r\n  - 192.0.0.0 ~ 223.255.255.255\r\n  - 기본 서브넷 마스크 : 255.255.255.0\r\n  - 소규모 통신망에서 사용한다.\r\n- 클래스 D\r\n  - 224.0.0.0 ~ 239.255.255.255\r\n  - 멀티캐스트용으로 사용한다.\r\n- 클래스 E\r\n  - 240.0.0.0 ~ 255.255.255.255\r\n  - 실험용으로 사용한다.\r\n\r\n### IPv6(Internet Protocol version 6)\r\n\r\n- IPv4의 주소 부족 문제를 해결하기 위해 개발되었다.\r\n- 128비트 길이의 IP 주소이다.\r\n- 16비트씩 8개의 필드로 분리 표기된다.\r\n\r\n#### IPv6의 장점\r\n\r\n- 인증 보안 기능을 포함하고 있어 IPv4보다 보안성이 강화되었다.\r\n- IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다.\r\n- 임의의 크기의 패킷을 주고받을 수 있도록 패킷 크기 제한이 없다.\r\n- 멀티미디어의 실시간 처리가 가능하다.\r\n- 자동으로 네트워크 환경 구성이 가능하다.\r\n- 주소체계는 유니캐스트(Unicast), 애니캐스트(Anycast), 멀티캐스트(Multicast) 등 세 가지로 나뉜다.\r\n\r\n#### IPv6의 통신 방식 20.6\r\n\r\n- 유니캐스트(Unicast)\r\n  - 하나의 호스트에서 다른 하나의 호스트에게 전달하는 1:1 통신 방식이다.\r\n- 애니캐스트(Anycast)\r\n  - 하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달하는 '1: 가장 가까운 1' 통신 방식이다.\r\n- 멀티캐스트(Multicast)\r\n  - 하나의 호스트에서 네트워크상의 특정 그룹 호스트들에게 전달하는 1:N 통신 방식이다.\r\n\r\n### 서브넷 마스크(Subnet Mask)\r\n\r\n- 네트워크를 작은 내부 네트워크로 분리하여 효율적으로 네트워크를 관리하기 위한 수단이다.\r\n- 서브넷 마스크는 32비트의 값으로 IP 주소를 네트워크와 호스트 IP 주소를 구분하는 역할을 한다.\r\n- 네트워크 ID에 해당하는 모든 비트를 1로 설정하며, 호스트 ID에 해당하는 모든 비트를 0으로 설정한다.\r\n- CIDR 표기 형식 : 10진수의 IP/네트워크 ID의 1비트의 개수\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n"},{"title":"sw first test3","description":"정보처리기사 필기(3) - DB 구축","category":"sw","date":"2023-12-26","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 자료 구조\r\n\r\n### 자료 구조의 분류\r\n\r\n1. 선형 구조\r\n   - 리스트\r\n     - 선형 리스트\r\n     - 연결 리스트\r\n2. 비선형 구조\r\n   - 트리\r\n   - 그래프\r\n\r\n### 자료 구조의 활용\r\n\r\n- 정렬\r\n  - 집합된 데이터 레코드를 일정 기준으로 재배열하는 것.\r\n  - 오름차순, 내림차순\r\n- 검색\r\n  - 저장된 데이터 레코드 중 원하는 값을 빠르게 찾는 것\r\n- 인덱스(Index)\r\n  - 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로, 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 별도로 구성한 순서 데이터를 말한다. (ex. 책의 맨 뒤에 빠르게 찾기 등)\r\n  - B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있다.\r\n  - BETWEEN 등 범위(Range) 검색에 활용될 수 있다.\r\n- 파일 편성\r\n  - 파일에서 레코드의 물리적인 배열 방법이다.\r\n\r\n## 선형 자료 구조\r\n\r\n### 리스트(List)\r\n\r\n- 선형 리스트(Linear List)\r\n  - 배열(Array)과 같이 연속되는 기억 장소에 저장되는 리스트이다.\r\n  - 가장 간단한 데이터 구조 중 하나로 데이터 항목을 추가 삭제하는 것이 불편하다.\r\n- 연결 리스트(Linked List)\r\n  - 노드의 포인터 부분을 서로 연결시킨 리스트로, 연속적인 기억 공간이 없어도 저장이 가능하다.\r\n  - 노트의 삽입/삭제가 용이하며 포인터를 위한 추가 공간이 필요하므로 기억 공간이 많이 소요된다.\r\n\r\n### 스택(Stack)\r\n\r\n- 리스트의 한쪽 끝에서만 자료의 삽입과 삭제가 이루어 지는 자료 구조이다.\r\n- 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO, Last In First Out) 방식이다.(PUSH and POP)\r\n- 마지막 삽입된 자료의 위치를 Top이라 하고, 가장 먼저 삽입된 자료의 위치를 Bottom이라고 한다.\r\n- 스택 가능 : 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술이다.\r\n- 스택 응용 분야\r\n  - 인터럽트 처리, 수식의 계산, 0-주소 지정 방식\r\n  - 재귀호출, 후위 표현(Post-fix expression)의 연산, 깊이 우선 탐색\r\n\r\n**스택의 삽입 알고리즘**\r\n\r\n```\r\n\r\nif TOP \u003e= n then call Stack-Full;\r\nelse TOP = TOP + 1;\r\nStack(TOP) = Data;\r\nend Insert\r\n\r\n```\r\n\r\n**스택의 삭제 알고리즘**\r\n\r\n```\r\nif TOP = 0\r\nthen Underflow\r\nElse\r\nRemove S(TOP)\r\nTOP = TOP - 1\r\n```\r\n\r\n**스택의 오버플로 알고리즘**\r\n\r\n```\r\nTOP \u003c- TOP + 1\r\nif TOP \u003e n then goto AA\r\nelse Stack(TOP) \u003c- item\r\n```\r\n\r\n### 큐(Queue)\r\n\r\n- 자료의 삽입 작업은 선형 리스트의 한쪽 끝에서, 제거 작업은 다른 쪽 끝에서 수행되는 자료 구조이다.\r\n- 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO: First In First Out) 방식이다.\r\n- 큐의 응용 분야 : 운영체제의 작업 스케줄링 등에서 응용된다.\r\n\r\n### 덱(Deque)\r\n\r\n- 자료의 삽입과 삭제가 리스트의 양쪽 끝에서 이루어지므로 두 개의 포인터를 사용하는 자료 구조이다.\r\n- 스택과 큐를 복합한 형태이다.\r\n- 입력 제한 덱을 Scroll, 출력 제한 덱을 Shelf라고 한다.\r\n\r\n## 비선형 구조\r\n\r\n### 트리(Tree)\r\n\r\n- 그래프(Graph)의 특수한 형태로써 노드(Node)와 브랜치(Branch)를 이용하여 사이클을 이루지 않도록 구성한 자료 구조이다.\r\n\r\n### 이진 트리(Binary Tree)\r\n\r\n- 차수(Degree)가 이 이하인 노트들로만 구성된 트리\r\n- 이 트리의 레벨 n에서 최대 노드의 수 : 2ⁿ-1\r\n- 깊이(레벨)가 4인 트리의 최대 노드 수는 2⁴-1로, 15이다.\r\n- 구조\r\n  - 정이진 트리 : 첫 번째 레벨부터 마지막 레벨까지 모두 2개씩 채워진 트리를 말한다.\r\n  - 전이진 트리 : 전이진 트리에서 한쪽 방향 노드가 아예 존재하지 않는 트리를 말한다.\r\n  - 사향 이진 트리 : 근노드로부터 한쪽 방향으로만 기울어진 트리를 말한다.\r\n\r\n### 그래프\r\n\r\n- 정점(Vertex)과 간선(Edge)의 집합으로 이루어지는 자료 구조.\r\n- 표현 방법 : 인접 행렬(Adjacency Matrix)\r\n- 신장 트리(Spanning Tree) : 간선들이 사이클을 이루지 않도록 정점들을 연결시킨 그래프이다.\r\n- 종류 : 방향 그래프, 무방향 그래프, 완전 그래프, 부 그래프\r\n- n개의 노드로 구성된 무방향 그래프의 최대 간선 수는 n(n-1)/2개다.\r\n- 제어 흐름 스래프에서 순환 복잡도 : V(G) - E(화살표 수) - N(노드 수) + 2\r\n\r\n### 인접 행렬(Adjacency Matrix)\r\n\r\n- 방향 그래프에서 ViVj 관계를 나타내는 행렬의 원소를 Aij라고 할 때, 방향 간선이 있으면 행렬의 Aij = 1, 방향 간선이 없으면 행렬의 Aij = 0 으로 나타낸다.\r\n- 무방향 그래프에서 Vi와 Vj가 서로 인접하면 Aij = 1, 서로 인접하지 않으면 Aij = 0으로 나타낸다.\r\n- 여기서 i, j는 첨자 (A₃의 3과 같음)\r\n\r\n# 정렬(Sort)\r\n\r\n- 정렬 알고리즘 선택 시 고려사항 : 데이터의 양, 초기 데이터의 배열 상태, 키 값들의 분포 상태, 사용 컴퓨터 시스템의 특성\r\n- 종류 : 내부 정렬(장치에서 정렬이 이루어짐), 외부 정렬(보조 기억 장치에서 정렬이 이루어짐)\r\n\r\n### 삽입 정렬(Insertion Sort)\r\n\r\n- 정렬된 파일에 새로운 하나의 레코드를 순서에 따라 삽입시켜 정렬하는 방법\r\n\r\n### 선택 정렬(Selection Sort)\r\n\r\n- n개의 레코드 중에서 최소값(또는 최대값)을 찾아 1st 레코드 위치에 놓고, 나머지 (n-1) 개의 레코드 중에서 최소값(또는 최대값)을 찾아 2nd 레코드 위치에 놓는 방법을 반복하여 정렬하는 방법이다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n²)\r\n\r\n### 병합 정렬(2-Way Merge Sort)\r\n\r\n- 두 개의 키들을 한 쌍으로 하여 각 쌍에 대해 순서를 정한다.\r\n- 순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브 리스트로 만든다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n log₂ n)\r\n\r\n### 퀵 정렬(Quick Sort)\r\n\r\n- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어가면서 정렬하는 방법으로, 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽에 모이도록 서로 교환시키는 부분 교환 정렬법이다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n log₂ n), 약=O(n²)\r\n\r\n### 힙 정렬(Heap Sort)\r\n\r\n- 전이진 트리를 이용하여 정렬하는 방법이다.\r\n- 정렬한 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다.\r\n- 평균 수행 시간 복잡도는 O(n log₂ n)이고, 최악의 수행 시간 복잡도는 O(log₂ n)이다.\r\n- 입력 자료의 레코드를 완전 이진 트리(Complete Binary Tree)로 구성한다.\r\n\r\n# 검색(Search)과 해싱(Hashing)\r\n\r\n### 검색\r\n\r\n- 기억 공간 내 기억된 자료 중에서 주어진 조건을 만족하는 자료를 찾는 것\r\n\r\n- 이분 검색(Binary Search, 이진 검색)\r\n  - 이분 검색을 실행하기 위한 전제 조건은 자료가 순차적으로 정렬되어 있어야 한다.\r\n  - 탐색 효율이 좋고 탐색 시간이 적게 소요된다.\r\n  - 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.\r\n- 선형 검색(Linear Search)\r\n  - 순차 검색(Sequential Search)이라고도 한다.\r\n  - 주어진 자료에서 원소를 첫 번째 레코드부터 순차적으로 비교하면서 해당키 값을 가진 레코드를 찾아내는 가장 간단한 검색 방법이다.\r\n  - 데이터를 특별히 조직화할 필요가 없고 다양한 상황에서도 사용될 수 있는 장점이 있지만 N개의 입력 자료에 대해서 평균적으로 (n+1)/2번의 비교를 해야 하므로 비효율적이다.\r\n- 피보나치 검색(Fibonacci Search)\r\n  - 이진 검색과 비슷한 원리로, 비교 대상 기준을 피보나치 수열로 결정한다.\r\n  - 피보나치 수열 : 1,2,3,5,8,11~로 앞의 두 수의 합이 다음 번 값이 된다.\r\n- 블록 검색\r\n  - 전체 레코드를 일정한 블록으로 분리한 뒤 각 블록 내의 키값을 순서대로 비교하여 원하는 값을 찾는 기법이다.\r\n- 이진 트리 검색\r\n  - 레코드를 2진 트리로 구성하여 검색하는 방식으로 데이터를 입력하는 순서대로 첫 번째 값을 근노드로 지정하고 근노드보다 작으면 왼쪽, 크면 오른쪽에 연결하여 구성한다.\r\n\r\n### 해싱\r\n\r\n- 해싱 함수(Hashing Function)를 이용하여 레코드키에 대한 해시 테이블(Hash Table) 내의 홈 주소(Home Address)를 계산하여 주어진 레코드에 접근하는 방식이다.\r\n- 직접 접근(Direct Access Method) 파일을 구성할 때 사용된다.\r\n- 속도는 가장 빠르지만 충돌 현상 시 오버플로우 해결의 부담이 가중되며, 많은 기억 공간을 요구한다.\r\n\r\n- 제산 방법(Division Method)\r\n  - 해싱 함수 기법에서 키값을 양의 정수인 소수로 나누어 나머지를 홈주소로 취하는 방법이다.\r\n- 중간 제곱 방법(Mid-Square Method)\r\n  - 레코드 키값을 제곱하고 나서 그 중간 부분의 값을 주소로 계산하는 방법이다.\r\n  - 해시 테이블의 크기에 따라서 중간 부분의 적당한 자릿수를 선택할 수 있다.\r\n  - 비트 단위로 n 자릿수를 중간 위치 자릿수로 가정하면 해시 테이블의 크기는 2n이다.\r\n- 중첩 방법(Folding Method)\r\n  - 해싱 함수 중 주어진 키를 여러 부분으로 나누고, 각 부분의 값을 더하거나 배타적 논리합(XOR: Exclusive OR) 연산을 통하여 나온 결과로 주소를 취하는 방법이다.\r\n- 기수 변환 방법(Radix Conversion Method)\r\n  - 해싱 함수 기법 중 어떤 진법으로 표현된 주어진 레코드 키값을 다른 진법으로 간주하고 키값을 변환하여 홈주소로 취하는 방식이다.\r\n- 계수 분석 방법(Digit Analysis Method)\r\n  - 주어진 모든 키값들에서 그 키를 구성하는 자릿수들의 분포를 조사하여 비교적 고른 분포를 보이는 자릿수들을 필요한 만큼 택하는 방법을 취하는 해싱 함수 기법이다.\r\n\r\n# 데이터베이스(Database) ★★★\r\n\r\n### 데이터베이스의 정의\r\n\r\n- 통합된 데이터(Integrated Data) : 각 사용자의 데이터를 한 곳에 모아 통합한 데이터이다.\r\n- 저장된 데이터(Stored Data) : 데이터베이스는 컴퓨터 하드웨어 저장 장치에 저장되어 있는 데이터이다.\r\n- 운영 데이터(Operational Data) : 데이터베이스는 어떤 조직의 고유 기능을 수행하기 위해 반드시 필요한 데이터이다.\r\n- 공용 데이터(Shared Data) : 데이터베이스를 여러 사용자가 공동 소유/관리/활용하는 데이터이다.\r\n\r\n### 데이터베이스의 특성\r\n\r\n- 실시간 접근성(Real Time Accessibility) : 수시적이고 비정형적인 질의에 대하여 실시간 처리로 응답할 수 있어야 한다.\r\n- 내용에 의한 참조(Content Reference) : 데이터베이스의 데이터는 그 주소나 위치에 의해 참조되는 것이 아니라 내용을 참조한다.\r\n- 동시 공유(Concurrent Sharing) : 같은 내용의 데이터를 여러 사람이 동시에 공용할 수 있다.\r\n- 계속적 변화(Continuous Evolution) : 데이터베이스는 데이터의 삽입, 삭제, 갱신으로 내용이 계속적으로 변한다.\r\n- 구성 : DBMS, 스키마, 데이터베이스 언어, 데이터베이스 사용자로 구성되어있다.\r\n\r\n## DBMS(DataBase Management System, 데이터베이스 관리 시스템)\r\n\r\n- 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다.\r\n- 응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리한다.\r\n- 데이터베이스의 구성, 접근 방법, 관리 유지에 대한 모든 책임을 진다.\r\n\r\n### DBMS의 필수 기능\r\n\r\n- 정의 기능(Definition Facility)\r\n  - 데이터베이스 구조를 정의한다.\r\n  - 데이터의 논리적 구조와 물리적 구조 사이에 변환이 가능하도록 두 구조 사이의 사상(Mapping)을 명시한다.\r\n- 조작 기능(Manipulation Facility)\r\n  - 데이터베이스에 접근하여 데이터의 검색/삽입/삭제/갱신 등의 연산 적업을 하기 위한 사용자와 데이터베이스 사이의 인터페이스 수단을 제공한다.\r\n- 제어 기능(Control Facility)\r\n  - 데이터베이스에 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 무결성이 유지되도록 제어해야 한다.\r\n  - 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안(Security)을 유지하고, 권한(Authority)을 검사할 수 있어야 한다.\r\n  - 여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때 처리 결과가 항상 정확성을 유지하도록 병행 제어를 할 수 있도록 한다.\r\n\r\n### DBMS의 장/단점\r\n\r\n- 장점\r\n  - 데이터의 중복 및 종속성 최소화\r\n  - 데이터 공유\r\n  - 데이터 무결성 및 일관성 유지\r\n  - 데이터 보안 보장 용이\r\n- 단점\r\n  - 예비와 회복 기법이 어려움\r\n  - 데이터베이스 전문가 부족\r\n  - 시스템이 복잡하고, 전산화 비용 증가\r\n\r\n### 데이터베이스 용어(일부)\r\n\r\n- 빅데이터 : 데이터의 생성 양, 주기, 형식 등이 기존 데이터에 비해 매우 크기 때문에, 종래의 방법으로는 수집/저장/검색/분석이 어려운 방대한 데이터이다.\r\n- 데이터 마이닝 : 데이터웨어하우징에서 수집되고 분석된 자료를 사용자에게 제공하기 위해 분류 및 가공되는 요소 기술이다.\r\n- Hadoop : 일반 컴퓨터로 가상화된 대형 스토리지를 구현한다. 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 빅데이터 분산 처리를 돕는 자바 소프트웨어 오픈소스 프레임워크이다.\r\n\r\n## 데이터베이스의 구성\r\n\r\n### 스키마\r\n\r\n- 데이터베이스의 구조(개체, 속성, 관계)에 대한 정의이다.\r\n\r\n#### 스키마의 3계층\r\n\r\n- 외부 스키마(External Schema)\r\n  - 사용자나 응용 프로그래머가 접근할 수 있는 정의르 기술한다.\r\n- 개념 스키마(Conceptual Schema)\r\n  - 데이터베이스 전체를 정의한 것으로 데이터 개체, 관계, 제약조건, 접근 권한, 무결성 규칙 등을 명세한 것이다.\r\n  - 범기관적 입장에서 데이터베이스를 정의한다.\r\n- 내부 스키마(Internal Schema)\r\n  - 데이터의 실제 저장 방법을 기술한다.\r\n  - 물리적 저장 장치의 입장에서 본 데이터베이스 구조로써 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.\r\n\r\n### 데이터베이스 언어(Database Language)\r\n\r\n- 데이터 정의어(DDL : Data Definition Language)\r\n  - 데이터베이스의 객체들, 즉 테이블, 뷰, 인덱스 등에 대한 구조인 스키마를 정의하고 변경하며 삭제할 수 있는 기능이 있다.\r\n  - 논리적 데이터 구조와 물리적 데이터 구조 간의 사상 정의이다.\r\n  - 번역한 결과가 데이터 사전에 저장된다.\r\n- 데이터 조작어(DML : Data Manipulation Language)\r\n  - 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.\r\n  - 데이터의 검색/삽입/삭제/변경을 구행한다.\r\n- 데이터 제어어(DCL : Data Control Language)\r\n  - 불법적인 사용자로부터 데이터를 보호한다.\r\n  - 무결성을 유지한다.\r\n  - 데이터 회복 및 병행 제어를 수행한다.\r\n\r\n## 데이터베이스 모델\r\n\r\n- 데이터 모델 : 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구이다.\r\n\r\n### 데이터 모델의 구성 요소\r\n\r\n- 데이터 구조(Structure) : 데이터 구조 및 정적 성질을 표현한다.\r\n- 연산(Operations) : 데이터의 인스턴스에 적용 가능한 연산 명세와 조작 기법을 표현한다.\r\n- 제약조건(Constraints) : 데이터의 논리적 제한 명시 및 조작의 규칙이다.\r\n\r\n### 데이터 모델의 구분\r\n\r\n- 데이터베이스 모델\r\n  - 개념적 모델\r\n    - ERD(Entity Relationship Diagram)\r\n  - 논리적 모델\r\n    - 계층형\r\n    - 네트워크(망)형\r\n    - 관계형\r\n    - 객체지향형\r\n\r\n#### 개념적 데이터 모델\r\n\r\n- 속성들로 기술된 개체 타입과 이 개체 타입 간의 관계를 이용하여 현실 세계를 표현하는 방법이다.\r\n- E-R 모델(Entity-Relationship 모델 , 개체-관계 모델)\r\n  - 대표적인 개념적 데이터 모델이다.\r\n  - 개체 타입과 이들 간의 관계 타입을 이용하여 현실 세계를 개념적으로 표현한 방법이다.\r\n  - E-R 다이어그램 : E-R 모델을 그래프 방식으로 표현하였다.\r\n\r\n#### 논리적 데이터 모델\r\n\r\n- 필드로 기술된 데이터 타입과 이 데이터 타입 간의 관계 현실 세계를 표현하는 방법이다.\r\n- 종류\r\n  - 관계형 데이터 모델 : 데이터베이스를 테이블(Table)의 집합으로 표현한다.\r\n  - 계층형 데이터 모델 : 데이터베이스를 트리(Tree) 구조로 표현한다.\r\n  - 네트워크형 데이터 모델 : 데이터베이스를 그래프(Graph) 구조로 표현(owner-member 관계)하며, CODASYL DBTG 모델이라고도 한다.\r\n\r\n## 관계형 데이터베이스 모델\r\n\r\n- 관계형 데이터베이스를 구성하는 개체나 관계를 릴레이션(Relation)으로 표현한다.\r\n\r\n### 관계형 데이터베이스 모델 구조\r\n\r\n| 속성(Attribute) |  학번   | 이름 |     학과     | 학년 |\r\n| :-------------: | :-----: | :--: | :----------: | :--: |\r\n|   튜플(Tuple)   | 2024010 |  A   |   심리학과   |  1   |\r\n|      튜플       | 2025015 |  B   |  전자공학과  |  2   |\r\n|      튜플       | 2026016 |  C   | 컴퓨터공학과 |  3   |\r\n\r\n- 튜플(Tuple)\r\n  - 테이블의 행(Row)에 해당하며 파일 구조의 레코드(Record)와 같은 의미이다.\r\n  - 카디널리티(Cardinality) : 튜플의 수(기수)\r\n  - 한 릴레이션의 튜플들의 값은 모두 상이하며, 튜플 간 순서가 없다.\r\n- 속성(Attribue)\r\n  - 테이블의 열(Column)에 해당하며 파일 구조의 항목(Item), 필드(Field)와 같은 의미이다.\r\n  - 차수(Degress) : 속성의 수\r\n  - 한 릴레이션의 속성은 원자값이며, 속성 간 순서가 없다.\r\n- 도메인(Domain) : 하나의 속성이 가질 수 있는 원자값들의 집합이다.\r\n\r\n### 릴레이션의 특징\r\n\r\n- 튜플의 유일성 : 모든 튜플은 서로 다른 값을 갖는다.\r\n- 튜플의 무순서성 : 하나의 릴레이션에서 튜플의 순서는 없다.\r\n- 속성의 원자성 : 속성은 원자값을 갖는다.\r\n- 속성의 무순서성 : 각 속성은 릴레이션 내에서 유일한 이름을 가지며, 속성의 순서는 큰 의미가 없다.\r\n\r\n## 키(Key)의 종류와 무결성\r\n\r\n### 키의 분류\r\n\r\n| 학번 | 주민번호 | 이름 | 나이 | \u003c-학생---수강-\u003e | 학번 |      과목      |\r\n| :--: | :------: | :--: | :--: | :-------------: | :--: | :------------: |\r\n|  1   | 123123-1 |  A   |  10  |       ---       |  1   |    운영체제    |\r\n|  2   | 123123-1 |  B   |  20  |       ---       |  2   | 소프트웨어공학 |\r\n|  3   | 123123-1 |  C   |  30  |       ---       |  3   |     C언어      |\r\n\r\n- 슈퍼키(Super Key)\r\n  - 두 개 이상의 속성으로 구성된 키 또는 혼합키를 의미한다.\r\n  - 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는다.\r\n- 외래키(Foreign Key)\r\n  - 다른 테이블의 기본키로 사용되는 속성이다.\r\n  - \u003c수강\u003e 테이블에서 \u003c학생\u003e 테이블을 참조할 때 \u003c학생\u003e 테이블의 학번은 참조키, \u003c수강\u003e 테이블의 학번이 외래 키가 된다.\r\n- 무결성(Integrity)\r\n  - 릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션을 조작하는 과정에서의 의미전 관계 (Semantic Relationship)를 명세한 것으로 정의 대항으로 도메인, 키, 종속성 등이 있다.\r\n  - 개체 무결성 : 기본키의 값은 Null 값이나 중복 값을 가질 수 없다는 제약조건이다.\r\n  - 참조 무결성 : 릴레이션 R1에 속성 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 한다. 이때 참조할 수 없는 외래키 값을 가질 수 없다는 제약조건이다.\r\n  - 도메인 무결성 : 릴레이션 중 하나의 속성은 반드시 원자 값이어야 한다는 것을 보장하는 제약조건이다.\r\n\r\n# 데이터베이스 설계와 구조화\r\n\r\n### 데이터베이스 설계 단계\r\n\r\n1. 요구조건 분석\r\n   - 데이터베이스 사용자로부터 요구조건 수집과 요구조건 명세서를 작성한다.\r\n2. 개념적 설계\r\n   - 목표 DBMS에 독립적인 개념 스키마를 설계한다.\r\n   - 개념 스키마 모델링(ERD)과 트랜잭션 모델링을 병행 수행한다.\r\n3. 논리적 설계\r\n   - 목표 DBMS에 종속적인 논리적 스키마를 설계한다.\r\n   - 스키마의 평가 및 정제를 한다.\r\n   - 논리적 데이터 모델로 변환 및 트랜잭션 인터페이스를 설계한다.\r\n4. 물리적 설계\r\n   - 목표 DBMS에 종속적인 물리적 구조를 설계한다.\r\n   - 저장 레코드 양식 설계와 레코드 집중의 분석/설계, 엑세스 경로 인덱싱, 클러스터링, 해싱 등의 설계가 포함된다.\r\n   - 접근 경로 설계 및 트랜잭션 세부 설계를 한다.\r\n5. 데이터베이스 구현\r\n   - 목표 DBMS의 DDL(데이터 정의어)로 스키마를 작성한다.\r\n   - 데이터베이스에 등록 후 트랜잭션을 작성한다.\r\n\r\n### 데이터베이스 정규화\r\n\r\n- 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다.\r\n- 좋은 데이터베이스 스키마를 생성하고 불필요한 데이터의 중복을 방지하여 정보 검색을 용이하게 할 수 있도록 허용한다.\r\n\r\n#### 정규화의 목적\r\n\r\n- 데이터 구조의 안정성 최대화\r\n- 중복 데이터의 최소화\r\n- 수정 및 삭제 시 이상 현상 최소화\r\n- 테이블 불일치 위험 간소화\r\n\r\n### 이상 현상(Anomaly)\r\n\r\n- 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미한다.\r\n- 종류\r\n  - 삽입 이상(Insertion Anomaly) : 데이터를 삽입할 떄 불필요한 데이터가 함께 삽입되는 현상\r\n  - 삭제 이상(Deletion Anomaly) : 릴레이션의 한 튜플을 삭제함으로써 연쇄 삭제로 인해 정보의 손실을 발생시키는 현상\r\n  - 갱신 이상(Update Anomaly) : 튜플 중에서 일부 속성을 갱신함으로써 정보의 모순성이 발생하는 현상\r\n\r\n# 정규화\r\n\r\n### 정규화 과정\r\n\r\n1. 비정규 릴레이션\r\n2. 1NF(도메인이 원자값)\r\n3. 2NF(부분적 함수 종속 제거)\r\n4. 3NF(이행적 함수 종속 제거)\r\n5. BCNF(결정자이면서 후보키가 아닌 함수 종속 제거)\r\n6. 4NF(다치 종속 제거)\r\n7. 6NF(조인 종속성 제거)\r\n\r\n### 반정규화(비정규화)\r\n\r\n- 정규화를 통하여 정합성과 데이터 무결성이 보장되지만, 테이블의 개수가 증가함에 따라 테이블 간의 조인이 증가하여 조회 성능이 떨어질 수 있는데, 이렇게 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능 향상과 개발(Development) 및 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다.\r\n- 반정규화 기법 : 테이블 반정규화, 컬럼 반정규화, 관계 반정규화\r\n- 테이블 반정규화 기법 : 테이블 병합, 테이블 분할, 테이블 추가\r\n- 테이블 추가 반정규화 유형 : 중복 테이블 추가, 집계 테이블 추가, 진행 테이블 추가, 부분 테이블 추가\r\n\r\n# SQL ★★★\r\n\r\n### SQL(Structured Query Language)\r\n\r\n- 관계형 데이터베이스의 표준 질의어\r\n- 종류\r\n  - DDL(데이터 정의어), DML(데이터 조작어), DCL(데이터 제어어)\r\n\r\n### DDL(Data Definition Language, 데이터 정의어)\r\n\r\n- 데이터베이스의 정의/변경/삭제에 사용되는 언어이다.\r\n- 논리적 데이터 구조와 물리적 데이터 구조로 정의할 수 있다.\r\n- 논리적 데이터 구조와 물리적 데이터 구조 간의 사상을 정의한다.\r\n- 번역한 결과가 데이터 사전에 저장된다.\r\n- 종류\r\n  - CREATE : 스키마, 도메인, 테이블, 뷰 정의\r\n  - ALTER : 테이블 정의 변경(필드 추가, 삭제, 갱신)\r\n  - DROP : 스키마, 도메인, 테이블, 뷰 삭제\r\n\r\n#### CREATE문 문법 구조\r\n\r\n- CREATE TABLE : 테이블을 생성하는 명령문\r\n\r\n```SQL\r\n\r\nCREATE TABLE 기본테이블\r\n    (\r\n        {열이름 데이터_타입 [NOT NULL] [DEFALUT 값]}\r\n        {[PRIMARY KEY(열이름_리스트)]},\r\n        {[UNIQUE(열이름_리스트,...)]},\r\n        {[FOREIGN KEY(열이름_리스트)]\r\n        REFERENCES 기본테이블[(기본키_열이름)]\r\n        [ON DELETE 옵션]\r\n        [ON UPDATE 옵션]}\r\n        [CHECK(조건식)]\r\n    );\r\n\r\n```\r\n\r\n- {}는 중복 가능한 부분\r\n- NOT NULL은 특정 열에 대해 NULL 값을 허용하지 않을 때 기술\r\n- PRIMARY KEY는 기본키를 구성하는 속성을 지정할 때 사용된다.\r\n- FOREIGN KEY는 외래키로 어떤 릴레이션의 기본키를 참조하는지를 기술한다.\r\n\r\n#### ALTER문 문법 구조\r\n\r\n- ALTER TABLE : 테이블 구조(필드 추가, 삭제, 변경) 변경문이다.\r\n\r\n```SQL\r\nALTER TABLE 테이블_이름 ADD 열_이름 데이터_타입 DEFAULT 값;\r\nALTER TABLE 테이블_이름 ALTER 열_이름 SET DEFAULT 값;\r\nALTER TABLE 테이블_이름 DROP 열_이름 CASCADE;\r\n```\r\n\r\n- ADD : 새로운 열(속성)을 추가할 때 사용한다.\r\n- ALTER : 특정 열(속성)의 디폴트 값을 변경할 때 사용한다.\r\n- DROP : 특정 열(속성)을 제거할 때 사용한다.\r\n\r\n#### DROP문 문법 구조\r\n\r\n- DROP : 테이블 삭제문\r\n\r\n```SQL\r\nDROP SCHEMA 스키마_이름 [CASCADE | RESTRICT];\r\nDROP DOMAIN 도메인_이름 [CASCADE | RESTRICT];\r\nDROP TABLE 테이블_이름 [CASCADE | RESTRICT];\r\nDROP INDEX 인덱스_이름;\r\n```\r\n\r\n- CASCADE : 옵션을 사용하면 삭제할 요소가 다른 개체에서 참조 중이라도 삭제가 수행된다.\r\n- RESTRICT : 옵션을 사용하면 삭제할 요소가 다른 개체에서 참조 중이라면 삭제가 수행되지 않는다.\r\n\r\n### DCL(Data Control Language, 데이터 제어어)\r\n\r\n- 데이터 제어 정의 및 기술에 사용되는 언어이다.\r\n- 불법적인 사용자로부터 데이터를 보호한다.\r\n- 무결성을 유지하고 데이터 복구 및 병행 제어를 한다.\r\n- 종류\r\n  - COMMIT : 명령어로 수행된 결과를 실제 물리적 디스크로 저장하고, 명령어로 수행을 성공적으로 완료하였음을 선언한다.\r\n  - ROLLBACK : 명령어로 수행에 실패하였음을 알리고, 수행된 결과를 원상 복귀시킨다.\r\n  - GRANT : 데이터베이스 사용자에게 사용 권한을 부여한다.\r\n  - REVOKE : 데이터베이스 사용자로부터 사용 권한을 취소한다.\r\n\r\n### DML(Data Maniqulation Language, 데이터 조작어)\r\n\r\n- 데이터의 검색/삽입/삭제/변경에 사용되는 언어이다.\r\n- 사용자와 DBMS 간의 인터페이스를 제공한다.\r\n- 종류\r\n  - SELECT\r\n    - 튜플 검색 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        SELECT 속성명[ALL | DISTINCT]\r\n        FROM 릴레이션명\r\n        WHERE 조건\r\n        [GROUP BY 속성명1, 속성명2, ... ]\r\n        [HAVING 조건]\r\n        [ORDER BY 속성명 [ASC | DESC]]\r\n    ```\r\n    - ALL : 모든 튜플을 검색(생략 가능)\r\n    - DISTINCT : 중복된 튜플 생략\r\n  - INSERT\r\n    - 튜플 삽입 명령어\r\n    - 기본 구조\r\n    ```SQL\r\n        INSERT INTO 테이블명(속성명1, 속성명2,...)\r\n        VALUES(데이터1, 데이터2 ...);\r\n    ```\r\n  - DELTETE\r\n    - 튜플 삭제 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        DELETE\r\n        FROM 테이블명\r\n        WHERE 조건;\r\n    ```\r\n  - UPDATE\r\n    - 튜플의 내용 변경 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        UPDATE 테이블명\r\n        SET 속성명 = 데이터\r\n        WHERE 조건;\r\n    ```\r\n\r\n### NoSQL\r\n\r\n- \"Not only SQL\"로, SQL만을 사용하지 않는 데이터베이스 관리 시스템(DBMS)을 지칭하며, 다양한 유형의 데이터베이스를 사용하는 것을 의미한다.\r\n- 데이터를 저장하는데 SQL 외에도 다른 방법도 있다는 개념하에 비정형 데이터의 저장을 위해 유연한 데이터 모델을 지원한다.\r\n- 전통적인 관계형 데이터베이스 관리 시스템과는 다른 비관계형(Non-Relational) DBMS이다.\r\n\r\n### 집계 함수\r\n\r\n- COUNT : 테이블의 행 수를 계산할 때 / 표현식: COUNT(\\*)\r\n- SUM : 하나 또는 여러 개의 열 합계를 구할 때 / 표현식 : SUM(열 이름)\r\n- AVG : 하나 또는 여러 개의 열 평균을 구할 때 / 표현식 : AVG(열 이름)\r\n- MAX : 해당 열의 최댓값을 구할 때 / 표현식 : MAX(열 이름)\r\n\r\n### HAVING 절을 사용한 조회 검색\r\n\r\n- GROUP BY절에 의해 선택된 그룹의 탐색 조건을 지정할 수 있으며 SUM, AVG, COUNT, MAX, MIN 등의 그룹 함수와 함께 사용할 수 있다.\r\n\r\n### ORDER BY 절을 이용한 정렬 검색\r\n\r\n- 특정 항목을 기준으로 검색 테이블의 행들을 오름차순(ASC) 또는 내림차순(DESC)으로 정렬할 때 사용한다. 생략하면 ASC가 디폴트 값이 되어 오름차순으로 정렬된다.\r\n\r\n# 트랜잭션 ★★★\r\n\r\n- 하나의 논리적 기능을 수행하기 위한 작업 단위이다.\r\n- 데이터베이스에서 일어나는 연산의 집합이다.\r\n\r\n### 트랜잭션의 특성\r\n\r\n- 원자성(Atomicity)\r\n  - 완전하게 수행이 완료되지 않으면 전혀 수행되지 않아야 한다.\r\n  - 연산은 Commit, Rollback을 이용하여 적용 또는 취소로 한꺼번에 완료되어야 한다.\r\n  - 중간에 하나의 오류가 발생되더라도 취소가 되어야 한다.\r\n- 일관성(Consistency)\r\n  - 시스템의 고정 요소는 트랜잭션 수행 전후가 같아야 한다.\r\n  - 트랜잭션 결과는 일관성을 유지해야 한다.\r\n- 격리성(Isolation, 고립성)\r\n  - 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 한다.\r\n- 영속성(Durability, 지속성)\r\n  - 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억된다.\r\n  - 은행계좌에서 100원 중 10원을 인출했을 때 계좌에는 90원이 남아 있어야 한다.\r\n\r\n# 보안과 권한 부여\r\n\r\n- 보안(Security)의 개념 : 권한이 없는 사용자로부터 데이터베이스를 보호하는 것\r\n\r\n### 권한 부여/회수\r\n\r\n#### GRANT\r\n\r\n- 데이터베이스 사용자에게 사용 권한을 부여한다.\r\n- 기본 구조\r\n  ```SQL\r\n      GRANT 권한 ON 데이터 객체 TO 사용자 [WITH GRANT OPTION];\r\n  ```\r\n- WITH GRANT OPTION : 사용자가 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여한다.\r\n- 부여 가능한 권한 : Update, Delete, Insert, Select\r\n\r\n#### REVOKE\r\n\r\n- 데이터베이스 사용자로부터 사용 권한을 취소한다.\r\n- 기본 구조\r\n  ```SQL\r\n      REVOKE [GRANT OPTION FOR] 권한 ON 데이터 객체 FROM 사용자 [CASCADE];\r\n  ```\r\n- GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소한다.\r\n- CASCADE : 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄 취소한다.\r\n- 부여 가능한 권한 : Update, Delete, Insert, Select\r\n\r\n# 암호화\r\n\r\n- 네트워크를 통하거나 컴퓨터 내부에 자료를 저장할때 권한을 가진 사람 외에는 데이터를 보지 못하도록 하는 것\r\n- 일반 평문을 다양한 방식의 암호화 기법으로 가공하여 저장하거나 전송 권한이 있는 사용자에 의해 복호화되어 사용한다.\r\n\r\n암호화 과정 : 평문 =\u003e 암호화(암호키) =\u003e 암호문 =\u003e 복호화(복호키) =\u003e 평문\r\n\r\n### 암호화 기법\r\n\r\n- 비밀키(Private Key, 대칭키) 암호화 기법\r\n  - 비밀키 암호화 기법을 동일한 키로 데이터를 암호화하고 복호화한다.\r\n  - 암호화, 복호화 키가 같아서 키를 공개하면 타인이 알게 된다.\r\n  - 암호화와 복호화 속도가 빠르다.\r\n- 공개키(Public Key, 비대칭키) 암호화 기법\r\n  - 공개키 암호화 기법은 각기 다른 키로 데이터를 암호화하고 복호화한다.\r\n  - 암호화, 복호화 키가 다르므로 키는 공개되어도 된다.\r\n  - 암호화 및 복호화 속도가 느리다.\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n"},{"title":"sw first test2","description":"정보처리기사 필기(2) - 소프트웨어 개발","category":"sw","date":"2023-12-25","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 단위 모듈\r\n\r\n- 소프트웨어 구현에 필요한 다양한 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것을 의미한다.\r\n- 사용자 또는 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램이다.\r\n- 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입될 수 있다.\r\n- 두 개의 단위 모듈이 합쳐지면 두 개의 기능들을 같은 모듈로 구현할 수 있다.\r\n- 종류 : 화면, DB접근, 인터페이스, 비즈니스 트랜잭션, 데이터 암호화 등\r\n\r\n### 모듈화의 원리\r\n\r\n- 소프트웨어 개발에 있어 기능을 나누고 추상화하여 소프트웨어의 성능을 향상시키고 유지보수를 효과적으로 구현하기 위한 기법을 의미한다.\r\n- 종류\r\n  - 분할과 지배(Dibide Conquer) : 복잡한 문제를 분해, 모듈 단위로 문제를 해결한다.\r\n  - 정보 은폐(Information Hiding) : 어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 은폐시킨다.\r\n  - 자료 추상화(Data Abstraction) : 함수 내에 자료 구조의 표현 명세를 은폐, 자료와 자료에 적용 가능한 오퍼레이션을 함께 정의한다.\r\n  - 모듈의 독립성(Module Independence) : 낮은 결합도, 높은 응집도를 갖도록 한다.\r\n\r\n### 단위 모듈 테스트\r\n\r\n- 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것이다.\r\n- 화이트박스 테스트와 블랙박스 테스트 기법이 있다.\r\n\r\n### 구현 단계의 작업 절차\r\n\r\n코딩 계획 =\u003e 코딩 =\u003e 컴파일 =\u003e 테스트\r\n\r\n# 통합 개발 환경\r\n\r\n### IDE(Integrated Development Environment)\r\n\r\n- C++, JAVA 등의 언어를 이용한 소프트웨어 개발 단계에서 패키지 인크루딩, 소스 코드 편집, 컴파일, 디버깅, 바이너리 배포 등 모든 작업을 통합 지원한다.\r\n- 편집기, 컴파일러, 디버거 등의 다양한 도구를 하나의 인터페이스로 통합하여 제공한다.\r\n- 오류 체크를 시각화하여 확인 및 수정을 쉽도록 지원한다.\r\n- 컴파일에 필요한 외부 추가 기능을 연계하여 개발의 편의성을 높였다.\r\n- 종류 : 이클립스, 비주얼 스튜디오, XCode, 안드로이드 스튜디오, IDEA, VSC 등\r\n\r\n### 빌드 자동화 도구\r\n\r\n- 소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만든다.\r\n- 소프트웨어 개발자가 반복 작업해야 하는 코딩을 잘 짜여진 프로세스를 통해 자동으로 실행하여, 신뢰성 있는 결과물을 생산해 낼 수 있는 작업 방식 및 방법이다.\r\n- 소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 생성하는 프로그램이며, 지속해서 증가하는 라이브러리의 자동 추가 및 관리(전처리, Preprocessing)를 지원한다.\r\n- 최근에는 오픈소스인 Gradle이 등장했으며, 구글이 안드로이드의 기본 빌드 시스템으로 Gradle을 선택하면서 사용자가 급증하였다.\r\n- 기능 : 코드 컴파일, 컴포넌트 패키징, 파일 조작, 개발 테스트 실행, 버전 관리 도구 통합, 문서 생성, 배포 기능, 코드 품질 분석\r\n- 프로세스 : 컴파일 =\u003e 패키징 =\u003e 단위 테스트 =\u003e 정적 분석 =\u003e 리포팅 =\u003e 배포 =\u003e 최종 빌드\r\n- 종류 : Gradle, Jenkins, Makefile, Ant, Maven 등\r\n\r\n# 제품 소프트웨어 패키징\r\n\r\n### 애플리케이션 패키징(배포)\r\n\r\n- 개발이 완료된 소프트웨어를 고객에게 인도하기 위해 패키징하고, 설치 메뉴얼, 사용 메뉴얼 등을 작성하는 일련의 배포용 설치 파일을 만드는 작업을 의미한다.\r\n- 패키징 시 사용자 시스템의 환경, 직관적 UI, 관리 서비스 형태 제공, 패키징 변경 및 개선 관리를 통한 안정적 배포를 고려해야 한다.\r\n\r\n### 패키징 프로세스\r\n\r\n- 기능 식별\r\n  - 입/출력 데이터를 식별하고 전체적인 기능 정의 및 데이터 흐름을 식별한다.\r\n  - 기능 단위 및 출력에 대하여 상세 정의한다.\r\n- 모듈화\r\n  - 모듈화를 위하여 모듈 간 결합도와 응집도를 분석한다.\r\n  - 분류할 수 있는 기능 단위 및 서비스 단위를 모듈 별로 분류한다.\r\n  - 공유 가능한 기능과 재활용 기능을 분류한다.\r\n- 빌드 진행\r\n  - 신규 개발 소스 및 컴파일 결과물을 준비한다.\r\n  - 정상적으로 빌드되는 기능 단위 및 서비스를 분류한다.\r\n  - 빌드 도구를 선별하여 선택하고, 해당 빌드 도구를 이용하여 빌드를 수행한다.\r\n  - 컴파일 회의 에디터 등의 관련 도구 기능을 확인한다.\r\n- 사용자 환경 분석\r\n  - 고객의 편의를 위하여 최소 사용자 환경 사전을 정의한다.\r\n  - 다양한 사용자 환경 테스트를 수행한다.\r\n- 패키지 적용 시험\r\n  - 실 사용자 환경에서의 패키징 적용을 테스트한다.\r\n  - 사용자 관점에서 UI 및 시스템상의 편의성을 점검한다.\r\n- 패키징 변경 개선\r\n  - 사용자 관점에서 패키징 적용 시 개선점을 도출하여 서비스 가능한 수준의 개선 후 개선 버전을 다시 패키징한다.\r\n\r\n### 패키징 도구의 구성요소\r\n\r\n|              구성              | 특징                                                                                                                                                          |\r\n| :----------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n|      암호화 (Encryptoin)       | 콘텐츠 및 라이센스를 암호화하고, 전자 서명을 할 수 있는 기술이다. (ex. PKI, Symmetric/Asymmetric Encryption, Digital) Signature                               |\r\n|    키 관리 (Key Management)    | 콘텐츠를 암호화한 키에 대한 저장 및 배포 기술이다. (관리 방식 : 분산형, 중앙)집중형                                                                           |\r\n|  암호화 파일 생성 (Packager)   | 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술이다. (ex. Pre-packaging, On-the-fly) Packaging                                                                  |\r\n|   식별 기술 (Identificatoin)   | 콘텐츠에 대해 식별하고 체계화하는 기술이다. (ex. DOI, URI)                                                                                                    |\r\n| 저작권 표현 (Right Expression) | 저작권의 라이센스 내용을 표현하는 기술이다. (ex. XrML/MPGE-21 REL, ODRL)                                                                                      |\r\n| 정책 관리 (Policy Management)  | 라이센스 발급 및 사용에 대한 정책 표현 및 관리 기술이다. (ex. XML, Contents Management) System                                                                |\r\n| 크랙 방지 (Tamper Resistance)  | 크랙에 의한 콘텐츠 사용 방지 기술이다.(Code Obfuscation, Kernel Debugger Detection, Module Certification) (ex. Secure DB, Secure Time Management, Encryption) |\r\n|     인증 (Authentication)      | 라이센스 발급 및 사용의 기준이 되는 사용자 인증 기술이다. (ex. User/Device Authentication, SSO, Digital Certificate)                                          |\r\n\r\n# 릴리즈 노트\r\n\r\n- 애플리케이션 최종 사용자인 고객에게 제공하는 잘 정리된 배포 정보 문서이다.\r\n- 애플리케이션 릴리즈 노트에는 상세 서비스를 포함하여 수정/변경된 정보를 담고 있는 문서이다.\r\n- 사용자에게 최종 배포된 릴리즈 노트를 보면 테스트가 어떻게 진행됐는지, 개발팀의 제공 사양을 얼마나 준수했는지를 확인해 볼 수 있다.\r\n- 전체적인 버전 관리 및 릴리즈 정보를 체계적으로 관리할 수 있다.\r\n- 릴리즈 노트는 현재 시제로 개발팀에서 직접 작성하여야 하며, 명확하고 정확하며 완전한 정보를 제공해야 한다.\r\n- 개발자와 테스터가 함께 협업해야 하고 최초 및 변경, 개선 항목까지 연결되어 다음 항목에 대한 정보들이 릴리즈 노트를 통해 작성되어야 한다.\r\n\r\n### 릴리즈 노트 작성 항목\r\n\r\n- 헤더(Header) : 문서명, 제품명, 배포 버전 번호, 릴리즈 날짜, 참고 날짜, 문서(릴리즈 노트) 버전 등\r\n- 개요 : 제품 및 변경에 대한 정보를 간략하게 작성한다.\r\n- 목적 : 제품의 버그 픽스(오류 수정)와 새로운 기능을 포함한 릴리즈의 새로운 사항의 나열과 더불어 릴리즈 노트의 목적에 대한 간략한 개요를 작성한다.\r\n- 이슈 요약 : 문제가 되는 버그의 간단한 설명과 개선사항 항목을 요약하여 작성한다.\r\n- 재현 항목 : 버그 발생을 재현하기 위한 절차이다.\r\n- 수정 및 개선 내용 : 수정 및 개선 내용을 간략하게 서술한다.\r\n- 최종 사용자 영향도 : 최종 사용자에게 필요한 조치로, 이 변경사항으로 인해 다른 기능이 영향을 받는지 간략히 서술한다.\r\n- 노트 : 소프트웨어 및 하드웨어 설치 항목, 제품, 문서를 포함한 업그레이드 항목을 서술한다.\r\n- 면책 조항 : 회사와 표준 제품과 관련된 메시지를 작성한다.(프리웨어, 불법 복제 금지 등)\r\n- 연락 정보 : 사용자 지원 및 문의 관련한 연락처 정보를 작성한다.\r\n\r\n### 릴리즈 노트 작성 순서\r\n\r\n1. 모듈 식별\r\n   - 모듈 및 빌드 수행 후 릴리즈 노트 기준의 항목을 순서대로 정리한다.\r\n   - 소스를 통하여 처리되는 입/출력 데이터의 형, 기능 정의, 데이터 흐름을 정리한다.\r\n   - 메인 함수 이외의 호출 함수를 정의하고 이에 대한 출력 값을 식별한다.(ex. I/O 데이터, Function Data Flow)\r\n2. 추가 개선 항목 식별\r\n   - 추가 개선에 따른 추가 항목을 식별하여 릴리즈 노트를 작성한다.\r\n   - 추가 개선에 대한 베타 버전을 이용 테스트 수행한다.\r\n   - 테스트 중 발생한 긴급 버그를 수정한다.\r\n   - 사용자 요청에 따른 추가 개선을 계획하고 수정한다.(ex. 베타 버전, 긴급 버그, 사용자 요청)\r\n\r\n# 형상관리 ★★★\r\n\r\n- 개발 단계에서 생성되는 모든 문서, 코드 등 소프트웨어의 변경사항을 체계적으로 관리하기 위하여 추적하고 통제하는 것이다.\r\n- 작업 산출물을 형상 항목(Configuration Item)이라는 형태로 선정하고, 형상 항목 간의 변경사항 추적과 통제 정책을 수립하고 관리한다.\r\n- 요구사항 변경 또는 오류로 지속해서 변화하는 자료이며, 이러한 변화를 이력화하여 유지보수성을 향상할 수 있다.\r\n- 소프트웨어는 눈으로 확인할 수 있는 가시성이 없으므로 개발 과정의 진행 정도를 확인하는 도구로 사용된다.\r\n- 단순 버전 관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간을 의미한다.\r\n\r\n### 형상 관리 항목(Configuration Item)\r\n\r\n- 개발 프로세스에서 생산되거나 사용되는 작업 산출물, 작업 산출물들의 집합체를 의미한다.\r\n- 대표적인 소프트웨어 형상 항목 : 프로젝트 요구 분석서, 운영 및 설치 지침서, 요구사항 명세서, 설계/인터페이스 명세서, 테스트 설계서, 소프트웨어 품질보증, 형상 관리, V \u0026 V 계획서(확인 및 검증)와 같은 계획서, 코드 모듈(소스와 오브젝트 모두)\r\n\r\n### 형상 관리 종류\r\n\r\n- 형상 관리는 버전관리, 리비전 관리, 변경 관리, 빌드 관리, 이슈 관리 등을 모두 포함한다.\r\n\r\n- 버전 관리\r\n  - 다양한 형상항목이 과거부터 현재에 이르기까지 요구사항 등의 변화에 따라 버전을 부여함으로써 이력을 관리하는 것이다.\r\n  - 버전을 통해 시간적인 변경사항과 해당 작업 담당자를 추적할 수 있다.\r\n- 변경 관리\r\n  - 변경된 요구사항에 대하여, 비용 및 기간 등을 고려하고 타당성을 평가한다.\r\n  - 요구사항이 타당한 경우 제품 또는 산출물을 변경하고, 그렇지 않을 경우 변경을 거부하는 활동이다.\r\n\r\n### 형상 관리의 필요성과 효과\r\n\r\n1. 형상관리의 필요성\r\n   - 이미 수정된 오류가 갑자기 다시 나타나거나, 사용하던 문서나 코드가 갑자기 사라지거나 찾을 수 없는 경우가 발생할 수 있다.\r\n   - 원시 코드와 실행 코드의 버전이 일치하지 않는다.\r\n   - 요구사항이 자주 변경되고, 변경이 어떤 결과를 가져올지 예측할 수 없다.\r\n   - 무엇을 변경해야 할지 막연하고, 따라서 변경에 대한 노력을 예측할 수 없다.\r\n   - 분산된 지역에서 소프트웨어를 병렬적으로 개발하기 어렵다.\r\n   - 제품 납기일을 맞추기가 어렵고, 프로젝트가 계획대로 잘 진행되고 있는지 모르겠다.\r\n2. 형상 관리의 효과\r\n   - 관리적 효과\r\n     - 표준 확입으로 전사적 IT 자원 관리가 쉬워, 기간별/팀별/업무별 산출물 현황 및 변경 이력 통계를 파악할 수 있다.\r\n     - 제품 개발 관련 산출물이 자동 생성되고 관리된다.\r\n     - 개발/유지보수 활동을 통합 관리할 수 있다.\r\n     - 변경 프로세스의 체계를 확립하고, 외주 개발 통제 및 현황 파악을 도와준다.\r\n   - 품질 향상 효과\r\n     - 산출물 버전 관리를 자동으로 생성 관리할 수 있어 결함 및 오류가 감소한다.\r\n     - 변경 프로그램의 이력 관리를 통하여 문제 파악 및 버그 수정이 쉬워지고, 변경 내용의 영향 분석이 쉬워진다.\r\n\r\n### 형상 관리 절차\r\n\r\n- 형상 관리는 최초 계획을 수립하고 형상 식별, 통제, 감사, 기록 및 보고와 같은 활동들을 통해 일련의 과정들을 거치게 된다.\r\n\r\n1. 형상 식별(Configuration Identification)\r\n   - 형상 관리의 가장 기본이 되는 활동으로 형상 관리 계획을 근거로 형상 관리의 대상이 무엇인지 식별하는 과정이다.\r\n   - 변경 추적성 부여와 대상 식별을 위해 ID와 관리 번호를 할당한다.\r\n   - 형상 항목 대상 : 품질 관리 계획서, 품질 관리 메뉴얼, 요구사항 명세서, 설계/인터페이스 명세서, 테스트 설계서, 소스 코드\r\n2. 형상 통제\r\n   - 형상통제위원회 운영을 통하여 변경 통제가 이루어져야 한다.\r\n   - 요구사항 변경 요구를 관리하고, 변경 제어, 형상 관리 등의 통제를 지원하고 기준선에 대한 관리 및 형상 통제를 수행할 수 있다.\r\n3. 형상 보고 및 감사\r\n   - 기준선의 무결성 평가 단계로서 개발자, 유지보수 담당자가 아닌 제3자의 객관적인 확인 및 검증 과정을 통해 새로운 형상의 무결성을 확보하는 활동이다. -형상 감사 시 고려사항 - 명시된 변경이 정확하게 수정되었는가? - 기술 검토를 수행하였는가? - 개발 프로세스를 준수하였는가? - 변경 발생 시, 형상 관리 절차를 준수하였는가? - 변경에 대한 정보(변경일, 변경인, 변경사항)를 기록하였는가?\r\n4. 형상 기록/보고\r\n   - 소프트웨어 개발 상태에 대한 보고서를 제공하는 단계로 기준선에 대한 변경과 처리 과정에서의 변경을 상태 보고에 모두 기록한다.\r\n   - 기록/보고 항목 : 승인된 형상 리스트, 계획된 변경 상태, 승인된 변경의 구현 상태\r\n\r\n### 형상 관리, 버전 관리, 변경 관리\r\n\r\n|                                               형상 관리 (Configuration Management)                                                |                                                        버전 관리 (Version Management)                                                         |                          변경 관리(Version Management)                          |\r\n| :-------------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------: |\r\n| 버전, 변경 관리 개념을 포함하고, 프로젝트 진행 상황, 빌드와 릴리즈 퍼블리싱까지 모두 관리할 수 있는 통합 시스템이라고 할 수 있다. | 변경 이력을 추적 관리하는 가장 좋은 방법이 버전으로 구분하는 것이다. 사소한 체크인, 체크아웃부터 릴리즈, 퍼블리싱의 과정을 버전으로 관리한다. | 소스 코드의 변경 상황을 관리한다. 문서의 변경 이력과 복원 등의 기능이 제공된다. |\r\n\r\n### 주요 버전 관리 도구\r\n\r\n- CVS(Concurrent Versions System)\r\n  - 동시 버전 시스템이다.\r\n  - 소프트웨어 프로젝트를 진행할 때, 파일로 이뤄진 모든 작업과 모든 변화를 추적하고, 여러 개발자가 협력하여 작업할 수 있게 한다.\r\n  - 오픈소스 프로젝트에서 널리 사용되었다.\r\n  - 최근에는 CVS가 한계를 맞아 이를 대체하는 Subversion이 개발되었다.\r\n- RCS(Revision Control System)\r\n  - CVS와의 차이점은 소스 파일의 수정을 한 사람만으로 제한한다.\r\n  - 다수의 사용자가 동시에 파일 수정을 할 수 없도록 파일 잠금 방식으로 버전을 관리하는 도구이다.\r\n- SubVersion(SVN)\r\n  - CVS보다 속도 개선, 저장 공간, 변경 관리 단위가 작업 모음 단위로 개선되었다. 2000년부터 콜랩넷에서 개발되었다.\r\n  - CVS와 사용 방법이 유사해 CVS 사용자가 쉽게 도입해 사용할 수 있다.\r\n  - 아파치 최상위 프로젝트로서 전 세계 개발자 커뮤니티와 함께 개발되고 있다.\r\n  - 디렉토리, 파일을 자유롭게 이동해도 버전 관리가 가능하다.\r\n  - repository(저장소) : 프로젝트의 파일 및 변경 정보가 저장되는 장소이다.\r\n  - trunk : 메인 개발 소스. 개발 소스를 커밋했을 때 개발 소스가 모이는 곳이다.\r\n  - branch : trunk에서 분기된 개발 소스로 실험적인 기능을 추가하거나, 출시를 위한 안정화 버전 작업을 할 때 사용한다.\r\n  - tag : 특정 시점에서 프로젝트의 스냅샷을 찍어 두는 것을 의미한다.\r\n- Bitkeeper\r\n  - SVN과 비슷한 중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도를 내도록 개발된 버전 관리 도구이다.\r\n- Git\r\n  - 프로그램 등의 소스 코드 관리를 위한 분산 저장소 방식 시스템이다.\r\n  - 리누스 토르발스가 리눅스 커널 개발에 이용하려고 개발하였으며, 현재는 다른 곳에도 널리 사용되고 있다.\r\n  - 지역 저장소와 원격 저장소 2개의 저장소가 존재한다.\r\n  - 지역 저장소에서 버전 관리가 진행되어 버전 관리가 빠르다.\r\n  - 깃의 작업 폴더는 모두 전체 기록과 각 기록을 추적할 수 있는 정보를 포함하고 있으며, 완전한 형태의 저장소이다.\r\n  - 네트워크에 접근하거나 중앙 서버에 의존하지 않는다.\r\n- Clear Case\r\n  - 복수 서버, 복수 클라이언트 구조이다.\r\n  - 서버 확장 요구가 있을 때 필요한 서버를 하나씩 추가할 수 있다.\r\n\r\n# 애플리케이션 테스트 관리 ★★★\r\n\r\n### 소프트웨어 테스트\r\n\r\n- 소프트웨어 개발 단계에서 사용자 요구사항에 서술된 동작과 성능, 사용성, 안정성 등을 만족하는지 확인하기 위하여 소프트웨어의 결함을 찾아내는 활동으로 품질 향상, 오류 발견, 오류 예방 관점에서 수행하는 행동이다.\r\n- 품질 향상 관점 : 반복적인 테스트를 거쳐 제품의 신뢰도를 향상하는 품질 보증 활동이다.\r\n- 오류 발견 관점 : 잠재된 오류를 발견하고 이를 수정하여 올바를 프로그램을 개발하는 활동이다.\r\n- 오류 예방 관점 : 코드 리뷰, 동료 검토, 인스펙션 등을 통해 오류를 사전에 발견하는 활동이다.\r\n\r\n### 소프트웨어 테스트의 원리\r\n\r\n- 테스팅은 결함이 존재함을 밝히는 활동이다.\r\n  - 소프트웨어의 잠재적인 결함을 줄일 수 있지만, 결함이 발견되지 않아도 결함이 없다고 증명할 수 없음을 나타낸다.\r\n- 완벽한 테스팅은 불가능하다.\r\n  - 무한 경로, 무한 입력값, 무한 시간이 소요되어 완벽하게 테스트할 수 없으므로 리스크 분석과 우선순위를 토대로 테스트에 집중하는 것을 의미한다.\r\n- 테스팅은 개발 초기에 시작해야 한다.\r\n  - 애플리케이션의 개발 단계에 테스트를 계획하고 SDLC(Software Development Life Cycle)의 각 단계에 맞춰 전략적으로 접근하는 것을 고려하라는 뜻이다.\r\n- 결함 집중(Defect Clustering)\r\n  - 애플리케이션 결함의 대부분은 소수의 특정한 모듈에 집중되어 존재한다. 파레토 법칙이 좌우한다.\r\n- 살충제 역설(Pesticide Paradox)\r\n  - 동일한 테스트 케이스로 반복 테스트 시 결함을 발견할 수 없으므로 주기적으로 테스트 케이스를 리뷰하고 개선해야 한다.\r\n- 테스팅은 정황(Context)에 의존한다.\r\n  - 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행하여야 한다.\r\n- 오류 부재의 궤변(Absence of Errors Fallacy)\r\n  - 사용자의 요구사항을 만족하지 못하는 오류를 발견하고 그 오류를 제거하였다 해도, 해당 애플리케이션의 품질이 높다고 말할 수 없다.\r\n\r\n### 파레토의 법칙(Law of Pareto)\r\n\r\n- 80 대 20 법칙 또는 2:8 법칙이라고도 한다. 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상을 가리킨다. 예를 들어 20%의 VIP 고객이 백화점 전체 매출의 80%에 해당하는 만큼 쇼핑하는 현상을 의미한다.\r\n\r\n### 테스트 케이스(Test Case)\r\n\r\n- 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미한다.\r\n- 명세 기반 테스트의 설계 산출물이다. (명세 기반 테스트 : 테스트 수행의 증거로도 활용되며, 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 구현하고 있는지 확인)\r\n- 테스트 케이스를 설계 단계에 작성하면 테스트 시 오류를 방지하고, 테스트 수행에 있어 낭비를 줄일 수 있다.\r\n- 표준 테스트 케이스 형식\r\n\r\n1. 테스트 계획 검토 및 자료 확보\r\n2. 위험 평가 및 우선 순위 결정\r\n3. 테스트 요구사항 정의\r\n4. 테스트 구조\r\n5. 설계 및 테스트 방법 결정\r\n6. 테스트 케이스 정의\r\n7. 테스트 케이스 타당성 확인 및 유지보수\r\n\r\n#### 테스트 케이스의 구성 요소(ISO/IEC/IEEE 29119-3)\r\n\r\n- 식별자(Identifier)\r\n- 테스트 항목(Test Item)\r\n- 입력 명세(Input Specification)\r\n- 출력 명세(Output Specification)\r\n- 환경 설정(Environmental Needs)\r\n- 특수 절차 요구(Special Procedure Requirement)\r\n- 의존성 기술(Inter-case Dependencies)\r\n\r\n#### 테스트 프로세스(Test Process)\r\n\r\n계획 및 제어 =\u003e 분석 및 설계 =\u003e 구현 및 실행 =\u003e 평가 =\u003e 완료\r\n\r\n### 테스트 커버리지(Test Coverage)\r\n\r\n- 테스트 수행 정도로서 구문 커버리지, 결정 커버리지, 조건 커버리지, 조건/결정 커버리지, 변경 조건/결정 커버리지, 다중 조건 커버리지로 구분한다.\r\n\r\n### 테스트 오라클(Test Oracle)\r\n\r\n- 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참(True) 값을 입력하여 비교하는 기법 및 활동을 말한다.\r\n- True 오라클\r\n  - 모든 입력값에 대하여 적합한 결과를 생성하여, 발생한 오류를 모두 검출 할 수 있는 오라클이다.\r\n- 일관성 검사(Consistent) 오라클\r\n  - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클이다.\r\n- 샘플링(Sampling) 오라클\r\n  - 임의로 선정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공한다.\r\n- 휴리스틱(Heuristic) 오라클\r\n  - 샘플링 오라클을 개선한 오라클로, 임의 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리한다.\r\n\r\n## 테스트\r\n\r\n### 테스트 레벨\r\n\r\n- 애플리케이션 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트, 설치 테스트로 분류한다.\r\n- 애플리케이션을 테스트하기 위한 총체적으로 관리하기 위한 테스트 활동의 묶음이다.\r\n- 각각의 테스트 레벨은 서로 독립적, 각각 다른 테스트 계획과 전략이 필요하다.\r\n\r\n#### 테스트 레벨의 종류\r\n\r\n- 단위 테스트\r\n  - 개발자가 원시 코드를 대상으로 각각의 단위를 다른 부분과 연계되는 부분은 고려하지 않고 단위 자체에만 집중하여 테스트한다.\r\n  - 객체지향에서 클래스 테스팅이 여기에 해당한다.\r\n- 통합 테스트\r\n  - 단위 테스트를 통과한 개발 소프트웨어/하드웨어 컴포넌트 간 인터페이스 및 연동 기능 등을 구조적으로 접근하여 테스트한다.\r\n- 시스템 테스트\r\n  - 단위/통합 테스트가 가능한 완벽히 완료되어 기능상 문제가 없는 상태에서 실제 환경과 가능한 유사한 환경에서 진행된다.\r\n  - 시스템 성능과 관련된 요구사항이 완벽하게 수행되는지를 테스트하기 때문에 사전 요구사항이 명확해야 한다.\r\n  - 개발 조직과는 독립된 테스트 조직에서 수행한다.\r\n- 인수 테스트\r\n  - 일반적인 테스트 레벨의 가장 마지막 상위 레벨로, SW 제품에 대한 요구사항이 제대로 이행되었는지 확인하는 단계이다.\r\n  - 테스팅 환경을 실 사용자 환경에서 진행하며 수행하는 주체가 사용자이다.\r\n  - 알파, 베타 테스트와 가장 밀접한 연관이 있다.\r\n\r\n#### 알파/베타 테스트\r\n\r\n- 알파 테스트\r\n  - 개발자 관점에서 수행되며, 사용상의 문제를 반영되도록 하는 테스트이다.\r\n  - 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 검사하는 기법이다.\r\n  - 개발자는 사용상의 문제를 기록하여 반영되도록 하는 테스트이다.\r\n- 베타 테스트\r\n  - 선정된 다수의 사용자가 자신들의 시용 환경에서 일정 기간 사용하면서 테스트한다.\r\n  - 문제점이나 개선 사항 등을 기록하고 개발 조직에 통보하여 반영되도록 하는 테스트이다.\r\n\r\n### 정적 테스트\r\n\r\n- 애플리케이션을 직접 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트 방식이다.\r\n- 소프트웨어 개발 초기에 결함 발견이 가능하여, 개발 비용을 낮출 수 있다.\r\n- 종류 : Inspection, walk-through, Code Test, Orthogonal Array Testing, Prior Defect History Testing, Risk-Based Testing, Run Chart, Statistical Profile Testing\r\n\r\n### 동적 테스트\r\n\r\n- 애플리케이션을 직접 실행하여 오류를 찾는 테스트 방식이다.\r\n- 소프트웨어 개발의 모든 단계에서 테스트를 수행한다.\r\n- 종류 : 블랙박스 테스트(명세 기반), 화이트박스 테스트(구조 기반)\r\n\r\n### 테스트 기반(Test Bases)에 따른 테스트\r\n\r\n- 구조 기반 테스트\r\n  - 소프트웨어 내부의 구조(논리 흐름)에 따라 테스트 케이스를 작성하고 확인하는 테스트 방식이다.\r\n  - 종류 : 구문 기반, 조건 기반, 데이터 흐름\r\n- 명세 기반 테스트\r\n  - 사용자의 요구사항에 대한 명세를 기반으로 테스트 케이스를 작성하고 확인하는 테스트 방식이다.\r\n  - 종류 : 동등 분할, 경계값 분석, 분류 트리, 상태 전이, 결정 테이블, 원인-결과, 조합 테스트, 시나리오, 오류 추정\r\n- 경험 기반 테스트\r\n  - 테스터의 경험을 기반으로 수행하는 테스트 방식이다.\r\n  - 요구사항에 대한 명세가 미흡하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적이다.\r\n  - 종류 : 에러 추정, 체크 리스트, 탐색적 테스팅\r\n\r\n### 목적에 따른 테스트\r\n\r\n- 성능(Performance) : 소프트웨어의 응답 시간, 처리량 등을 테스트한다.\r\n- 회복(Recovery) : 소프트웨어에 고의로 부하를 가하여 실패하도록 유도하고 올바르게 복구되는지 테스트한다.\r\n- 구조(Structured) : 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가한다.\r\n- 회귀(Regression) : 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인한다.\r\n- 안전(Security) : 소프트웨어가 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인한다.\r\n- 강도(Stress) : 소프트웨어에 과도하게 부하를 가하여도 소프트웨어가 정상적으로 실행되는지 확인한다.\r\n- 병행(Parallel) : 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 두 결과를 비교/확인한다.\r\n\r\n## 테스트 기법\r\n\r\n### 화이트박스 테스트(White Box Test)\r\n\r\n- 모듈의 원시 코드를 오픈시킨 상태에서 코드의 논리적 모든 경로를 테스트하는 방법이다.\r\n- Source Code의 모든 문장을 한 번 이상 수행하여 모듈 안의 작동을 직접 관찰할 수 ㅅ있다.\r\n- 산출물의 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.\r\n\r\n### 화이트박스 테스트 종류\r\n\r\n1. 기초 경로 검사(Base Path Testing)\r\n2. 제어 구조 검사\r\n\r\n### 화이트박스 테스트 검증 기준\r\n\r\n- 문장 검증 기준 : 소스 코드의 모든 구분이 한 번 이상 수행된다.\r\n- 분기 검증 기준 : 소스 코드의 모든 조건문이 한 번 이상 수행된다.\r\n- 조건 검증 기준 : 소스 코드의 모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행된다.\r\n- 분기/조건 기준 : 소스 코드의 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우 한 번 이상 수행된다.\r\n\r\n### 블랙박스 테스트(Black Box Test)\r\n\r\n- 블랙박스 테스트는 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트로 기능 테스트라고도 한다.\r\n- 요구사항 명세를 보면서 테스트하며, 주로 구현된 기능을 테스트한다.\r\n- 소프트웨어 인터페이스에서 실시되는 테스트이다.\r\n\r\n### 블랙박스 테스트 종류\r\n\r\n1. 동치 분할 검사(Equivalence Partitioning)\r\n   - 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법이다.\r\n   - 입력 조건에 타당한 입력 자료와 그렇지 않은 자료의 개수를 균등하게 분할해 테스트 케이스를 설정한다.\r\n2. 원인-효과 그래프 검사(Cause and Effect Graphing)\r\n   - 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한다.\r\n   - 효용성이 높은 테스트 케이스를 선정해 검사한다.\r\n3. 오류 예측 검사(Error Forecast)\r\n   - 과거의 경험이나 감각으로 테스트하는 기법이다.\r\n   - 다른 테스트 기법으로는 찾기 어려운 오류를 찾아내는 보충적 검사 기법이다.\r\n4. 비교 검사(Comparision Testing)\r\n   - 동일한 테스트 자료를 여러 버전의 프로그램에 입력하고 동일한 결과가 출력되는지 테스트하는 기법이다.\r\n5. 경계값 분석(Boundary Value Analysis)\r\n   - 입력 자료에만 치중한 동치 분할 기법을 보완한 기법이다.\r\n   - 입력 조건 경계값에서 오류 발생 확률이 크다는 것을 활용하여 경계값을 테스트 케이스로 선정해 검사한다.\r\n   - 대표적인 명세 기반 기법(Specification based Technique)이다.\r\n\r\n## 단위/통합 테스트\r\n\r\n### 단위 테스트\r\n\r\n- 소프트웨어 최소 기능 단위인 모듈, 컴포넌트를 테스트하는 것으로 사용자의 요구사항을 기반으로 한 기능 테스트를 제일 먼저 수행한다.\r\n- 인터페이스, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 결제 조건 등을 테스트한다.\r\n- 구조 기반 테스트와 명세 기반 테스트로 분류할 수 있으나 주로 구조 기반 테스트를 시행한다.\r\n\r\n### 통합 테스트(Integration Test)\r\n\r\n- 각 모듈 간을 결합하여 시스템을 완성시키는 과정에서 모듈 간 인터페이스 혹은 통합된 컴포넌트 간 상호작용 오류 및 결함을 찾아 해결하기 위한 테스트 기법이다.\r\n- 통합 방식\r\n  - 비점진적 통합 방식(빅뱅 통합)\r\n    - 모든 모듈이 결합된 프로그램 전체를 대상으로 테스트한다.\r\n    - 규모가 작은 소프트웨어에 적합하다.\r\n    - 오류 발견/장애 위치 파악 또는 수정이 어렵다.\r\n  - 점진적 통합 방식(상향식/하향식)\r\n    - 단계적으로 통합하며 테스트한다.\r\n    - 오류 수정이 쉽다.\r\n    - 인터페이스 관련 오류를 테스트할 수 있다.\r\n\r\n### 하향식 통합\r\n\r\n- 상위 컴포넌트를 테스트하고 점증적으로 하위 컴포넌트를 검사한다.\r\n- 주요 제어 모듈 기준으로 아래로 통합하며 진행한다.\r\n- 하위 컴포넌트 개발이 완료되지 않은 경우 스텁(Stub)을 사용하기도 한다.\r\n- 우선 통합법, 깊이 우선 통합법, 넓이 우선 통합법 등이 있다.\r\n- 하위 레벨 모듈들은 특정한 소프트웨어 부가 기능을 수행하는 클러스터들에 결합된다.\r\n\r\n### 상향식 통합\r\n\r\n- 프로그램 구조에서 최하위 레벨인 모듈을 구성하고 상위 모듈 방향으로 통합하며 검사한다.\r\n- 가장 하위 단계의 모듈부터 수행되므로 스터브가 필요 없으나 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터가 필요하다.(Driver 사용)\r\n\r\n### 빅뱅 통합\r\n\r\n- 시스템을 구성하는 모듈을 각각 따로 구현하고 전체 시스템을 한 번에 테스트를 진행한다.\r\n- 테스트를 위한 Driver와 Stub 없이 실제 모듈들로 테스트를 진행한다.\r\n- 단시간 테스트를 수행하나 결함의 격리가 어려운 방식이다.\r\n\r\n### 샌드위치 통합\r\n\r\n- 상향식과 하향식의 장점을 이용하는 방식(하향식 + 상향식)이다.\r\n- 하위 프로젝트가 있는 대규모 프로젝트에 사용하는 방식이다.\r\n- 병렬 테스트가 가능하고 시간 절약이 가능하다.\r\n- 스텁(Stub)과 드라이버(Driver)의 필요성이 매우 높은 방식이며, 비용이 많이 들어간다.\r\n\r\n# 애플리케이션 성능 개선\r\n\r\n### 성능 측정 지표\r\n\r\n- 처리량(Throughput) : 주어진 시간에 처리할 수 있는 프로세스 처리 수\r\n- 응답 시간(Response Time) : 데이터 입력 완료 시부터 응답 출력이 개시될 때까지의 시간\r\n- 경과 시간(Turnaround Time) : 입력한 시점부터 그 결과의 출력이 완료할 때까지 걸리는 시간\r\n- 자원 사용률(Resource Usage) : 프로세스 처리 중 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량\r\n\r\n### 유형별 성능 분석 도구\r\n\r\n- 성능/부하/스트레스(Performance/Load/Stress) 정검 도구 : 측정 지표인 처리량, 응답 시간, 경과 시간 등을 점검하기 위해 가상의 시스템 부하나 스트레스를 통해 성능을 분석하는 도구이다.\r\n- 모니터링(Monitoring) 도구 : 성능 모니터링, 성능 저하 원인 분석, 시스템 부하량 분석, 장애 진단, 사용자 분석, 용량 산정 등의 기능을 통하여 애플리케이션 실행 시 자원 사용량을 확인하고 분석 가능한 도구이다.\r\n\r\n## 애플리케이션 성능 저하 원인\r\n\r\n### DB 연결 및 쿼리 실행 시 발생되는 성능 저하 원인\r\n\r\n1. DB Lock\r\n   - 과도한 데이터 조회/업데이트/인덱스 생성 시 발생한다.\r\n   - Lock의 해제 시까지 대기하거나 처리되지 못하고 종료된다.\r\n2. 불필요한 DB Fetch\r\n   - 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 발생한다.\r\n   - 결과 세트에서 마지막 위치로 커서를 옮기는 작업이 빈번한 경우 응답 시간 저하 현상이 발생한다.\r\n3. 연결 누수(Connection Leak)\r\n   - DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생한다.\r\n4. 부적절한 Connection Pool Size\r\n   - 커넥션 풀 크기가 너무 작거나 크게 설정한 경우 발생한다.\r\n5. 기타\r\n   - 트랜잭션이 Commit되지 않고 커넥션 풀에 반환되거나, 잘못 작성된 코드로 인해 불필요한 commit이 자주 발생하는 경우 발생한다.\r\n\r\n### 내부 로직으로 인한 성능 저하 원인\r\n\r\n- 웹 애플리케이션의 인터넷 접속 불량이나 대량의 파일로 인해 부하가 발생하는 경우이다.\r\n- 정상적으로 처리되지 않은 오류 처리로 인한 부하나 트랜잭션이 수행되는 동안 외부 트랜잭션(외부 호출)이 장시간 수행되거나, 타임아웃이 일어나는 경우이다.\r\n\r\n### 잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인\r\n\r\n- 환경 설정으로 인한 성능 저하 : Thread pool, Heap Memoty의 크기를 너무 작게 설정하면 Heap Memory Full 현상이 발생한다.\r\n- 네트워크 장비로 인한 성능 저하 : 라우터, L4 스위치 등 네트워크 관련 장비 간 데이터 전송 실패 또는 전송 지연에 따른 데이터 손실이 발생한다.\r\n\r\n# 알고리즘\r\n\r\n- 주어진 과제를 해결하기 위한 방법과 절차를 의미한다.\r\n- 알고리즘은 자연어, 의사코드(Pseudocode), 순서도, 프로그래밍 언어를 이용하여 표현 가능하다.\r\n\r\n1. 분할 정복법(Divide \u0026 Conquer)\r\n   - 제시된 문제를 분할이 불가할 때까지 나누고, 각 과제를 풀면서 다시 병합해 문제의 답을 얻는 Top-down 방식이다.\r\n   1. 분할(Divide) : 정복이 필요한 과제를 분할이 가능한 부분까지 분할하고,\r\n   2. 정복(Conquer) : 1에서 분할된 하위 과제들을 모두 해결(정복)한다.\r\n   3. 결합(Combine) : 그리고 2에서 정복된 해답을 모두 취합(결합)한다.\r\n   - ex. Quick sort, Merge sort 알고리즘\r\n2. 동적 계획법(Dynamic Programming)\r\n   - 주어진 문제를 해결하기 위해 부분 문제에 대한 답을 계속적으로 활용해 나가는 Bottom-up 방식이다.\r\n     1. 부분 문제로 분리\r\n     2. 가장 낮은 단계의 부분 문제 해답 계산\r\n     3. 이 부분 문제의 해답을 이용해 상위 부분 문제를 해결\r\n   - 이전 단계의 해답을 활용하기 위해 반드시 기억할 수 있는 저장소가 필요하기 때문에 속도는 빠르지만, 공간 복잡도가 커지는 단점이 있다.\r\n   - ex. 플로이드 알고리즘, 피보나치 수열 알고리즘(재귀 호출(동적 계획법) 뿐만 아니라 분할 정복법을 통해서도 구현 가능)\r\n3. 탐욕법(Greedy Method)\r\n   - 국소적인 관점에서 최적의 해결 방법을 구하는 기법으로 최적의 해결 방법을 구하지는 못하나 동적 계획법보다 효율적이라고 할 수 있다.\r\n   - ex. 크루스칼 알로리즘, 다익스트라 알고리즘\r\n4. 백트래킹(Back tracking)\r\n   - 어떤 문제의 최적해를 구하기 위해 모든 가능성을 찾아가는 방법이다.\r\n   - N-Queen 문제 해결 시에 응용된다. -동적 계획법과 같이 기억할 저장소를 필요로 한다.\r\n5. 분기 한정법(Branch \u0026 Bound)\r\n   - 정해진 범위(Bound)를 벗어나는 값들은 가지치기(Branch)해가며 결과값을 추적해 나가는 방식이다.\r\n   - ex. 최적 우선 탐색(Best First Search) 알고리즘, A\\* 알고리즘\r\n6. 근사 해법(Approximation Algorithm)\r\n   - 복잡도가 매우 높은 문제게 대해 가장 근사치의 값을 구하는 기법이다.- NP-Hard 문제를 해결하기 위해, 주어진 시간에 최적해를 가장 가까운 답을 찾는 결정성 알고리즘을 구현하는 기법이다.\r\n   - 시간 복잡도, 공간 복잡도, 정밀도를 척도로 평가된다.\r\n   - ex. 근사 알고리즘\r\n\r\n### 시간 복잡도에 따른 알고리즘\r\n\r\n- 시간 복잡도는 알고리즘이 문제를 해결하기 위한 시간(연산)의 횟수를 말한다.\r\n- 시간 복잡도를 고려하는 것을 최적화를 위해 필요하다.\r\n- 알고리즘의 소요 시간에 대한 정확한 평가는 어려워 자료의 수 n이 증가할 때 시간이 증가하는(Time Complexity) 대략적인 패턴을 의미한다.\r\n- 시간 복잡도 Big-O 표기법\r\n  - O(1) : 상수 시간의 복잡도를 의미하며 입력값 n이 주어졌을 때, 문제를 해결하는데 오직 한 단계만 거친다.(해시 함수).\r\n  - O(log₂n) : 로그 시간의 복잡도를 의미하며 입력값 n이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.(이진 탐색)\r\n  - O(nlog₂n) : 선형 로그 시간의 복잡도를 의미하며, 문제 해결을 위한 단계 수는 n log2 n 번의 수행 시간을 갖는다.(퀵 정렬, 병합 정렬)\r\n  - O(n) : 선형 시간의 복잡도를 의미하며 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계이다.(순차 탐색)\r\n  - O(n²) : 제곱 시간의 복잡도를 의미하며 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱근이다.(버블 정렬, 삽입 정렬, 선택 정렬)\r\n  - O(Cⁿ) : 지수 시간의 복잡도를 의미하며 문제를 해결하기 위한 단계의 수는 주어진 상수값 C의 n 제곱이다.\r\n\r\n# 소스 코드 최적화\r\n\r\n- 읽기 쉽고 변경 및 추가가 쉬운 클린 코드를 작성하는 것을 의미한다.\r\n- 소스 코드 품질을 위해 기본적으로 지킬 원칙과 기준을 정의하고 있다.\r\n- 나쁜 코드\r\n  - 다른 개발자가 로직을 이해하기 어렵게 작성된 코드\r\n  - 변수/메서드에 대한 명칭을 알 수 없는 코드이다. -동일한 처리 로직이 중복되게 작성된 코드이다.\r\n  - 스파게티 코드\r\n  - 유형 : 오염, 문서 부족, 의미 없는 이름, 높은 결합도, 아키텍처 침식\r\n- 클린 코드\r\n  - 깔끔하게 잘 정리된 코드\r\n  - 중복 코드 제거로 애플리케이션의 설계가 개선된다.\r\n  - 가독성이 높아 애플리케이션의 기능에 대해 쉽게 이해할 수 있다.\r\n  - 버그를 찾기 쉬워지며, 프로그래밍 속도가 빨라진다.\r\n  - 클린 코드 최적화 원칙 : 가독성, 단순성, 의존성 배제, 중복성 취소화, 추상화\r\n  - 유형 : 보기 좋은 배치, 작은 함수, 분석 가능한 제어 흐름, 오류 처리, 간결한 주석, 의미 있는 이름\r\n\r\n### 코드 간결성 유지 지침\r\n\r\n- 공백을 이용하여 실행문 그룹과 주석을 명확히 구분하고, 복잡한 논리식과 산술식은 괄호와 들여쓰기(Indentation)를 통해 명확히 표현한다.\r\n- 빈 줄을 사용하여 선언부와 구현부를 구별하고 한 줄에 되도록 적은 문장을 코딩한다.\r\n\r\n### 클린 코드의 작성 원칙\r\n\r\n- 가독성 : 이해하기 쉬운 용어를 사용하고 들여쓰기 등을 활용하여 코드를 쉽게 읽을 수 있도록 작성한다.\r\n- 단순성 : 클래스/메서드/함수는 최소 단위로 분리해 한 번에 한 가지 기능만 처리한다.\r\n- 의존성 배체 : 다른 모듈에 미치는 영향을 최소화하여 코드 변경 시 다른 부분에 영향이 없도록 작성한다.\r\n- 중복성 최소화 : 중복된 코드는 삭제하여 공통된 코드로 사용한다.\r\n- 추상화 : 상위 클래스/메서드/함수에서 간략하게 애플리케이션 특성을 나타내고, 상세 내용은 하위 클래스/메서드/함수에서 구현한다.\r\n\r\n### 소스 코드 최적화 유형\r\n\r\n1. 클래스 분할 배치\r\n   - 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이도록 한다.\r\n   - 모듈 크기를 작게 작성한다.\r\n2. 좋은 이름 사용\r\n   - 변수나 함수 이름은 Namming Rule을 정의하여 기억하기 좋고, 발음이 쉽게 사용한다.\r\n3. 코딩 형식 준수\r\n   - 개념적 유사성 높은 종속 함수를 사용하여 논리적으로 코드를 라인별로 구분하여 가독성을 높이다.\r\n   - 호출하는 함수 앞쪽에, 호출되는 함수를 배치하고, 지역 변수는 각 함수 맨 처음에 선언한다.\r\n4. 느슨한 결합(Loosely Coupled)\r\n   - 클래스 간 의존성이 느슨하게 하기 위해 인터페이스 클래스를 이용하여 추상화된 자료 구조와 메서드를 구현한다.\r\n5. 적절한 주석\r\n   - 코드의 간단한 기능 안내 및 중요 코드를 표시할 때 적절히 사용한다.\r\n\r\n# 인터페이스 구현\r\n\r\n- 송/수신 시스템 간의 데이터 교환 및 처리를 실현해주는 작업이다.\r\n- 사전에 정의된 기능 구현을 분석하고 인터페이스를 구현한다.\r\n- 인터페이스 기능 구현을 기반으로 인터페이스 구현 방법을 분석하고 분석된 인터페이스 구현 정의를 바탕으로 인터페이스를 구현한다.\r\n\r\n### AJAX(Asynchronous Javascript And Xml)\r\n\r\n- javascript를 사용한 비동기 통신 기술로 클라이언트와 서버 간에 XML 데이터를 주고받는 기술이다.\r\n- 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법이다.\r\n\r\n### JSON(Javascript Object Notation)\r\n\r\n- 데이터 통신을 이용한 인터페이스 구현 방법이다.\r\n- 웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성/값의 쌍 형태로 표현하는 형식으로 JS를 토대로 개발된 형식이다.\r\n- 속성/값의 쌍(Attribute-Value Pairs)인 데이터 객체 전달을 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷으로 비동기 처리에 쓰이는 AJAX에서 XML을 대체하는 주요 데이터 포맷이다.\r\n\r\n# 인터페이스 보안\r\n\r\n- 모듈 컴포넌트 간 데이터 교환 시 데이터 변조/탈취 및 인터페이스 모듈 자체의 보안 취약점이 존재할 수 있다.\r\n\r\n1. 데이터 통신 시 데이터 탈취 위협\r\n   - 스니핑(Sniffing) : 네트워크 주변을 지나다니는 패킷을 엿보면서 계정(ID)과 비밀번호를 알아내는 보안 위협이다.\r\n   - 스푸핑(Spoofing) : 일반 사용자가 인터넷상에서 통신하는 정보를 크래커의 사이트를 통하도록 하여 비밀번호를 알아내는 보안 위협이다.\r\n2. 데이터베이스 암호화\r\n   - 데이터베이스의 기밀성을 유지하기 위해 중요 민감 데이터는 암호화한다.\r\n   - 대칭 키, 해시, 비대칭키 알고리즘이 사용된다.\r\n3. 시큐어 코딩\r\n   - OWASP(Open Web Application Security Project) Top 10을 참고하여 KISA(한국 인터넷 진흥원)에서 SW 보안 약점 가이드를 발표하였다.\r\n   - SW 보안 취약점, 약점 및 대응 방안이 구체적으로 서술되어 있으며 이를 바탕으로 시큐어 코딩을 하도록 한다.\r\n\r\n# 데이터베이스 보안\r\n\r\n- 데이터베이스의 기밀성 유지를 위하여 중요하고 민감한 데이터는 암호화 기법을 활용하여 암호화하도록 한다.\r\n- 데이터베이스의 접근 권한 및 SQL, 프로시져, 트리거 등 데이터베이스 동작 객체의 보안 취약점을 보완하도록 한다.\r\n- 민감하고 중요한 데이터는 암호화와 익명화 등을 통하여 데이터 자체 보안 방법도 고려해야 한다.\r\n- 영역 : 비인가자 접근 관리, 악의적 코드 삽입 금지, 민감 데이터 관리, 악의적 시도 시 에러 처리\r\n\r\n### 데이터베이스 암호화 알고리즘\r\n\r\n- 대칭키 알고리즘 : ARIA 128/129/256, SEED\r\n- 해시 알고리즘 : SHA-256/384/512, HAS-160\r\n- 비대칭키 알고리즘 : RSA, ECDSA, ECC\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n"},{"title":"sw first test1","description":"정보처리기사 필기(1) - 소프트웨어 설계","category":"sw","date":"2023-12-24","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 소프트웨어\r\n\r\n### 소프트웨어(SW)의 개념\r\n\r\n- 컴퓨터를 동작시키고 어떤 일의 처리 순서와 방법을 지시하는 명령어의 집합인 프로그램과 프로그램의 수행에 필요한 절차, 규칙, 관련 문서 등의 총칭\r\n- 프로그램(Program) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합\r\n- 자료 구조(Data Structure) : 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭하는 것으로, 데이터 간의 논리적 관계나 처리 알고리즘\r\n- 문서(Paper) : 소프트웨어를 개발함에 있어 사용자 설명서, 소프트웨어 요구분석서, 평가서, 명세서, 프로젝트 계획서, 검사 계획서 등\r\n\r\n### 소프트웨어의 특징\r\n\r\n- 상품성 : 소프트웨어를 개발하면 상품이 되어 판매가 된다.\r\n- 복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다.\r\n- 변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다.\r\n- 복제성 : 복제가 용이해 쉽게 복사, 유통이 가능하다.\r\n\r\n### 시스템(System)의 개요와 기본 요소\r\n\r\n- 시스템의 개요\r\n  - 컴퓨터로 처리 가능한 자료를 입력하고 저장, 처리, 가공해 출력할 수 있도록 설계/구현된 정보 체계를 의미한다.\r\n  - 하나의 목적을 위해 다양한 요소가 유기적으로 결합된 것을 의미한다.\r\n- 기본 요소\r\n  - 입력, 처리, 출력, 제어, 피드백으로 구성된다.\r\n\r\n### 소프트웨어 위기(Software Crisis)\r\n\r\n- 컴퓨터의 발달 과정에서 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없는 문제가 발생함을 의미한다.\r\n- 소프트웨어 위기의 원인\r\n  - 하드웨어 비용을 초과하는 개발 비용의 증가\r\n  - 개발 기간의 지연\r\n  - 개발 인력 부족 및 인건비 상승\r\n  - 성능 및 신뢰성 부족\r\n  - 유지보수의 어려움에 따른 엄청난 비용\r\n\r\n# 소프트웨어 공학\r\n\r\n### 소프트웨어 공학이란?\r\n\r\n- 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 방법, 도구와 절차들의 체계를 말한다.\r\n- IEEEE(전기/전자기술협회)는 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법이라 정의하였다.\r\n\r\n### 소프트웨어 공학의 기본 원칙\r\n\r\n- 현대적인 프로그래밍 기술을 적용해야 한다.\r\n- 신뢰성이 높아야 한다.\r\n- 사용의 편리성과 유지보수성이 높아야 한다.\r\n- 지속적인 검증 시행을 해야 한다.\r\n\r\n### 소프트웨어 공학 계층 구조\r\n\r\n- 도구 : 프로세스와 방법을 처리하는 기능을 제공하는 것\r\n- 방법론 : 소프트웨어를 설계하는데 기술적인 방법을 제공하는 것\r\n- 프로세스 : 소프트웨어의 가장 기초가 되며 개발에 사용되는 방법론과 도구가 적용되는 순서를 의미한다.\r\n\r\n### 소프트웨어 품질\r\n\r\n- 사용자의 요구대로 만들어져야 한다.\r\n- 유지보수가 쉬워야 한다.\r\n- 에러를 최소화해야 한다.\r\n- 초반에 정한 비용에 맞춰 개발해야 한다.\r\n- 정확한 결과가 도출되어야 한다.\r\n- 원하는 시간에 원하는 기능을 수행할 수 있어야 한다.\r\n\r\n### 소프트웨어 공학의 목표\r\n\r\n- 소프트웨어의 생산성과 품질을 향상시킨다.\r\n- 최소의 비용으로 단기간에 시스템에 적합한 소프트웨어를 개발하는 것이 소프트웨어 공학의 궁극적 목적이다.\r\n\r\n### 소프트웨어 재공학(Software Reengineering)\r\n\r\n- 재공학의 개념\r\n  - 소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법을 의미한다.\r\n  - 현재의 시스템을 변경하거나 재구조화(Restructuring)하는 것이다.\r\n    - 재구조화: 재공학의 한 유형으로 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선하는 것\r\n  - 소프트웨어 재공학 관점에서 가장 연관 싶은 유지보수 유형은 예방 유지보수(Preventive Maintenance)이다.\r\n- 재공학의 장점\r\n  - 개발 시간 및 비용 감소\r\n  - 품질 향상\r\n  - 생산성 향상\r\n  - 신뢰성 향상\r\n  - 구축 방법에 대한 지식의 공유\r\n  - 프로젝트 실패 위험 감소\r\n- 재공학의 목표\r\n  - 소프트웨어의 유지보수성 향상이 최우선\r\n  - 복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거\r\n  - 수월한 재사용과 소프트웨어의 수명 연장\r\n- 과정\r\n  - 분석(Analysis) =\u003e 구성(Restructuring) =\u003e 역공학(Reverse Engineering) =\u003e 이식(Migration)\r\n\r\n### 역공학\r\n\r\n- 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어내는 작업\r\n- 역공학의 가장 간단하고 오래된 형태 == 재문서화\r\n\r\n# CASE (Computer Aided Software Engineering) ★★★\r\n\r\n### CASE란?\r\n\r\n- 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업이다.\r\n- 자료 흐름도 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어 CASE 도구이다.\r\n- 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대한다.\r\n\r\n### CASE가 제공하는 기능\r\n\r\n- 개발을 신속하게 할 수 있고, 오류 수정이 쉬워 소프트웨어 품질이 향상된다.\r\n- 소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화시켜 주는 통합된 도구를 제공해주는 기술이다.\r\n- 소프트웨어 시스템의 문서회 및 명세화를 위한 그래픽 기능을 제공한다.\r\n- 소프트웨어 개발 단계의 표준화를 기할 수 있으며, 자료 흐름도 작성 기능을 제공한다.\r\n- 모델들 사이의 모순 검사 기능을 제공하며 다양한 소프트웨어 개발 모형을 지원한다.\r\n- 원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술\r\n\r\n### CASE 사용의 장점\r\n\r\n- 소프트웨어 개발 기간 단축 및 개발 비용을 절약하여 소프트웨어 생산성을 향상시킨다.\r\n- 자동화된 검사를 통해 소프트웨어 품질이 향상된다.\r\n- 프로그램의 유지보수가 간편해지고 소프트웨어 모듈의 재사용성이 향상된다.\r\n- 소프트웨어 개발 주기의 표준안 확립, 소프트웨어 개발 기법의 실용화, 문서화의 용이성 제공, 시스템 수정 및 유지보수 축소 등의 효과를 얻을 수 있다.\r\n\r\n### CASE의 분류\r\n\r\n- 상위(Upper) CASE : 요구분석 및 설계 단계 지원\r\n- 하위(Lower) CASE : 소스 코드 작성, 테스트, 문서화 과정 지원\r\n- 통합(Integrate) CASE : 소프트웨어 개발 주기 전체 과정 지원\r\n\r\n### 요구사항 분석을 위한 CASE 도구\r\n\r\n- SADT(Structured Analysis and Design Technique) : SoftTech 사에서 개발한 것으로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위해 널리 이용되어 온 구조적 분석 및 설계 도구이다. 구조적 요구분석을 하귀 위해 블록 다이어그램을 채택한 자동화 도구다.\r\n- REM( Software Requirements Engineering Methodolohy) = RSL/REVS : TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 것으로, RSL과 REVS를 사용하는 자동화 도구다.\r\n  - RSL(Requirement Statement Language) : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어이다.\r\n  - REVS(Requirement Engineering and Validation System) : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분ㅅ거 명세서를 출력하는 요구사항 분석기다.\r\n\r\n# 소프트웨어 개발 방법론 ★★★\r\n\r\n### 소프트웨어 생명주기(Software Life Cycle)\r\n\r\n- 소프트웨어 제품의 개념 형성에서 시작하여 운용/유지보수에 이르기까지 변화의 모든 과정이다.\r\n- 당성 검토 =\u003e 개발 계획 =\u003e 요구사항 분석 =\u003e 설계 =\u003e 구현 =\u003e 테스트 =\u003e 운용 =\u003e 유지보수\r\n\r\n### 폭포수 모형(Waterfall Model) - 순차적 모델\r\n\r\n- 선형 순차적 모델이라고도 하며, Boehm이 제시한 고전적 생명주기 모형으로, 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 모형이다.\r\n\r\n### 나선형 모형(Spiral Model) - 점증적 위험관리 모델\r\n\r\n- Boehm이 제시하였으며, 반복적인 작업을 수행하는 점증적 생명주기 모형이다.\r\n- 점증적 모형, 집중적 모형이라고도 하며 유지보수 과정이 필요 없다.\r\n- 소프트웨어 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적이다.\r\n- 나선을 따라서 돌아가면서 각 개발 순서를 반복하여 수행하는 점진적 방식으로 누락된 요구사항을 추가할 수 있다.\r\n  - 목표설정 =\u003e 위험분석 =\u003e 개발과 검증 =\u003e 고객평가/다음단계 수립 =\u003e 목표설정\r\n\r\n### 하향식/상향식 설계\r\n\r\n- 하향식 설계 : 소프트웨어 설계 시 제일 상위에 있는 Main User Function에서 시작하여 기능을 하위 기능들로 나눠가며 설계하는 방식이다.\r\n- 상향식 설계 : 가장 기본적인 컴포넌트를 먼저 설계한 다음 이것을 사용하는 상위 수준의 컴포넌트를 설계하는 방식이다.\r\n\r\n### 프로토타입 모형(Prototype Model)\r\n\r\n- 실제 개발될 시스템의 견본(Prototype)을 미리 만들어 최종 결과물을 예측하는 모형이다.\r\n- 개발이 완료되고 나서 사용을 하면 문제점을 할 수 있는 폭포수 모형의 단점을 보완하기 위한 모형으로 요구사항을 충실히 반영할 수 있다.\r\n\r\n### HIPO(Hierarchy Input Process Output)\r\n\r\n- 입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법이다.\r\n- 일반적으로 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Overview Diagram), 세부적 다이어그램(Detail Diagram)으로 구성된다.\r\n- 구조도(가시적 도표, Visual Table of Contents), 개요, 도표(Index Diagram), 상세 도표(Detail Diagram)로 구성된다.\r\n- 가시적 도표는 전체적인 기능과 흐름을 보여주는 구조이다.\r\n- 기능과 자료의 의존 관계를 동시에 표현할 수 있다.\r\n- 보기 쉽고 이해하기 쉬우며 유지보수가 쉽다.\r\n- 하향식 소프트웨어 개발을 위한 문서화 도구이다.\r\n\r\n### V-모델\r\n\r\n- 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델이다.\r\n- 세부적인 프로세스로 구성되어 있어서 신뢰도 높은 시스템 개발에 효과적이다.\r\n- 개발 단계의 작업을 확인하기 위해 테스트 작업을 수행한다.\r\n- 생명주기 초반부터 테스트 작업을 지원한다.\r\n- 코드뿐만 아니라 요구사항과 설계 결과도 테스트할 수 있어야 한다.\r\n- 폭포수 모형보다 반복과 재처리 과정이 명확하다.\r\n- 테스트 작업을 단계별로 구분하므로 책임이 명확해진다.\r\n\r\n### 애자일(Agile) 개발 방법론\r\n\r\n- 날렵한, 재빠른 이란 사전적 의미가 있다.\r\n- 특정 방법론이 아닌 소프트웨어를 빠르고 낭비 없이 제작하기 위해 고객과의 협업에 초점을 두고 소프트웨어 개발 중 설계 변경에 신속히 대응하여 요구사항을 수용할 수 있다.\r\n- 절차와 도구보다 개인과 소통을 중요시하고 고객과의 피드백을 중요하게 생각한다.\r\n- 소프트웨어가 잘 실행되는데 가치를 두며, 소프트웨어 배포 시차를 최소화할 수 있다.\r\n  - 특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션 변화\r\n  - 종류\r\n    - 익스트림 프로그래밍(XP, eXtreame Programming)\r\n    - 스크럼(SCRUM)\r\n    - 린(Lean)\r\n    - DSDM(Dynamic System Development, 동적 시스템 개발 방법론)\r\n    - FDD(Feature Driven Development, 기능 중심 개발)\r\n    - Crystal\r\n    - ASD(Adaptive Software Development, 적응형 소프트웨어 개발방법론)\r\n    - DAD(Disciplined Agile Delivery, 학습 애자일 배포)\r\n- Agile 선언문\r\n  - 프로세스나 도구보다 개인과의 소통이 더 중요하다.\r\n  - 완벽한 문서보다 실행되는 소프트웨어가 더 중요하다.\r\n  - 계약 협상보다 고객과의 협업이 더 중요하다.\r\n  - 계획을 따르는 것보다 변경에 대한 응답이 더 중요하다.\r\n\r\n#### XP (eXtream Programming)\r\n\r\n- 개념\r\n  - 1999년 Kent Beck이 제안하였으며, 개발 단계 중 요구사항이 시시각각 변동이 심한 경우 적합한 방법론\r\n  - 요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 함\r\n  - 요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 적용하는 방식으로, 예측성보다는 적응성에 더 높은 가치를 부여한 방법\r\n  - 고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법\r\n- 핵심 가치\r\n  - 소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향한다.\r\n  - 단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다.\r\n  - 피드백(Feedback) : 소프트웨어 개발에서 변화는 불가피하므로 지속적 테스트와 통합, 반복적 결함 수정 등 빠르게 피드백한다.\r\n  - 용기(Courage) : 고객 요구사항 변화에 능동적으로 대응한다.\r\n  - 존중(Respect) : 개발 팀원 간의 상호 존중을 기본으로 한다.\r\n- 효과적인 프로젝트 관리를 위한 3대 요소\r\n  - 사람(People) : 인적 자원\r\n  - 문제(Problem) : 문제 인식\r\n  - 프로세스(Process) : 작업 계획\r\n\r\n#### SCRUM\r\n\r\n- 개념과 특징\r\n  - 요구사항 변경에 신속하게 대처할 수 있는 반복적이고 점진적인 소규모 팀원 간 활발한 소통과 협동심이 필요한 팀 중심의 소프트웨어 개발 방법론\r\n  - 신속하게 반복적으로 실제 작동하는 소프트웨어를 제공\r\n  - 개발자들의 팀 구성과 각 구성원의 역할, 일정 결과물 및 그 외 규칙을 정하는 것을 의미\r\n  - 기능 개선점에 우선순위를 부여하고, 개발 주기 동안 실제 동작 가능한 결과를 제공\r\n  - 개발 주기마다 적용된 기능이나 개선점의 리스트를 제공\r\n  - 커뮤니케이션을 위해 팀은 개방된 공간에서 개발하고, 매일 15분 정도 짧은 회의를 함\r\n  - 팀원 스스로 팀을 구성해야 함(Self Organizing)\r\n- 기본 원리\r\n  - 기능 협업을 기준으로 배치된 팀은 스프린트 단위로 소프트웨어를 개발한다.\r\n  - 스프린트는 고정된 30일의 반복이며, 스프린트를 시행하는 작업은 고정된다.\r\n  - 요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 한다.\r\n  - 정해진 시간을 철저히 지켜야 하며, 완료된 모든 작업은 제품 백로그에 기록된다.\r\n  - 가장 기본적인 정보 교환 수단은 일일 스탠드 업 미팅, 또는 일일 스크럼이다.\r\n\r\n# 요구사항 개발 ★★★\r\n\r\n### 요구공학(Requirements Engineering)\r\n\r\n- 요구공학의 개념\r\n  - 소프트웨어 개발 시 사용자 요구가 정확히 반영된 시스템 개발을 위해 사용자의 요구를 추출, 분석, 명세, 검증, 관리하는 구조화된 활동 집합이다.\r\n  - 요구사항을 정의하고, 문서로 만들고 관리하는 프로세스를 의미한다.\r\n  - 효과적인 의사소통을 통하여 공통 이해를 설정하며, 불필요한 비용 절감, 요구사항 변경 추적이 가능해진다.\r\n  - 분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용할 수 있다.\r\n  - 자료 흐름도, 자료 사전 등이 효과적으로 이용될 수 있으며, 더 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 활용될 수 있다.\r\n- 요구공학의 목적\r\n  - 소프트웨어 개발 시 이해관계자 사이의 원활한 의사소통 수단을 제공한다.\r\n  - 요구사항 누락 방지, 상호 이해 오류 등의 제거로 경제성을 제공한다.\r\n  - 요구사항 변경 이력 관리를 통하여 개발 비용 및 시간을 절약할 수 있다.\r\n  - 비용과 일정에 대한 제약설정과 타당성 조사, 요구사항 정의 문서화 등을 수행한다.\r\n- 요구공학(개발) 프로세스\r\n  - 요구사항을 명확히 분석하여 검증하는 진행 순서를 의미한다.\r\n  - 개발 대상에 대한 요구사항을 체계적으로 도출한다.\r\n  - 도출된 요구사항을 분석하여 분석 결과를 명세서에 정리한다.\r\n  - 정리된 명세서를 마지막으로 확인, 검증하는 일련의 단계를 말한다.\r\n  - 경제성, 기술성, 적법성, 대안성 등 타당성 조사가 선행되어야 한다.\r\n\r\n### 요구사항 분류 기준\r\n\r\n- 기능적 요구사항 : 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항(ex. A라는 기능이 있어야 한다.)\r\n- 비기능적 요구사항 : 시스템 구축에 대한 성능, 보안, 품질, 안정성 등으로 실제 수행에 보조적인 요구사항(ex. 몇 초 내로 A라는 화면이 보였으면 좋겠다 등)\r\n\r\n### 요구사항 명세(Requirement Specification)\r\n\r\n- 시스템 정의, 시스템 요구사항, 소프트웨어 요구사항을 작성한다.\r\n- 체계적으로 검토, 평가, 승인될 수 있도록 문서로 만드는 것을 의미한다.\r\n- 기능 요구사항은 빠지는 부분 없이 명확하게 기술한다.\r\n- 비기능 요구사항은 필요한 것만 명확하게 기술한다.\r\n- 개발자가 효과적으로 설계할 수 있고 사용자가 쉽게 이해할 수 있도록 한다.\r\n\r\n### 요구사항 명세 속성\r\n\r\n- 정확성 : 요구사항은 정확해야 한다.\r\n- 명확성 : 단 한 가지로만 해설되어야 한다.\r\n- 완전성 : 모든 것이 표현(기능+비기능) 가능해야 한다.\r\n- 일관성 : 요구사항 간 충돌이 없어야 한다.\r\n- 수정 용이성 : 요구사항 변경이 가능해야 한다.\r\n- 추적성 : RFP, 제안서를 통해 추적 가능해야 한다.\r\n\r\n### 형상관리(Configuration Management)\r\n\r\n- 애플리케이션 개발 단계에서 도출되는 프로그램, 문서, 데이터 등의 모든 자료를 형상 단위라고 하며, 이러한 자료의 변경을 관리함으로써 애플리케이션 버전 관리 등을 하는 활동이다.(ex. Git, SVN(subversion), Apache CVS 등)\r\n\r\n# UML (Unified Modeling Language) ★★★\r\n\r\n### 개념 모델링(Conceptual Modeling)\r\n\r\n- 요구사항을 이해하기 쉽도록 실 세계의 상황을 단순화하여 개념적으로 표현한 것을 모델이라고 하고, 이렇게 표현된 모델을 생성해 나가는 과정을 개념 모델링이라고 한다.\r\n- 모델은 문제가 발생하는 상황에 대한 이해를 증진하고 해결책을 설명하므로 소프트웨어 요구사항 분석의 핵심이라 할 수 있다.\r\n- 개발 대상 도메인의 엔티티(Entity)들과 그들의 관계 및 종속성을 반영한다.\r\n- 요구사항별로 관점이 다르므로 개념 모델도 다양하게 표현되어야 한다.\r\n- 대부분 UML(Unified Modeling Language)을 사용한다.\r\n- 종류 : Use Case Diagram, Data Flow Model, State Model, Goal-Based Model, User Interactions, Object Model, Data Model\r\n\r\n### UML (Unified Modeling Language)\r\n\r\n- UML 개념\r\n  - 객체지향 소프트웨어 개발 과정에서 시스템 분석, 설계, 구현 등의 산출물을 명세화, 시각화, 문서화 할 때 사용하는 모델링 기술과 방법론을 통합하여 만든 범용 모델링 언어이다.\r\n  - Rumbaugh의 OMT 방법론과 Booch의 Booch 방법론, Jacobson의 OOSE 방법론을 통합하여 만든 모델링 개념의 공통 집합으로, 객체지향 분석 및 설계 방법론의 표준 지정을 목표로 제안된 모델링 언어이다.\r\n  - OMG(Object Management Group)에서 표준화 공고 후 Microsoft, Oracle 등이 참여하여 1997.1 버전 1.0을 Release 하였다.\r\n- 럼바우(Rumbaugh) 객체지향 분석 기법\r\n  - 소프트웨어 구성 요소를 그래픽으로 모형화하였다.\r\n  - 객체 모델링 기법이라고도 한다.\r\n    - 객체 모델링 : 정보 모델링이라고도 한다. 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체를 다이어그램으로 표시한다.(OMT : Object Modeling Technique)\r\n    - 동적 모델링 : 제어 흐름, 상호작용, 동작 순서 등의 상태를 시간 흐름에 따라 상태 다이어그램으로 표시한다.\r\n    - 기능 모델링 : 여러 프로세스 간의 자료 흐름을 표시한다. 어떤 데이터를 입력하여 어떤 결과를 가져올 수 있을지를 표현한다.\r\n- UML의 특성\r\n  - 비주얼화 : 소프트웨어 구성 요소 간의 관계 및 상호작용을 시각화한 것이다.\r\n  - 문서화 : 소프트웨어 생명주기의 중요한 작업을 추적하고 문서화할 수 있다. 개발 프로세스 및 언어와 무관하게 개발자 간의 의사소통 도구를 제공한다.\r\n  - 명세화 : 분석, 설계, 구현의 완벽한 모델을 제공한다. 분석 단계-기능 모델, 설계 단계-동작 수준 모델, 구현 단계-상호작용 모델 수준으로 명세화할 수 있다. 단순 표기법이 아닌 구현에 필요한 개발적 요소 및 기능에 대한 명세를 제공한다.\r\n  - 구축 : 객체지향 언어와 호환되는 프로그래밍 언어는 아니지만, 모델이 객체지향 언어로 매핑될 수 있다.\r\n- UML 소프트웨어에 대한 관점\r\n  - 기능적 관점 : 사용자 측면에서 본 소프트웨어의 기능을 나타낸다. 사용 사례 모델링이라고도 한다. 요구분석 단계에서 사용한다. UML에서는 Use Case Diagram을 사용한다.\r\n  - 정적 관점 : 소프트웨어 내부의 구성 요소 사이의 구조적 관계를 나타낸다. 객체, 속성, 연관 관계, 오퍼레이션의 시스템 구조를 나타내며, UML에서는 Class Diagram을 사용한다. (ex. 클래스 사이의 관계, 클래스 구성과 패키지 사이의 관계)\r\n  - 동적 관점 : 시스템의 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사용한다.\r\n- UML의 기본 구성\r\n  - 사물(Things)\r\n  - 관계(Relationship)\r\n  - 다이어그램(Diagram)\r\n\r\n### Use Case Diagram\r\n\r\n- 객체지향 초반기 분석 작업에 작성되는 사용자의 요구를 기능적 측면에서 기술할 때 사용되는 도구로 Actor와 User Case로 구성된다.\r\n- 얻어지는 결과는 개발 대상 시스템이 제공해야 하는 서비스 목록이 된다.\r\n\r\n#### Use Case Diagram 요소\r\n\r\n- 시스템 경계(System Boundary)\r\n- 액터(Actor)\r\n- 유스케이스(Use Case)\r\n- 접속 관계(Communication Association)\r\n- 사용 관계(Uses Association)\r\n- 확장 관계(Extends Association)\r\n\r\n#### Use Case Diagram 작성단계\r\n\r\n- 액터 식별\r\n- Use Case 식별\r\n- 관계 정의\r\n- Use Case 구조화\r\n\r\n# UI (User Interface) / UX (User eXperience) ★★★\r\n\r\n### UI\r\n\r\n- 인간, 디지털 기기, 소프트웨어 사이에서 의사소통할 수 있도록 만들어진 매개체이다.\r\n- 인간과 컴퓨터의 상호작용(HCI)에 필요한 화상, 문자, 소리, 수단(장치)을 의미한다.\r\n\r\n#### UI 분야\r\n\r\n- 표현에 관한 분야 : 전체적인 구성과 콘텐츠의 상세 표현을 위한 분야이다.\r\n- 정보 제공과 전달 분야 : 물리적 제어를 통한 정보 제공과 전달을 위한 분야이다.\r\n- 기능 분야 : 기능적으로 사용자가 쉽고 간편하게 사용하도록 하는 분야이다.\r\n\r\n#### UI의 특징\r\n\r\n- 사용자 입력의 검증\r\n- 에러 처리의 에러 메시지 처리\r\n- 도움과 프롬프트(Prompt) 제공\r\n  - 프롬프트 : 사용자의 명령을 받아들일 준비가 되었음을 모니터에 나타내는 표시(커서 등)\r\n\r\n#### UI 설계 원칙\r\n\r\n- 직관성 : 누구나 쉽게 이해하고 사용할 수 있도록 한다.\r\n- 유효성 : 사용자의 목적을 정확히 달성할 수 있도록 유용하고 효과적이어야 한다.\r\n- 학습성 : 사용자가 쉽게 배우고 익힐 수 있어야 한다.\r\n- 유연성 : 사용자의 요구를 최대한 수용하면서 오류를 최소화해야 한다.\r\n\r\n#### UI 설계 도구\r\n\r\n- 와이어 프레임(Wire Frame) : UI 중심의 화면 레이아웃을 선(Wire)을 이용하여 대략적으로 작성한다.\r\n- 목업(Mockup) : 실물과 흡사한 정적인 모형을 의미한다.\r\n- 프로토타입(Prototype) : Interaction(상호작용)이 결합하여 실제 작동하는 모형이다.\r\n- 스토리보드(StoryBoard) : 정책, 프로세스, 와이어 프레임, 설명이 모두 포함된 설계 문서이다.\r\n\r\n### UX\r\n\r\n#### UX 사용자 경험\r\n\r\n- 사용자가 제품을 대상으로 직/간접적으로 사용하면서 느끼고 생각하게 되는 지각과 반응, 행동 등 모든 경험을 의미한다.\r\n- UI는 사람과 시스템 간의 상호작용을 의미하지만, UX는 제품과 서비스, 회사와 상호작용을 통해서 전체적인 느낌이나 경험을 말한다.\r\n- UX에 영향을 주는 요소 : 성능, 시간\r\n\r\n#### 모바일 사용자 UX 설계 시 고려사항(행정안전부 고시)\r\n\r\n- 시스템을 사용하는 대상, 환경, 목적, 빈도 등을 고려한다.\r\n- 사용자가 직관적으로 서비스 이용 방법을 파악할 수 있도록 한다.\r\n- 입력의 최소화, 자동 완성 기능을 제공한다.\r\n- 사용자의 입력 실수를 수정할 수 있도록 되돌림 기능을 제공한다.\r\n- 모바일 서비스의 특성에 적합한 디자인을 제공한다.\r\n\r\n# 모듈과 결합도, 응집도 ★★★\r\n\r\n### 모듈\r\n\r\n- 전체 프로그램에서 어떠한 기능을 수행할 수 있는 실행 코드를 의미한다.\r\n- 재사용이 가능하며 자체적으로 컴파일할 수 있다.\r\n- 시스템 개발 시 기간과 노동력을 절감할 수 있다.\r\n- 모듈의 독립성은 결합도와 응집도에 의해 측정된다.\r\n- 서브루틴 = 서브 시스템 = 작업 단위\r\n- 변수의 선언을 효율적으로 할 수 있어 기억 장치를 유용하게 사용할 수 있다.\r\n- 모듈마다 사용할 변수를 정의하지 않고 상속하여 사용할 수 있다.\r\n- 각 모듈의 기능이 서로 다른 모듈과의 과도한 상호 작용을 회피함으로서 이루어지는 것을 기능적 독립성이라 한다.\r\n\r\n### 결합도(Coupling)\r\n\r\n- 서로 다른 두 모듈 간의 상호 의존도로서 두 모듈 간의 기능적인 연관 정도를 나타낸다.\r\n- 모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상되어 시스템을 구현하고 유지보수 작업이 쉬워진다.\r\n- 자료 결합도가 설계 품질이 가장 좋다.\r\n\r\n| 결합도 수준 |              분류              | 특징                                                                                                                                                                                                                                                                                        |\r\n| :---------: | :----------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| 결합도 약함 |   자료 결합도(Data Coupling)   | 모듈 간의 인터페이스가 자료 요소로만 구성된 경우로 다른 모듈에 영향을 주지 않는 가장 바람직한 결합도이다. 모듈 간의 내용을 전혀 알 필요가 없다.                                                                                                                                             |\r\n|             | 스탬프 결합도(Stamp Coupling)  | 두 모듈이 같은 자료 구조를 조회하는 경우의 결합도이며, 자료 구조의 어떠한 변화 즉 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈까지도 영향을 미치게 된다. 배열, 레코드, 구조 등이 모듈 간 인터페이스로 전달되는 경우와 관계된다.            |\r\n| 결합도 보통 | 제어 결합도(Control Coupling)  | 어떤 모듈이 다른 모듈의 내부 논리 조작을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 상위 모듈에 처리 명령을 부여하는 권리 전도 현상이 발생하게 된다.                                                                     |\r\n|             | 외부 결합도(External Coupling) | 어떤 모듈에서 외부로 선언한 변수(데이터)를 다른 모듈에서 참조할 경우와 관계된다.                                                                                                                                                                                                            |\r\n|             |  공통 결합도(Common Coupling)  | 여러 모듈이 공통 자료 영역을 사용하는 경우로 공통 데이터 영역 내용을 수정하면 이 데이터를 사용하는 모든 모듈에 영향을 준다.                                                                                                                                                                 |\r\n| 결합도 강함 | 내용 결합도(Content Coupling)  | 가장 강한 결합도를 가지고 있으며, 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 조회하도록 설계되었을 경우와 관계된다. 한 모듈에서 다른 모듈의 내부로 제어 또는 이동된다. 한 모듈이 다른 모듈 내부 자료의 조회 또는 변경이 가능하다. - 두 모듈이 같은 문자(Literals)의 공유가 가능하다. |\r\n\r\n### 응집도(Cohesion)\r\n\r\n- 명령어, 명령어의 모임, 호출문, 특정 작업 수행 코드 등 모듈 안의 요소들이 서로 관련된 정도를 말한다.\r\n- 구조적 설계에서 기능 수행 시 모듈 간 최소한의 상호작용을 하여 하나의 기능만을 수행하는 정도를 표현한다.\r\n- 모듈이 독립적인 기능으로 구성됨의 정도를 의미한다.\r\n- 응집도가 높다는 것은 필요한 요소들로 구성됨을 의미한다.\r\n- 응집도가 낮다는 것은 요소 간의 관련성이 적음을 의미한다.\r\n\r\n| 응집도      | 분류                                            | 특징                                                                                                     |\r\n| ----------- | ----------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\r\n| 응집도 약함 | 우연적 응집도(Coincidental Cohesion)            | 모듈 내부의 각 기능 요소들이 서로 관련이 없는 요소로만 구성된 경우와 관계된다.                           |\r\n|             | 논리적 응집도(Logical Cohesion)                 | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우와 관계된다.          |\r\n|             | 시간적 응집도(Temporal Cohesion)                | 특정 시간에 처리되는 여러 기능을 모아 한 개의 모듈로 작성할 경우와 관계된다.                             |\r\n|             | 절차적 응집도(Procedural Cohesion)              | 모듕리 다수의 관련 기능을 가질 때 모듈 내부의 기능 요소들이 그 기능을 순차적으로 수행할 경우와 관계된다. |\r\n|             | 통신적(교환적) 응집도(Communicational Cohesion) | 같은 입력과 출력을 사용하는 소 작업이 모인 경우와 관계된다.                                              |\r\n|             | 순차적 응집도(Sequential Cohesion)              | 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 요소의 입력 자료로 제공되는 경우와 관계된다.    |\r\n| 응집도 강함 | 기능적 응집도(Functional Cohesion)              | 모듈 내부의 모든 기능 요소들이 한 문제와 연관되어 수행되는 경우와 관계된다.                              |\r\n\r\n#### 모듈 설계의 특징\r\n\r\n바람직한 소프트웨어 설계는 응집도는 강하게, 결합도는 약하게 설계하여 모듈의 독립성을 확보할 수 있도록 한다.\r\n\r\n- 유지보수가 수월해야 하며 복잡도와 중복을 피하며 입구와 출구는 하나씩 갖도록 한다.\r\n- 모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.\r\n- 모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.\r\n- 적당한 모듈의 크기를 유지하고 모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.\r\n- 모듈의 크기가 작으면 모듈 개수가 증가하여 모듈 간 통합 비용이 증가하고, 모듈의 크기가 크면 단위 모듈 개발에 큰 비용과 시간이 소요된다.\r\n- 모듈 독립성이 높다는 것은 단위 모듈을 변경하더라도 타 모듈에 영향이 적다는 의미이며, 오류 발견과 해결이 쉬워진다.\r\n\r\n### 모듈과 컴포넌트\r\n\r\n- 모듈\r\n  - 자신만으로 동작할 수 있는 명령의 집합이다.\r\n  - 실제로 가장 맨 앞에 위치하는 구현된 단위이며 자료 구조, 알고리즘 등 이를 제공하는 인터페이스다.\r\n  - 정의하지 않는 이상 바로 재활용할 수 없다.\r\n- 컴포넌트\r\n  - SW 시스템에서 독립적인 업무 또는 기능을 수행하는 모듈로 교체가 가능한 부품이다.\r\n  - 모듈화로 생산성을 향상했으나 모듈의 소스 코드 레벨의 재활용으로 인한 한계성을 극복하기 위하여 등장하였다.\r\n  - 인터페이스를 통해서 연결된다.\r\n\r\n### 공통 모듈 - 명세 기법\r\n\r\n- 정확성(Correctness) : 실제 구현 시 꼭 필요한 기능인지 확인할 수 있도록 정확히 작성한다.\r\n- 명확성(명료성, Clearity) : 해당 기능에 대한 일관된 이해와 하나로 해석될 수 있도록 작성한다.\r\n- 완전성(Completeness) : 시스템 구현 시 필요한 것, 요구되는 것을 모두 작성한다.\r\n- 일관성(Consistency) : 공통 기능 간 서로 충돌이 발생하지 않도록 작성한다.\r\n- 추적성(Traceability) : 공통 기능에 대한 요구사항 출처, 관련 시스템이 유기적 관계 구분이 가능하도록 작성한다.\r\n\r\n# 소프트웨어 아키텍처(Software Architecture)\r\n\r\n- 요구사항을 기반으로 개발 대상 소프트웨어의 기본 틀(뼈대)을 만드는 것이다.\r\n- 다수의 이해관계자가 참여하는 복잡한 개발에서 상호 이해, 타협, 의사소통을 체계적으로 접근하기 위한 것이다.\r\n- 전체 시스템의 전반적인 구조를 체계적으로 설계하는 것이다.\r\n- 권형도(2004) : \"소프트웨어를 구성하는 컴포넌트들의 상호작용 및 관계, 각각의 특성을 기반으로 컴포넌트들이 상호 유기적으로 결합하는 소프트웨어의 여러 가지 원칙들의 집합\"이다.\r\n- 역할 : 설계 및 구현을 위한 구조적/비구조적인 틀(Frame)을 제공한다.\r\n- Structure Frame : 시스템 개발을 위하여 결정된 컴포넌트의 구조 모델이다.\r\n- Non Structure frame : 해당 구조 모델 이외 다른 아키텍처 설계의 결정들이다.\r\n\r\n### Software Architecture 특징\r\n\r\n- 간략성 : 이해하고 추론할 수 있을 정도로 간결해야 한다.\r\n- 추상화 : 시스템의 추상적인 표현을 사용한다.\r\n- 가시성 : 시스템이 포함해야 하는 것들을 가시화해야 한다.\r\n- 복잡도 관리 종류 : 과정 추상화, 데이터 추상화, 제어 추상화\r\n\r\n### MVC(Model View Controller) 패턴\r\n\r\n대화형 애플리케이션을 아래와 같이 3부분으로 분류한다.\r\n\r\n- Model : 핵심 기능 + 데이터\r\n- View : 사용자에게 정보 표시(다수 뷰가 정의될 수 있다.)\r\n- Controller : 사용자로부터 입력을 처리한다.\r\n\r\n### 클라이언트 서버(Client Server) 패턴\r\n\r\n- 하나의 서버와 다수 클라이언트로 구성되며, 클라이언트가 서버에 서비스를 요청하면 커뮤니케이션이 이루어진다. 서버는 응답을 위해 항상 대기 중이어야 한다.\r\n- 여러 컴포넌트에 걸쳐서 데이터와 데이터를 처리하는 애플리케이션에 적합하다.\r\n- 장점 : 직접 데이터 분산, 위치 투명성을 제공한다.\r\n- 단점 : 서비스와 서버의 이름을 관리하는 레지스터가 없어 이용 가능한 서비스 시간에 불편함을 초래한다.\r\n- 활용 : 이메일, 문서 공유, 은행 등 온라인 애플리케이션\r\n\r\n### 파이프 필터(Pipe-Filters)\r\n\r\n- 데이터 흐름(Data Stream - 데이터 송/수신이나 처리의 연속적 흐름)을 생성하고 처리하는 시스템을 위한 구조이다.\r\n- 필터는 파이프를 통해 받은 데이터를 변경시키고 그 결과를 파이프로 전송한다.\r\n- 각 처리 과정은 필터 컴포넌트에서 이루어지며, 처리되는 데이터는 파이프를 통해 흐른다. 이 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있다.\r\n- 컴파일러, 연속한 필터들은 어휘 분석, 파싱, 의미 분석 그리고 코드 생성을 수행한다.\r\n- 장점 : 필터 교환과 재조합을 통해서 높은 유연성을 제공한다.\r\n- 단점 : 상태정보 공유를 위해 비용이 소요되며 데이터 변환에 과부하가 걸릴 수 있다.\r\n- 활용 : 컴파일러, 어휘 분석, 구문 분석, 의미 분석, 코드 생성\r\n\r\n### Peer To Peer\r\n\r\n- 분산 컴퓨팅 애플리케이션 구축 시 유연성을 제공한다.\r\n- 클라이언트/서버 스타일레 대칭적 특징을 추가한 형태이다.\r\n- Peer가 하나의 컴포넌트로 대응되며 컴포넌트는 클라이언트, 서버 역할 모두 수행한다.\r\n\r\n### 이벤트 버스(Event - Bus)\r\n\r\n- 이벤트 버스 : 이벤트 생성(소스), 이벤트 수행(리스너), 이벤트 통로(채널), 채널 관리(버스)\r\n- 소스 이벤트가 메시지를 발행하면 해당 채널 구독자가 메시지 수신 후 해당 이벤트를 처리하는 방식으로 주로 이벤트를 처리하며 이벤트 소스, 이벤트 리스너(Event Listener), 채널, 이벤트 버스 등 4가지 주요 컴포넌트들을 갖는다.\r\n- 소스는 이벤트 버스를 통해 특정 채널로 메시지를 발행하고, 리스너는 특정 채널에서 메시지를 구독한다. 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.\r\n\r\n### 인터프리터(InterPreter)\r\n\r\n- SQL과 같은 데이터베이스 쿼리 언어, 통신 프로토콜을 정의하기 위한 언어\r\n- 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용된다.\r\n- 주로 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다.\r\n\r\n# 객체지향 설계 ★★★\r\n\r\n### 구조적 프로그래밍(Structured Programming)\r\n\r\n- 프로그램의 이해가 쉽고 디버깅 작업이 쉽다.\r\n- 한 개의 입구(입력)와 한 개의 출구(출력) 구조를 갖도록 한다.\r\n- GOTO(분기) 문은 사용하지 않는다.\r\n- 구조적 프로그래밍의 기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조, 반복(Iteration) 구조\r\n\r\n### 절차적 프로그래밍(Procedural Programming)\r\n\r\n- 순서대로 일련의 명령어를 나열하여 프로그래밍한다.\r\n- Function 기반의 프로그래밍이며, 프로시저로써 Function 외에도 Subroutine이 문법적으로 구현되어 있다.\r\n- 절차형 언어의 경우 규모가 커지면 커질수록 함수가 기하급수적으로 늘어난다.\r\n- 함수가 타 프로그램과 문제를 일으킬 수 있는 문제점을 가지고 있다.\r\n- 프로그램과 별개로 데이터 취급이 되므로 완전하지 않고 현실 세계 문제를 프로그램으로 표현하는데 제약이 있다.\r\n\r\n### 객체지향 프로그래밍(Object Oriented Programming)\r\n\r\n- 컴퓨터 소프트웨어를 구조적인 코드 단위로 보는 것이 아니라 Object 단위로 구분하고 Object 간의 모음으로 설계하는 것이다.\r\n- 소프트웨어 내의 Object는 서로 Message를 주고받는다.\r\n- 처리 요구를 받은 객체가 자기 자신 안에 있는 내용을 가지고 처리하는 방식이다.\r\n- 프로그램이 단순화되고 생산성, 신뢰성이 높아져 대규모 개발에 많이 사용된다.\r\n\r\n### 객체지향의 특징\r\n\r\n- 캡슐화(Encapsulation)\r\n  - 서로 관련성이 높은 데이터(속성)와 그와 관련된 기능(메서드, 함수)을 묶는 기법이다.\r\n  - 결합도가 낮아져 소프트웨어 개발에 있어 재사용성이 높아진다.\r\n  - 정보 은닉을 통하여 타 객체와 메시지 교환 시 인터페이스가 단순해진다.\r\n  - 변경 발생 시 오류의 파급 효과가 적다.\r\n- 상속성(Inheritance)\r\n  - 상위 클래스의 모든 속성, 연산을 하위 클래스가 재정의 없이 물려받아 사용하는 것이다.\r\n  - 상위 클래스는 추상적 성질을, 자식 클래스는 구체적 성질을 가진다.\r\n  - 하위 클래스는 상속받은 속성과 연산에 새로운 속성과 연산을 추가하여 사용할 수 있다.\r\n  - 다중 상속 : 다수 상위 클래스에서 속성과 연산을 물려받는 것이다.\r\n- 다형성(Polymorphism)\r\n  - 객체가 다양한 모양을 가지는 성질을 뜻한다.\r\n  - 오퍼레이션이나 속성의 이름이 하나 이상의 클래스에서 정의되고 각 클래스에서 다른 형태로 구현될 수 있는 개념이다.\r\n  - 속성이나 변수가 서로 다른 클래스에 속하는 객체를 지칭할 수 있는 성질이다.\r\n- 추상화(Abstraction)\r\n  - 시스템 내의 공통 성질을 추출한 뒤 추상 클래스를 설정하는 기법이다.\r\n  - 현실 세계를 컴퓨터 시스템에 자연스럽게 표현할 수 있다.\r\n  - 종류 : 기능 추상화, 제어 추상화, 자료 추상화\r\n- 정보은닉(Information Hiding)\r\n  - 객체 내부의 속성과 메서드를 숨기고 공개된 인터페이스를 통해서만 메시지를 주고받을 수 있도록 하는 것을 의미한다.\r\n  - 예기치 못한 SideEffect를 줄이기 위해 사용한다.\r\n\r\n### 오버로딩(Overloading)과 오버라이딩(Overriding)\r\n\r\n- 오버로딩\r\n  - 사전적 의미 : 과적, 과부하\r\n  - 한 클래스 내에서 같은 이름의 메서드를 사용하는 것\r\n  - 같은 이름의 메서드를 여러 개 정의하면서 매개 변수의 유형과 개수가 달라지도록 하는 기술\r\n- 오버라이딩\r\n  - 사전적 의미 : 가장 우선되는, 최우선으로 되는, 다른 것보다 우선인\r\n  - 상속 관계의 두 클래스의 상위 클래스에서 정의한 메서드를 하위 클래스에서 변경(재정의)하는 것\r\n  - JAVA 언어에서는 static 메서드의 오버라이딩을 허용하지 않는다.\r\n  - 오버라이딩의 경우 하위 객체의 매개 변수 개수와 타입은 상위 객체와 같아야 한다.\r\n\r\n### 객체지향 설계 원칙(SOLID)\r\n\r\n1. 단일 책임의 원칙\r\n   - (SRP : Single Responsibility Principle)\r\n   - 모든 클래스는 단일 목적으로 생성되고, 하나의 책임만 가져야 한다.\r\n2. 개방 - 폐쇄의 원칙\r\n   - (OCP : Open Closed Principle)\r\n   - 소프트웨어 구성 요소는 확장에 대해서는 개방되어야 하나 수정에 대해서는 폐쇄적이어야 한다.\r\n3. 리스코프치환 원칙\r\n   - (LSP : Liskov Substitution Principle)\r\n   - 부모 클래스가 들어갈 자리에 자식 클래스를 대체하여도 계획대로 작동해야 한다.\r\n4. 인터페이스 분리 원칙\r\n   - (ISP : Interface Segregation Principle)\r\n   - 클라이언트는 자신이 사용하지 않는 메서드와 의존 관계를 맺으면 안 된다.\r\n   - 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안 된다.\r\n5. 의존 역전 원칙\r\n   - (DIP : Dependency Inversion Principle)\r\n   - 의존 관계를 맺으면 변하기 쉽고 변화 빈도가 높은 것보다 변하기 어렵고 변화 빈도가 낮은 것에 의존한다.\r\n\r\n# 디자인 패턴\r\n\r\n- 자주 사용하는 설계 형태를 정형화하여 유형별로 설계 템플릿을 만들어 두고 소프트웨어 개발 중 나타나는 과제를 해결하기 위한 방법 중 한 가지다.\r\n- 다양한 응용 소프트웨어 시스템들을 개발할 때 서로 간에 공통점이 있으며, 이러한 유사점을 패턴이라 한다.\r\n- 개발자 간 원활한 의사소통, 소프트웨어 구조 파악 용이, 설계 변경에 대한 유연한 대처, 개발의 효율성, 유지보수성, 운용성 등 소프트웨어 품질 향상에 도움을 준다.\r\n- 객체지향 프로그래밍 설계 시 유사한 상황에서 구조적인 문제를 해결할 수 있도록 방안을 제공해주며, Gof(Gang of Four) 분류가 가장 많이 사용된다.\r\n\r\n### 디자인 패턴을 사용할 때의 장/단점\r\n\r\n장점\r\n\r\n- 개발자 간의 월활한 의사소통을 지원한다.\r\n- 소프트웨어 구조 파악이 쉽다.\r\n- 재사용을 통한 개발 시간을 단축할 수 있다.\r\n- 설계 변경 요청에 대해 유연하게 대처할 수 있다.\r\n- 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.\r\n\r\n단점\r\n\r\n- 객체지향 설계/구현 위주로 사용된다.\r\n- 초기 투자 비용이 부담된다.\r\n\r\n### 디자인 패턴의 구성 요소\r\n\r\n- 필수 요소\r\n  - 패턴의 이름 : 패턴을 부를 때 사용하는 이름과 패턴의 유형\r\n  - 문제 및 배경 : 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미\r\n  - 해법 : 패턴을 이루는 요소들, 관계, 협동(Collaboration) 과정\r\n  - 결과 : 패턴을 사용하면 얻게 되는 이점이나 영향\r\n- 추가 요소\r\n  - 알려진 사례 : 간단한 적용 사례\r\n  - 샘플 코드 : 패턴이 적용된 원시 코드\r\n  - 원리, 정당성, 근거\r\n\r\n### GoF(Gangs of Four) 디자인 패턴\r\n\r\n- 에릭 감마, 리처드 헬름, 랄프 존슨, 존 브리시데스가 제안\r\n- 객체지향 설계 단계 중 재사용에 관한 유용한 설계를 디자인 패턴화하였다.\r\n- 생성 패턴, 구조 패턴, 행위 패턴으로 분류한다.\r\n\r\n#### 생성 패턴\r\n\r\n- 객체를 생성하는 것과 관련된 패턴이다.\r\n- 객체의 생성과 변경이 전체 시스템에 미치는 영향은 최소화하도록 만들어주어 유연성을 높일 수 있고 코드를 유지하기가 쉬운 편이다.\r\n- 객체의 생성과 참조 과정을 추상화함으로써 시스템을 개발할 때 부담을 덜어준다.\r\n- 구성\r\n  - Factory Method\r\n    - 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클레스에서 인스턴스를 생성하도록 하는 방식이다.\r\n    - Virtual-Constructor 패턴이라고도 한다.\r\n  - Singleton\r\n    - 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 한다.\r\n    - 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴이다.\r\n  - Prototype\r\n    - prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.\r\n    - 일반적인 방법으로 객체를 생성한다.\r\n    - 비용이 많이 소요되는 경우 주로 사용한다.\r\n  - Builder\r\n    - 작게 분리된 인스턴스를 조립하듯 조합하여 객체를 생성한다.\r\n  - Abstraction Factory\r\n    - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다.\r\n    - 관련된 서브 클래스를 그룹 지어 한 번에 교체할 수 있다.\r\n\r\n#### 구조 패턴\r\n\r\n- 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이다.\r\n- 복잡한 형태의 구조를 갖는 시스템을 개발하기 쉽게 만들어주는 패턴이다.\r\n- 새로운 기능을 가진 복합 객체를 효과적으로 작성할 수 있다.\r\n  - ex. 서로 다른 인터페이스를 지닌 2 개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다. 프로그램 내의 자료 구조나 인터페이스 구조 등 구조를 설계하는데 많이 활용된다.\r\n- 구성\r\n  - Adapter\r\n    - 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해준다.\r\n    - 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.\r\n  - Bridge\r\n    - 큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층구조(추상화 및 구현)로 나눈 후 각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴\r\n    - 기능 클래스 계층과 구현 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 각자 독립적으로 변혈할 수 있도록 해주는 패턴이다.\r\n  - Composite(복합체)\r\n    - 객체들을 트리 구조들로 구성한 후, 이러한 구조들과 개별 객체들처럼 작업할 수 있도록 하는 구조 패턴\r\n  - Decorator\r\n    - 객체들을 새로운 행동들을 포함한 특수 래퍼 객체들 내에 넣어서 위 행동들을 해당 객체들에 연결시키는 구조적 디자인 패턴\r\n  - Facade(퍼사드)\r\n    - 라이브러리에 대한, 프레임워크에 대한 또는 다른 클래스들의 복잡한 집합에 대한 단순화된 인터페이스를 제공하는 구조적 디자인 패턴\r\n  - Flyweight\r\n    - 각 객체에 모든 데이터를 유지하는 대신 여러 객체들 간에 상태의 공통 부분들을 공유하여 사용할 수 있는 RAM에 더 많은 객체들을 포함할 수 있도록 하는 구조 디자인 패턴\r\n  - Froxy\r\n    - 다른 객체에 대한 대체 또는 자리표시자를 제공할 수 있는 구조 디자인 패턴\r\n    - 프록시는 원래 객체에 대한 접근을 제어하므로, 자신의 요청이 원래 객체에 전달되기 전 또는 후에 무언가를 수행할 수 있도록 함.\r\n\r\n### 행위 패턴\r\n\r\n- 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.\r\n- 메시지 교환과 관련된 것으로, 객체 간의 행위나 알고리즘 등과 관련된 패턴을 말한다.\r\n- 구성\r\n  - Chain of Responsibility(책임 연쇄)\r\n    - 핸들러들의 체인(사슬)을 따라 요청을 전달할 수 있게 해주는 행동 디자인 패턴\r\n    - 각 핸들러는 요청을 받으면 요청을 처리할지 아니면 체인의 다음 핸들러로 전달할지를 결정\r\n  - Iterator(반복자)\r\n    - 컬렉션의 요소들의 기본 표현(리스트, 스택, 트리 등)을 노출하지 않고 그들을 하나씩 순회할 수 있도록 하는 행동 디자인 패턴\r\n  - Command(명령)\r\n    - 요청을 요청에 대한 모든 정보가 포함된 독립실행형 객체로 변환하는 행동 디자인 패턴\r\n    - 이 변환은 다양한 요청들이 있는 메서드들을 인수화 할 수 있도록 하며, 요청의 실행을 지연 또는 대기열에 넣을 수 있도록 하고, 또 실행 취소할 수 있는 작업을 지원할 수 있도록 함.\r\n  - Interpreter(해석자)\r\n    - 단순한 언어를 해석할 때 유용한 패턴\r\n    - 간단한 언어의 문법을 정의하고 해석하는 패턴\r\n    - 언어가 주어지면 해당 표현을 사용하여 언어로 문장을 해석하는 인터프리터를 사용하여 문법 표현을 정의하는 방법\r\n  - Memento(기록)\r\n    - 메멘토 패턴은 객체를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴\r\n    - 오리지네이터, 케어테이커, 메멘토 등 3개의 객체로 구현된다.\r\n    - 오리지네이터 : 내부 상태를 보유하고 있는 일부 객체\r\n  - Observer(감시자)\r\n    - 여러 객체에 자신이 관찰 중인 객체에 발생하는 모든 이벤트에 대해 알리는 구독 매커니즘을 정의할 수 있도록 하는 행동 디자인 패턴(관찰자)\r\n  - State(상태)\r\n    - 객체의 내부 상태가 변경될 때 해당 객체가 그의 행동을 변경할 수 있도록 하는 행동 디자인패턴\r\n    - 객체가 행동을 변경할 때 객체가 클래스를 변경한 것처럼 보일 수 있음\r\n  - Strategy(전략)\r\n    - 패턴은 알고리즘들의 패밀리를 정의하고, 각 패밀리를 별도의 클래스에 넣은 후 그들의 객체들을 상호교환할 수 있도록 하는 행동 디자인 패턴\r\n  - Visitor(방문자)\r\n    - 알고리즘들을 그들이 작동하는 객체들로부터 분리할 수 있도록 하는 행동 디자인 패턴\r\n  - Template Method\r\n    - 부모 클래스에서 알고리즘의 골격을 정의하지만, 해당 알고리즘의 구조를 변경하지 않고 자식 클래스들이 알고리즘의 특정 단계들을 오버라이드(재정의)할 수 있도록 하는 행동 디자인 패턴\r\n  - Mediator(중재자)\r\n    - 객체 간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다.\r\n    - Virual-Constructor 패턴이라고도 한다.\r\n    - 객체 간의 혼란스러운 의존 관계들을 줄일 수 있는 행동 디자인 패턴\r\n    - 패턴은 객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 협력하도록 한다.\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n"}]},"__N_SSG":true},"page":"/sw","query":{},"buildId":"XtXKFWqeTji0t4y80ckoo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>