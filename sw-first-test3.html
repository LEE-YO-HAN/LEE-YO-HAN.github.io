<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Hanbbi<!-- -->&#x27;<!-- -->s DevLog</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="정보처리기사 필기(3) - DB 구축"/><meta name="keywords" content="sw, sw first test3, 정보처리기사, 정처기, 필기, DB 구축"/><meta http-equiv="title" content="정보처리기사 필기(3) - DB 구축"/><meta http-equiv="subject" content="sw"/><meta property="og:title" content="sw first test3"/><meta property="og:description" content="정보처리기사 필기(3) - DB 구축"/><meta property="og:image" content="/images/cards/SW.png"/><meta name="naver-site-verification" content="af9c8049662a7c6c85ea946e9eb561086e70062c"/><meta name="google-site-verification" content="Zgp7rA3RAdcRnhPPsGLK-t4KVTO86AejlDIQQIGpvLg"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4077287316160146" crossorigin="anonymous"></script><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="14"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/f9bc783e634631d2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f9bc783e634631d2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7d0bddee48749f95.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-b0c8bcfd40968c52.js" defer=""></script><script src="/_next/static/chunks/pages/_app-75e0f90c6bcb24ce.js" defer=""></script><script src="/_next/static/chunks/235-2e07634c3cd78c71.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-d0432a4b187b0b46.js" defer=""></script><script src="/_next/static/K8nG0fk5J7F1j1N6vDjxZ/_buildManifest.js" defer=""></script><script src="/_next/static/K8nG0fk5J7F1j1N6vDjxZ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-c845a976-0 icUnkm"><header class="sc-c62045a0-0 ejGrOn"><span style="display:none" class="sc-c62045a0-1 kkIswC"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 17 17" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g></g><path d="M16 3v2h-15v-2h15zM1 10h15v-2h-15v2zM1 15h15v-2h-15v2z"></path></svg></span><h1><a href="/">Hanbbi<!-- -->&#x27;<!-- -->s DevLog</a></h1><nav style="transform:translateX(-100%)" class="sc-e9bb2eba-0 extUal"><div class="sc-e9bb2eba-1 eDAIOV"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M405 136.798L375.202 107 256 226.202 136.798 107 107 136.798 226.202 256 107 375.202 136.798 405 256 285.798 375.202 405 405 375.202 285.798 256z"></path></svg></div><ul class="sc-e9bb2eba-2 kjvNul"><div><p class="sc-e9bb2eba-3 bvmfTl">FE</p><li class="sc-e9bb2eba-4 bSVRxo"><a href="/html">HTML</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/css">CSS</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/javascript">JavaScript</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/typescript">TypeScript</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/redux">Redux</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/react">React</a></li><li class="sc-e9bb2eba-4 bSVRxo"><a href="/nextjs">Nextjs</a></li></div><div><p class="sc-e9bb2eba-3 bvmfTl">BE</p><li class="sc-e9bb2eba-4 bSVRxo"><a href="/nestjs">Nestjs</a></li></div><div><p class="sc-e9bb2eba-3 bvmfTl">CS</p><li class="sc-e9bb2eba-4 bSVRxo"><a style="color:white;font-weight:bold" href="/sw">정보처리기사</a></li></div><div><p class="sc-e9bb2eba-3 bvmfTl">ETC</p><li class="sc-e9bb2eba-4 bSVRxo"><a href="/github">Simple Memo</a></li></div></ul></nav></header><section class="sc-c845a976-1 bePtAz"><aside class="sc-226f6af7-0 jzKfYm"><div class="sc-226f6af7-1 eudLNA"><a target="_blank" href="https://portfolio-sigma-wheat-63.vercel.app/"><img alt="profile" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" src="/images/profileImage/cat.png"/><span>Go Profile!</span></a><p>Hanbbi</p></div><div class="sc-226f6af7-2 fEJwOM"><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0 0 68.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"></path></svg><span>yhl0078@gmail.com</span></a><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>Github</span></a></div></aside><article class="sc-c845a976-2 jRRSKe"><main class="sc-39211eb-0 hLWqGG"><section class="sc-39211eb-1 cLKxEH"><p>정보처리기사</p><h1>정보처리기사 필기(3) - DB 구축</h1><span>2023-12-26</span></section><main class="sc-39211eb-2 kPnWiO"><div class="markdown"><h2>필기 시험 공략</h2>
<p>개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.</p>
<p>구글 앱 스토어에서 &quot;<strong>정보처리기출문제</strong>&quot;라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.</p>
<p>나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.</p>
<p>표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.</p>
<ol>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84">소프트웨어 설계</a></p>
</li>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C">소프트웨어 개발</a></p>
</li>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95">DB구축</a></p>
</li>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9">프로그래밍 언어 활용</a></p>
</li>
<li>
<p><a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC">정보시스템 구축 관리</a></p>
</li>
</ol>
<p>본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.</p>
<hr/>
<h1>자료 구조</h1>
<h3>자료 구조의 분류</h3>
<ol>
<li>선형 구조<!-- -->
<ul>
<li>리스트<!-- -->
<ul>
<li>선형 리스트</li>
<li>연결 리스트</li>
</ul>
</li>
</ul>
</li>
<li>비선형 구조<!-- -->
<ul>
<li>트리</li>
<li>그래프</li>
</ul>
</li>
</ol>
<h3>자료 구조의 활용</h3>
<ul>
<li>정렬<!-- -->
<ul>
<li>집합된 데이터 레코드를 일정 기준으로 재배열하는 것.</li>
<li>오름차순, 내림차순</li>
</ul>
</li>
<li>검색<!-- -->
<ul>
<li>저장된 데이터 레코드 중 원하는 값을 빠르게 찾는 것</li>
</ul>
</li>
<li>인덱스(Index)<!-- -->
<ul>
<li>데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로, 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 별도로 구성한 순서 데이터를 말한다. (ex. 책의 맨 뒤에 빠르게 찾기 등)</li>
<li>B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있다.</li>
<li>BETWEEN 등 범위(Range) 검색에 활용될 수 있다.</li>
</ul>
</li>
<li>파일 편성<!-- -->
<ul>
<li>파일에서 레코드의 물리적인 배열 방법이다.</li>
</ul>
</li>
</ul>
<h2>선형 자료 구조</h2>
<h3>리스트(List)</h3>
<ul>
<li>선형 리스트(Linear List)<!-- -->
<ul>
<li>배열(Array)과 같이 연속되는 기억 장소에 저장되는 리스트이다.</li>
<li>가장 간단한 데이터 구조 중 하나로 데이터 항목을 추가 삭제하는 것이 불편하다.</li>
</ul>
</li>
<li>연결 리스트(Linked List)<!-- -->
<ul>
<li>노드의 포인터 부분을 서로 연결시킨 리스트로, 연속적인 기억 공간이 없어도 저장이 가능하다.</li>
<li>노트의 삽입/삭제가 용이하며 포인터를 위한 추가 공간이 필요하므로 기억 공간이 많이 소요된다.</li>
</ul>
</li>
</ul>
<h3>스택(Stack)</h3>
<ul>
<li>리스트의 한쪽 끝에서만 자료의 삽입과 삭제가 이루어 지는 자료 구조이다.</li>
<li>가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO, Last In First Out) 방식이다.(PUSH and POP)</li>
<li>마지막 삽입된 자료의 위치를 Top이라 하고, 가장 먼저 삽입된 자료의 위치를 Bottom이라고 한다.</li>
<li>스택 가능 : 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술이다.</li>
<li>스택 응용 분야<!-- -->
<ul>
<li>인터럽트 처리, 수식의 계산, 0-주소 지정 방식</li>
<li>재귀호출, 후위 표현(Post-fix expression)의 연산, 깊이 우선 탐색</li>
</ul>
</li>
</ul>
<p><strong>스택의 삽입 알고리즘</strong></p>
<pre><code node="[object Object]">
if TOP &gt;= n then call Stack-Full;
else TOP = TOP + 1;
Stack(TOP) = Data;
end Insert

</code></pre>
<p><strong>스택의 삭제 알고리즘</strong></p>
<pre><code node="[object Object]">if TOP = 0
then Underflow
Else
Remove S(TOP)
TOP = TOP - 1
</code></pre>
<p><strong>스택의 오버플로 알고리즘</strong></p>
<pre><code node="[object Object]">TOP &lt;- TOP + 1
if TOP &gt; n then goto AA
else Stack(TOP) &lt;- item
</code></pre>
<h3>큐(Queue)</h3>
<ul>
<li>자료의 삽입 작업은 선형 리스트의 한쪽 끝에서, 제거 작업은 다른 쪽 끝에서 수행되는 자료 구조이다.</li>
<li>가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO: First In First Out) 방식이다.</li>
<li>큐의 응용 분야 : 운영체제의 작업 스케줄링 등에서 응용된다.</li>
</ul>
<h3>덱(Deque)</h3>
<ul>
<li>자료의 삽입과 삭제가 리스트의 양쪽 끝에서 이루어지므로 두 개의 포인터를 사용하는 자료 구조이다.</li>
<li>스택과 큐를 복합한 형태이다.</li>
<li>입력 제한 덱을 Scroll, 출력 제한 덱을 Shelf라고 한다.</li>
</ul>
<h2>비선형 구조</h2>
<h3>트리(Tree)</h3>
<ul>
<li>그래프(Graph)의 특수한 형태로써 노드(Node)와 브랜치(Branch)를 이용하여 사이클을 이루지 않도록 구성한 자료 구조이다.</li>
</ul>
<h3>이진 트리(Binary Tree)</h3>
<ul>
<li>차수(Degree)가 이 이하인 노트들로만 구성된 트리</li>
<li>이 트리의 레벨 n에서 최대 노드의 수 : 2ⁿ-1</li>
<li>깊이(레벨)가 4인 트리의 최대 노드 수는 2⁴-1로, 15이다.</li>
<li>구조<!-- -->
<ul>
<li>정이진 트리 : 첫 번째 레벨부터 마지막 레벨까지 모두 2개씩 채워진 트리를 말한다.</li>
<li>전이진 트리 : 전이진 트리에서 한쪽 방향 노드가 아예 존재하지 않는 트리를 말한다.</li>
<li>사향 이진 트리 : 근노드로부터 한쪽 방향으로만 기울어진 트리를 말한다.</li>
</ul>
</li>
</ul>
<h3>그래프</h3>
<ul>
<li>정점(Vertex)과 간선(Edge)의 집합으로 이루어지는 자료 구조.</li>
<li>표현 방법 : 인접 행렬(Adjacency Matrix)</li>
<li>신장 트리(Spanning Tree) : 간선들이 사이클을 이루지 않도록 정점들을 연결시킨 그래프이다.</li>
<li>종류 : 방향 그래프, 무방향 그래프, 완전 그래프, 부 그래프</li>
<li>n개의 노드로 구성된 무방향 그래프의 최대 간선 수는 n(n-1)/2개다.</li>
<li>제어 흐름 스래프에서 순환 복잡도 : V(G) - E(화살표 수) - N(노드 수) + 2</li>
</ul>
<h3>인접 행렬(Adjacency Matrix)</h3>
<ul>
<li>방향 그래프에서 ViVj 관계를 나타내는 행렬의 원소를 Aij라고 할 때, 방향 간선이 있으면 행렬의 Aij = 1, 방향 간선이 없으면 행렬의 Aij = 0 으로 나타낸다.</li>
<li>무방향 그래프에서 Vi와 Vj가 서로 인접하면 Aij = 1, 서로 인접하지 않으면 Aij = 0으로 나타낸다.</li>
<li>여기서 i, j는 첨자 (A₃의 3과 같음)</li>
</ul>
<h1>정렬(Sort)</h1>
<ul>
<li>정렬 알고리즘 선택 시 고려사항 : 데이터의 양, 초기 데이터의 배열 상태, 키 값들의 분포 상태, 사용 컴퓨터 시스템의 특성</li>
<li>종류 : 내부 정렬(장치에서 정렬이 이루어짐), 외부 정렬(보조 기억 장치에서 정렬이 이루어짐)</li>
</ul>
<h3>삽입 정렬(Insertion Sort)</h3>
<ul>
<li>정렬된 파일에 새로운 하나의 레코드를 순서에 따라 삽입시켜 정렬하는 방법</li>
</ul>
<h3>선택 정렬(Selection Sort)</h3>
<ul>
<li>n개의 레코드 중에서 최소값(또는 최대값)을 찾아 1st 레코드 위치에 놓고, 나머지 (n-1) 개의 레코드 중에서 최소값(또는 최대값)을 찾아 2nd 레코드 위치에 놓는 방법을 반복하여 정렬하는 방법이다.</li>
<li>최대, 최소, 평균 시간 복잡도 : O(n²)</li>
</ul>
<h3>병합 정렬(2-Way Merge Sort)</h3>
<ul>
<li>두 개의 키들을 한 쌍으로 하여 각 쌍에 대해 순서를 정한다.</li>
<li>순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브 리스트로 만든다.</li>
<li>최대, 최소, 평균 시간 복잡도 : O(n log₂ n)</li>
</ul>
<h3>퀵 정렬(Quick Sort)</h3>
<ul>
<li>레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어가면서 정렬하는 방법으로, 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽에 모이도록 서로 교환시키는 부분 교환 정렬법이다.</li>
<li>최대, 최소, 평균 시간 복잡도 : O(n log₂ n), 약=O(n²)</li>
</ul>
<h3>힙 정렬(Heap Sort)</h3>
<ul>
<li>전이진 트리를 이용하여 정렬하는 방법이다.</li>
<li>정렬한 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다.</li>
<li>평균 수행 시간 복잡도는 O(n log₂ n)이고, 최악의 수행 시간 복잡도는 O(log₂ n)이다.</li>
<li>입력 자료의 레코드를 완전 이진 트리(Complete Binary Tree)로 구성한다.</li>
</ul>
<h1>검색(Search)과 해싱(Hashing)</h1>
<h3>검색</h3>
<ul>
<li>
<p>기억 공간 내 기억된 자료 중에서 주어진 조건을 만족하는 자료를 찾는 것</p>
</li>
<li>
<p>이분 검색(Binary Search, 이진 검색)</p>
<ul>
<li>이분 검색을 실행하기 위한 전제 조건은 자료가 순차적으로 정렬되어 있어야 한다.</li>
<li>탐색 효율이 좋고 탐색 시간이 적게 소요된다.</li>
<li>비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.</li>
</ul>
</li>
<li>
<p>선형 검색(Linear Search)</p>
<ul>
<li>순차 검색(Sequential Search)이라고도 한다.</li>
<li>주어진 자료에서 원소를 첫 번째 레코드부터 순차적으로 비교하면서 해당키 값을 가진 레코드를 찾아내는 가장 간단한 검색 방법이다.</li>
<li>데이터를 특별히 조직화할 필요가 없고 다양한 상황에서도 사용될 수 있는 장점이 있지만 N개의 입력 자료에 대해서 평균적으로 (n+1)/2번의 비교를 해야 하므로 비효율적이다.</li>
</ul>
</li>
<li>
<p>피보나치 검색(Fibonacci Search)</p>
<ul>
<li>이진 검색과 비슷한 원리로, 비교 대상 기준을 피보나치 수열로 결정한다.</li>
<li>피보나치 수열 : 1,2,3,5,8,11~로 앞의 두 수의 합이 다음 번 값이 된다.</li>
</ul>
</li>
<li>
<p>블록 검색</p>
<ul>
<li>전체 레코드를 일정한 블록으로 분리한 뒤 각 블록 내의 키값을 순서대로 비교하여 원하는 값을 찾는 기법이다.</li>
</ul>
</li>
<li>
<p>이진 트리 검색</p>
<ul>
<li>레코드를 2진 트리로 구성하여 검색하는 방식으로 데이터를 입력하는 순서대로 첫 번째 값을 근노드로 지정하고 근노드보다 작으면 왼쪽, 크면 오른쪽에 연결하여 구성한다.</li>
</ul>
</li>
</ul>
<h3>해싱</h3>
<ul>
<li>
<p>해싱 함수(Hashing Function)를 이용하여 레코드키에 대한 해시 테이블(Hash Table) 내의 홈 주소(Home Address)를 계산하여 주어진 레코드에 접근하는 방식이다.</p>
</li>
<li>
<p>직접 접근(Direct Access Method) 파일을 구성할 때 사용된다.</p>
</li>
<li>
<p>속도는 가장 빠르지만 충돌 현상 시 오버플로우 해결의 부담이 가중되며, 많은 기억 공간을 요구한다.</p>
</li>
<li>
<p>제산 방법(Division Method)</p>
<ul>
<li>해싱 함수 기법에서 키값을 양의 정수인 소수로 나누어 나머지를 홈주소로 취하는 방법이다.</li>
</ul>
</li>
<li>
<p>중간 제곱 방법(Mid-Square Method)</p>
<ul>
<li>레코드 키값을 제곱하고 나서 그 중간 부분의 값을 주소로 계산하는 방법이다.</li>
<li>해시 테이블의 크기에 따라서 중간 부분의 적당한 자릿수를 선택할 수 있다.</li>
<li>비트 단위로 n 자릿수를 중간 위치 자릿수로 가정하면 해시 테이블의 크기는 2n이다.</li>
</ul>
</li>
<li>
<p>중첩 방법(Folding Method)</p>
<ul>
<li>해싱 함수 중 주어진 키를 여러 부분으로 나누고, 각 부분의 값을 더하거나 배타적 논리합(XOR: Exclusive OR) 연산을 통하여 나온 결과로 주소를 취하는 방법이다.</li>
</ul>
</li>
<li>
<p>기수 변환 방법(Radix Conversion Method)</p>
<ul>
<li>해싱 함수 기법 중 어떤 진법으로 표현된 주어진 레코드 키값을 다른 진법으로 간주하고 키값을 변환하여 홈주소로 취하는 방식이다.</li>
</ul>
</li>
<li>
<p>계수 분석 방법(Digit Analysis Method)</p>
<ul>
<li>주어진 모든 키값들에서 그 키를 구성하는 자릿수들의 분포를 조사하여 비교적 고른 분포를 보이는 자릿수들을 필요한 만큼 택하는 방법을 취하는 해싱 함수 기법이다.</li>
</ul>
</li>
</ul>
<h1>데이터베이스(Database) ★★★</h1>
<h3>데이터베이스의 정의</h3>
<ul>
<li>통합된 데이터(Integrated Data) : 각 사용자의 데이터를 한 곳에 모아 통합한 데이터이다.</li>
<li>저장된 데이터(Stored Data) : 데이터베이스는 컴퓨터 하드웨어 저장 장치에 저장되어 있는 데이터이다.</li>
<li>운영 데이터(Operational Data) : 데이터베이스는 어떤 조직의 고유 기능을 수행하기 위해 반드시 필요한 데이터이다.</li>
<li>공용 데이터(Shared Data) : 데이터베이스를 여러 사용자가 공동 소유/관리/활용하는 데이터이다.</li>
</ul>
<h3>데이터베이스의 특성</h3>
<ul>
<li>실시간 접근성(Real Time Accessibility) : 수시적이고 비정형적인 질의에 대하여 실시간 처리로 응답할 수 있어야 한다.</li>
<li>내용에 의한 참조(Content Reference) : 데이터베이스의 데이터는 그 주소나 위치에 의해 참조되는 것이 아니라 내용을 참조한다.</li>
<li>동시 공유(Concurrent Sharing) : 같은 내용의 데이터를 여러 사람이 동시에 공용할 수 있다.</li>
<li>계속적 변화(Continuous Evolution) : 데이터베이스는 데이터의 삽입, 삭제, 갱신으로 내용이 계속적으로 변한다.</li>
<li>구성 : DBMS, 스키마, 데이터베이스 언어, 데이터베이스 사용자로 구성되어있다.</li>
</ul>
<h2>DBMS(DataBase Management System, 데이터베이스 관리 시스템)</h2>
<ul>
<li>종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다.</li>
<li>응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리한다.</li>
<li>데이터베이스의 구성, 접근 방법, 관리 유지에 대한 모든 책임을 진다.</li>
</ul>
<h3>DBMS의 필수 기능</h3>
<ul>
<li>정의 기능(Definition Facility)<!-- -->
<ul>
<li>데이터베이스 구조를 정의한다.</li>
<li>데이터의 논리적 구조와 물리적 구조 사이에 변환이 가능하도록 두 구조 사이의 사상(Mapping)을 명시한다.</li>
</ul>
</li>
<li>조작 기능(Manipulation Facility)<!-- -->
<ul>
<li>데이터베이스에 접근하여 데이터의 검색/삽입/삭제/갱신 등의 연산 적업을 하기 위한 사용자와 데이터베이스 사이의 인터페이스 수단을 제공한다.</li>
</ul>
</li>
<li>제어 기능(Control Facility)<!-- -->
<ul>
<li>데이터베이스에 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 무결성이 유지되도록 제어해야 한다.</li>
<li>정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안(Security)을 유지하고, 권한(Authority)을 검사할 수 있어야 한다.</li>
<li>여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때 처리 결과가 항상 정확성을 유지하도록 병행 제어를 할 수 있도록 한다.</li>
</ul>
</li>
</ul>
<h3>DBMS의 장/단점</h3>
<ul>
<li>장점<!-- -->
<ul>
<li>데이터의 중복 및 종속성 최소화</li>
<li>데이터 공유</li>
<li>데이터 무결성 및 일관성 유지</li>
<li>데이터 보안 보장 용이</li>
</ul>
</li>
<li>단점<!-- -->
<ul>
<li>예비와 회복 기법이 어려움</li>
<li>데이터베이스 전문가 부족</li>
<li>시스템이 복잡하고, 전산화 비용 증가</li>
</ul>
</li>
</ul>
<h3>데이터베이스 용어(일부)</h3>
<ul>
<li>빅데이터 : 데이터의 생성 양, 주기, 형식 등이 기존 데이터에 비해 매우 크기 때문에, 종래의 방법으로는 수집/저장/검색/분석이 어려운 방대한 데이터이다.</li>
<li>데이터 마이닝 : 데이터웨어하우징에서 수집되고 분석된 자료를 사용자에게 제공하기 위해 분류 및 가공되는 요소 기술이다.</li>
<li>Hadoop : 일반 컴퓨터로 가상화된 대형 스토리지를 구현한다. 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 빅데이터 분산 처리를 돕는 자바 소프트웨어 오픈소스 프레임워크이다.</li>
</ul>
<h2>데이터베이스의 구성</h2>
<h3>스키마</h3>
<ul>
<li>데이터베이스의 구조(개체, 속성, 관계)에 대한 정의이다.</li>
</ul>
<h4>스키마의 3계층</h4>
<ul>
<li>외부 스키마(External Schema)<!-- -->
<ul>
<li>사용자나 응용 프로그래머가 접근할 수 있는 정의르 기술한다.</li>
</ul>
</li>
<li>개념 스키마(Conceptual Schema)<!-- -->
<ul>
<li>데이터베이스 전체를 정의한 것으로 데이터 개체, 관계, 제약조건, 접근 권한, 무결성 규칙 등을 명세한 것이다.</li>
<li>범기관적 입장에서 데이터베이스를 정의한다.</li>
</ul>
</li>
<li>내부 스키마(Internal Schema)<!-- -->
<ul>
<li>데이터의 실제 저장 방법을 기술한다.</li>
<li>물리적 저장 장치의 입장에서 본 데이터베이스 구조로써 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.</li>
</ul>
</li>
</ul>
<h3>데이터베이스 언어(Database Language)</h3>
<ul>
<li>데이터 정의어(DDL : Data Definition Language)<!-- -->
<ul>
<li>데이터베이스의 객체들, 즉 테이블, 뷰, 인덱스 등에 대한 구조인 스키마를 정의하고 변경하며 삭제할 수 있는 기능이 있다.</li>
<li>논리적 데이터 구조와 물리적 데이터 구조 간의 사상 정의이다.</li>
<li>번역한 결과가 데이터 사전에 저장된다.</li>
</ul>
</li>
<li>데이터 조작어(DML : Data Manipulation Language)<!-- -->
<ul>
<li>사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.</li>
<li>데이터의 검색/삽입/삭제/변경을 구행한다.</li>
</ul>
</li>
<li>데이터 제어어(DCL : Data Control Language)<!-- -->
<ul>
<li>불법적인 사용자로부터 데이터를 보호한다.</li>
<li>무결성을 유지한다.</li>
<li>데이터 회복 및 병행 제어를 수행한다.</li>
</ul>
</li>
</ul>
<h2>데이터베이스 모델</h2>
<ul>
<li>데이터 모델 : 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구이다.</li>
</ul>
<h3>데이터 모델의 구성 요소</h3>
<ul>
<li>데이터 구조(Structure) : 데이터 구조 및 정적 성질을 표현한다.</li>
<li>연산(Operations) : 데이터의 인스턴스에 적용 가능한 연산 명세와 조작 기법을 표현한다.</li>
<li>제약조건(Constraints) : 데이터의 논리적 제한 명시 및 조작의 규칙이다.</li>
</ul>
<h3>데이터 모델의 구분</h3>
<ul>
<li>데이터베이스 모델<!-- -->
<ul>
<li>개념적 모델<!-- -->
<ul>
<li>ERD(Entity Relationship Diagram)</li>
</ul>
</li>
<li>논리적 모델<!-- -->
<ul>
<li>계층형</li>
<li>네트워크(망)형</li>
<li>관계형</li>
<li>객체지향형</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>개념적 데이터 모델</h4>
<ul>
<li>속성들로 기술된 개체 타입과 이 개체 타입 간의 관계를 이용하여 현실 세계를 표현하는 방법이다.</li>
<li>E-R 모델(Entity-Relationship 모델 , 개체-관계 모델)<!-- -->
<ul>
<li>대표적인 개념적 데이터 모델이다.</li>
<li>개체 타입과 이들 간의 관계 타입을 이용하여 현실 세계를 개념적으로 표현한 방법이다.</li>
<li>E-R 다이어그램 : E-R 모델을 그래프 방식으로 표현하였다.</li>
</ul>
</li>
</ul>
<h4>논리적 데이터 모델</h4>
<ul>
<li>필드로 기술된 데이터 타입과 이 데이터 타입 간의 관계 현실 세계를 표현하는 방법이다.</li>
<li>종류<!-- -->
<ul>
<li>관계형 데이터 모델 : 데이터베이스를 테이블(Table)의 집합으로 표현한다.</li>
<li>계층형 데이터 모델 : 데이터베이스를 트리(Tree) 구조로 표현한다.</li>
<li>네트워크형 데이터 모델 : 데이터베이스를 그래프(Graph) 구조로 표현(owner-member 관계)하며, CODASYL DBTG 모델이라고도 한다.</li>
</ul>
</li>
</ul>
<h2>관계형 데이터베이스 모델</h2>
<ul>
<li>관계형 데이터베이스를 구성하는 개체나 관계를 릴레이션(Relation)으로 표현한다.</li>
</ul>
<h3>관계형 데이터베이스 모델 구조</h3>
<table><thead><tr><th style="text-align:center">속성(Attribute)</th><th style="text-align:center">학번</th><th style="text-align:center">이름</th><th style="text-align:center">학과</th><th style="text-align:center">학년</th></tr></thead><tbody><tr><td style="text-align:center">튜플(Tuple)</td><td style="text-align:center">2024010</td><td style="text-align:center">A</td><td style="text-align:center">심리학과</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">튜플</td><td style="text-align:center">2025015</td><td style="text-align:center">B</td><td style="text-align:center">전자공학과</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">튜플</td><td style="text-align:center">2026016</td><td style="text-align:center">C</td><td style="text-align:center">컴퓨터공학과</td><td style="text-align:center">3</td></tr></tbody></table>
<ul>
<li>튜플(Tuple)<!-- -->
<ul>
<li>테이블의 행(Row)에 해당하며 파일 구조의 레코드(Record)와 같은 의미이다.</li>
<li>카디널리티(Cardinality) : 튜플의 수(기수)</li>
<li>한 릴레이션의 튜플들의 값은 모두 상이하며, 튜플 간 순서가 없다.</li>
</ul>
</li>
<li>속성(Attribue)<!-- -->
<ul>
<li>테이블의 열(Column)에 해당하며 파일 구조의 항목(Item), 필드(Field)와 같은 의미이다.</li>
<li>차수(Degress) : 속성의 수</li>
<li>한 릴레이션의 속성은 원자값이며, 속성 간 순서가 없다.</li>
</ul>
</li>
<li>도메인(Domain) : 하나의 속성이 가질 수 있는 원자값들의 집합이다.</li>
</ul>
<h3>릴레이션의 특징</h3>
<ul>
<li>튜플의 유일성 : 모든 튜플은 서로 다른 값을 갖는다.</li>
<li>튜플의 무순서성 : 하나의 릴레이션에서 튜플의 순서는 없다.</li>
<li>속성의 원자성 : 속성은 원자값을 갖는다.</li>
<li>속성의 무순서성 : 각 속성은 릴레이션 내에서 유일한 이름을 가지며, 속성의 순서는 큰 의미가 없다.</li>
</ul>
<h2>키(Key)의 종류와 무결성</h2>
<h3>키의 분류</h3>
<table><thead><tr><th style="text-align:center">학번</th><th style="text-align:center">주민번호</th><th style="text-align:center">이름</th><th style="text-align:center">나이</th><th style="text-align:center">&lt;-학생---수강-&gt;</th><th style="text-align:center">학번</th><th style="text-align:center">과목</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">123123-1</td><td style="text-align:center">A</td><td style="text-align:center">10</td><td style="text-align:center">---</td><td style="text-align:center">1</td><td style="text-align:center">운영체제</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">123123-1</td><td style="text-align:center">B</td><td style="text-align:center">20</td><td style="text-align:center">---</td><td style="text-align:center">2</td><td style="text-align:center">소프트웨어공학</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">123123-1</td><td style="text-align:center">C</td><td style="text-align:center">30</td><td style="text-align:center">---</td><td style="text-align:center">3</td><td style="text-align:center">C언어</td></tr></tbody></table>
<ul>
<li>슈퍼키(Super Key)<!-- -->
<ul>
<li>두 개 이상의 속성으로 구성된 키 또는 혼합키를 의미한다.</li>
<li>모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는다.</li>
</ul>
</li>
<li>외래키(Foreign Key)<!-- -->
<ul>
<li>다른 테이블의 기본키로 사용되는 속성이다.</li>
<li>&lt;수강&gt; 테이블에서 &lt;학생&gt; 테이블을 참조할 때 &lt;학생&gt; 테이블의 학번은 참조키, &lt;수강&gt; 테이블의 학번이 외래 키가 된다.</li>
</ul>
</li>
<li>무결성(Integrity)<!-- -->
<ul>
<li>릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션을 조작하는 과정에서의 의미전 관계 (Semantic Relationship)를 명세한 것으로 정의 대항으로 도메인, 키, 종속성 등이 있다.</li>
<li>개체 무결성 : 기본키의 값은 Null 값이나 중복 값을 가질 수 없다는 제약조건이다.</li>
<li>참조 무결성 : 릴레이션 R1에 속성 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 한다. 이때 참조할 수 없는 외래키 값을 가질 수 없다는 제약조건이다.</li>
<li>도메인 무결성 : 릴레이션 중 하나의 속성은 반드시 원자 값이어야 한다는 것을 보장하는 제약조건이다.</li>
</ul>
</li>
</ul>
<h1>데이터베이스 설계와 구조화</h1>
<h3>데이터베이스 설계 단계</h3>
<ol>
<li>요구조건 분석<!-- -->
<ul>
<li>데이터베이스 사용자로부터 요구조건 수집과 요구조건 명세서를 작성한다.</li>
</ul>
</li>
<li>개념적 설계<!-- -->
<ul>
<li>목표 DBMS에 독립적인 개념 스키마를 설계한다.</li>
<li>개념 스키마 모델링(ERD)과 트랜잭션 모델링을 병행 수행한다.</li>
</ul>
</li>
<li>논리적 설계<!-- -->
<ul>
<li>목표 DBMS에 종속적인 논리적 스키마를 설계한다.</li>
<li>스키마의 평가 및 정제를 한다.</li>
<li>논리적 데이터 모델로 변환 및 트랜잭션 인터페이스를 설계한다.</li>
</ul>
</li>
<li>물리적 설계<!-- -->
<ul>
<li>목표 DBMS에 종속적인 물리적 구조를 설계한다.</li>
<li>저장 레코드 양식 설계와 레코드 집중의 분석/설계, 엑세스 경로 인덱싱, 클러스터링, 해싱 등의 설계가 포함된다.</li>
<li>접근 경로 설계 및 트랜잭션 세부 설계를 한다.</li>
</ul>
</li>
<li>데이터베이스 구현<!-- -->
<ul>
<li>목표 DBMS의 DDL(데이터 정의어)로 스키마를 작성한다.</li>
<li>데이터베이스에 등록 후 트랜잭션을 작성한다.</li>
</ul>
</li>
</ol>
<h3>데이터베이스 정규화</h3>
<ul>
<li>함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다.</li>
<li>좋은 데이터베이스 스키마를 생성하고 불필요한 데이터의 중복을 방지하여 정보 검색을 용이하게 할 수 있도록 허용한다.</li>
</ul>
<h4>정규화의 목적</h4>
<ul>
<li>데이터 구조의 안정성 최대화</li>
<li>중복 데이터의 최소화</li>
<li>수정 및 삭제 시 이상 현상 최소화</li>
<li>테이블 불일치 위험 간소화</li>
</ul>
<h3>이상 현상(Anomaly)</h3>
<ul>
<li>릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미한다.</li>
<li>종류<!-- -->
<ul>
<li>삽입 이상(Insertion Anomaly) : 데이터를 삽입할 떄 불필요한 데이터가 함께 삽입되는 현상</li>
<li>삭제 이상(Deletion Anomaly) : 릴레이션의 한 튜플을 삭제함으로써 연쇄 삭제로 인해 정보의 손실을 발생시키는 현상</li>
<li>갱신 이상(Update Anomaly) : 튜플 중에서 일부 속성을 갱신함으로써 정보의 모순성이 발생하는 현상</li>
</ul>
</li>
</ul>
<h1>정규화</h1>
<h3>정규화 과정</h3>
<ol>
<li>비정규 릴레이션</li>
<li>1NF(도메인이 원자값)</li>
<li>2NF(부분적 함수 종속 제거)</li>
<li>3NF(이행적 함수 종속 제거)</li>
<li>BCNF(결정자이면서 후보키가 아닌 함수 종속 제거)</li>
<li>4NF(다치 종속 제거)</li>
<li>6NF(조인 종속성 제거)</li>
</ol>
<h3>반정규화(비정규화)</h3>
<ul>
<li>정규화를 통하여 정합성과 데이터 무결성이 보장되지만, 테이블의 개수가 증가함에 따라 테이블 간의 조인이 증가하여 조회 성능이 떨어질 수 있는데, 이렇게 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능 향상과 개발(Development) 및 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다.</li>
<li>반정규화 기법 : 테이블 반정규화, 컬럼 반정규화, 관계 반정규화</li>
<li>테이블 반정규화 기법 : 테이블 병합, 테이블 분할, 테이블 추가</li>
<li>테이블 추가 반정규화 유형 : 중복 테이블 추가, 집계 테이블 추가, 진행 테이블 추가, 부분 테이블 추가</li>
</ul>
<h1>SQL ★★★</h1>
<h3>SQL(Structured Query Language)</h3>
<ul>
<li>관계형 데이터베이스의 표준 질의어</li>
<li>종류<!-- -->
<ul>
<li>DDL(데이터 정의어), DML(데이터 조작어), DCL(데이터 제어어)</li>
</ul>
</li>
</ul>
<h3>DDL(Data Definition Language, 데이터 정의어)</h3>
<ul>
<li>데이터베이스의 정의/변경/삭제에 사용되는 언어이다.</li>
<li>논리적 데이터 구조와 물리적 데이터 구조로 정의할 수 있다.</li>
<li>논리적 데이터 구조와 물리적 데이터 구조 간의 사상을 정의한다.</li>
<li>번역한 결과가 데이터 사전에 저장된다.</li>
<li>종류<!-- -->
<ul>
<li>CREATE : 스키마, 도메인, 테이블, 뷰 정의</li>
<li>ALTER : 테이블 정의 변경(필드 추가, 삭제, 갱신)</li>
<li>DROP : 스키마, 도메인, 테이블, 뷰 삭제</li>
</ul>
</li>
</ul>
<h4>CREATE문 문법 구조</h4>
<ul>
<li>CREATE TABLE : 테이블을 생성하는 명령문</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>
</span>CREATE TABLE 기본테이블
<!-- -->    (
<!-- -->        {열이름 데이터_타입 [NOT NULL] [DEFALUT 값]}
<!-- -->        {[PRIMARY KEY(열이름_리스트)]},
<!-- -->        {[UNIQUE(열이름_리스트,...)]},
<!-- -->        {[FOREIGN KEY(열이름_리스트)]
<!-- -->        REFERENCES 기본테이블[(기본키_열이름)]
<!-- -->        [ON DELETE 옵션]
<!-- -->        [ON UPDATE 옵션]}
<!-- -->        [CHECK(조건식)]
<!-- -->    );
</code></pre></pre>
<ul>
<li>{}는 중복 가능한 부분</li>
<li>NOT NULL은 특정 열에 대해 NULL 값을 허용하지 않을 때 기술</li>
<li>PRIMARY KEY는 기본키를 구성하는 속성을 지정할 때 사용된다.</li>
<li>FOREIGN KEY는 외래키로 어떤 릴레이션의 기본키를 참조하는지를 기술한다.</li>
</ul>
<h4>ALTER문 문법 구조</h4>
<ul>
<li>ALTER TABLE : 테이블 구조(필드 추가, 삭제, 변경) 변경문이다.</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>ALTER TABLE 테이블_이름 ADD 열_이름 데이터_타입 DEFAULT 값;
</span>ALTER TABLE 테이블_이름 ALTER 열_이름 SET DEFAULT 값;
<!-- -->ALTER TABLE 테이블_이름 DROP 열_이름 CASCADE;</code></pre></pre>
<ul>
<li>ADD : 새로운 열(속성)을 추가할 때 사용한다.</li>
<li>ALTER : 특정 열(속성)의 디폴트 값을 변경할 때 사용한다.</li>
<li>DROP : 특정 열(속성)을 제거할 때 사용한다.</li>
</ul>
<h4>DROP문 문법 구조</h4>
<ul>
<li>DROP : 테이블 삭제문</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>DROP SCHEMA 스키마_이름 [CASCADE | RESTRICT];
</span>DROP DOMAIN 도메인_이름 [CASCADE | RESTRICT];
<!-- -->DROP TABLE 테이블_이름 [CASCADE | RESTRICT];
<!-- -->DROP INDEX 인덱스_이름;</code></pre></pre>
<ul>
<li>CASCADE : 옵션을 사용하면 삭제할 요소가 다른 개체에서 참조 중이라도 삭제가 수행된다.</li>
<li>RESTRICT : 옵션을 사용하면 삭제할 요소가 다른 개체에서 참조 중이라면 삭제가 수행되지 않는다.</li>
</ul>
<h3>DCL(Data Control Language, 데이터 제어어)</h3>
<ul>
<li>데이터 제어 정의 및 기술에 사용되는 언어이다.</li>
<li>불법적인 사용자로부터 데이터를 보호한다.</li>
<li>무결성을 유지하고 데이터 복구 및 병행 제어를 한다.</li>
<li>종류<!-- -->
<ul>
<li>COMMIT : 명령어로 수행된 결과를 실제 물리적 디스크로 저장하고, 명령어로 수행을 성공적으로 완료하였음을 선언한다.</li>
<li>ROLLBACK : 명령어로 수행에 실패하였음을 알리고, 수행된 결과를 원상 복귀시킨다.</li>
<li>GRANT : 데이터베이스 사용자에게 사용 권한을 부여한다.</li>
<li>REVOKE : 데이터베이스 사용자로부터 사용 권한을 취소한다.</li>
</ul>
</li>
</ul>
<h3>DML(Data Maniqulation Language, 데이터 조작어)</h3>
<ul>
<li>데이터의 검색/삽입/삭제/변경에 사용되는 언어이다.</li>
<li>사용자와 DBMS 간의 인터페이스를 제공한다.</li>
<li>종류<!-- -->
<ul>
<li>SELECT<!-- -->
<ul>
<li>튜플 검색 명령어이다.</li>
<li>기본 구조</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>    SELECT 속성명[ALL | DISTINCT]
</span>    FROM 릴레이션명
<!-- -->    WHERE 조건
<!-- -->    [GROUP BY 속성명1, 속성명2, ... ]
<!-- -->    [HAVING 조건]
<!-- -->    [ORDER BY 속성명 [ASC | DESC]]</code></pre></pre>
<ul>
<li>ALL : 모든 튜플을 검색(생략 가능)</li>
<li>DISTINCT : 중복된 튜플 생략</li>
</ul>
</li>
<li>INSERT<!-- -->
<ul>
<li>튜플 삽입 명령어</li>
<li>기본 구조</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>    INSERT INTO 테이블명(속성명1, 속성명2,...)
</span>    VALUES(데이터1, 데이터2 ...);</code></pre></pre>
</li>
<li>DELTETE<!-- -->
<ul>
<li>튜플 삭제 명령어이다.</li>
<li>기본 구조</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>    DELETE
</span>    FROM 테이블명
<!-- -->    WHERE 조건;</code></pre></pre>
</li>
<li>UPDATE<!-- -->
<ul>
<li>튜플의 내용 변경 명령어이다.</li>
<li>기본 구조</li>
</ul>
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>    UPDATE 테이블명
</span>    SET 속성명 = 데이터
<!-- -->    WHERE 조건;</code></pre></pre>
</li>
</ul>
</li>
</ul>
<h3>NoSQL</h3>
<ul>
<li>&quot;Not only SQL&quot;로, SQL만을 사용하지 않는 데이터베이스 관리 시스템(DBMS)을 지칭하며, 다양한 유형의 데이터베이스를 사용하는 것을 의미한다.</li>
<li>데이터를 저장하는데 SQL 외에도 다른 방법도 있다는 개념하에 비정형 데이터의 저장을 위해 유연한 데이터 모델을 지원한다.</li>
<li>전통적인 관계형 데이터베이스 관리 시스템과는 다른 비관계형(Non-Relational) DBMS이다.</li>
</ul>
<h3>집계 함수</h3>
<ul>
<li>COUNT : 테이블의 행 수를 계산할 때 / 표현식: COUNT(*)</li>
<li>SUM : 하나 또는 여러 개의 열 합계를 구할 때 / 표현식 : SUM(열 이름)</li>
<li>AVG : 하나 또는 여러 개의 열 평균을 구할 때 / 표현식 : AVG(열 이름)</li>
<li>MAX : 해당 열의 최댓값을 구할 때 / 표현식 : MAX(열 이름)</li>
</ul>
<h3>HAVING 절을 사용한 조회 검색</h3>
<ul>
<li>GROUP BY절에 의해 선택된 그룹의 탐색 조건을 지정할 수 있으며 SUM, AVG, COUNT, MAX, MIN 등의 그룹 함수와 함께 사용할 수 있다.</li>
</ul>
<h3>ORDER BY 절을 이용한 정렬 검색</h3>
<ul>
<li>특정 항목을 기준으로 검색 테이블의 행들을 오름차순(ASC) 또는 내림차순(DESC)으로 정렬할 때 사용한다. 생략하면 ASC가 디폴트 값이 되어 오름차순으로 정렬된다.</li>
</ul>
<h1>트랜잭션 ★★★</h1>
<ul>
<li>하나의 논리적 기능을 수행하기 위한 작업 단위이다.</li>
<li>데이터베이스에서 일어나는 연산의 집합이다.</li>
</ul>
<h3>트랜잭션의 특성</h3>
<ul>
<li>원자성(Atomicity)<!-- -->
<ul>
<li>완전하게 수행이 완료되지 않으면 전혀 수행되지 않아야 한다.</li>
<li>연산은 Commit, Rollback을 이용하여 적용 또는 취소로 한꺼번에 완료되어야 한다.</li>
<li>중간에 하나의 오류가 발생되더라도 취소가 되어야 한다.</li>
</ul>
</li>
<li>일관성(Consistency)<!-- -->
<ul>
<li>시스템의 고정 요소는 트랜잭션 수행 전후가 같아야 한다.</li>
<li>트랜잭션 결과는 일관성을 유지해야 한다.</li>
</ul>
</li>
<li>격리성(Isolation, 고립성)<!-- -->
<ul>
<li>트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 한다.</li>
</ul>
</li>
<li>영속성(Durability, 지속성)<!-- -->
<ul>
<li>트랜잭션의 완료 결과가 데이터베이스에 영구히 기억된다.</li>
<li>은행계좌에서 100원 중 10원을 인출했을 때 계좌에는 90원이 남아 있어야 한다.</li>
</ul>
</li>
</ul>
<h1>보안과 권한 부여</h1>
<ul>
<li>보안(Security)의 개념 : 권한이 없는 사용자로부터 데이터베이스를 보호하는 것</li>
</ul>
<h3>권한 부여/회수</h3>
<h4>GRANT</h4>
<ul>
<li>데이터베이스 사용자에게 사용 권한을 부여한다.</li>
<li>기본 구조<!-- -->
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>    GRANT 권한 ON 데이터 객체 TO 사용자 [WITH GRANT OPTION];</span></code></pre></pre>
</li>
<li>WITH GRANT OPTION : 사용자가 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여한다.</li>
<li>부여 가능한 권한 : Update, Delete, Insert, Select</li>
</ul>
<h4>REVOKE</h4>
<ul>
<li>데이터베이스 사용자로부터 사용 권한을 취소한다.</li>
<li>기본 구조<!-- -->
<pre><pre node="[object Object]" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;background:#2b2b2b"><code class="language-SQL" style="color:#a9b7c6;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>    REVOKE [GRANT OPTION FOR] 권한 ON 데이터 객체 FROM 사용자 [CASCADE];</span></code></pre></pre>
</li>
<li>GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소한다.</li>
<li>CASCADE : 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄 취소한다.</li>
<li>부여 가능한 권한 : Update, Delete, Insert, Select</li>
</ul>
<h1>암호화</h1>
<ul>
<li>네트워크를 통하거나 컴퓨터 내부에 자료를 저장할때 권한을 가진 사람 외에는 데이터를 보지 못하도록 하는 것</li>
<li>일반 평문을 다양한 방식의 암호화 기법으로 가공하여 저장하거나 전송 권한이 있는 사용자에 의해 복호화되어 사용한다.</li>
</ul>
<p>암호화 과정 : 평문 =&gt; 암호화(암호키) =&gt; 암호문 =&gt; 복호화(복호키) =&gt; 평문</p>
<h3>암호화 기법</h3>
<ul>
<li>비밀키(Private Key, 대칭키) 암호화 기법<!-- -->
<ul>
<li>비밀키 암호화 기법을 동일한 키로 데이터를 암호화하고 복호화한다.</li>
<li>암호화, 복호화 키가 같아서 키를 공개하면 타인이 알게 된다.</li>
<li>암호화와 복호화 속도가 빠르다.</li>
</ul>
</li>
<li>공개키(Public Key, 비대칭키) 암호화 기법<!-- -->
<ul>
<li>공개키 암호화 기법은 각기 다른 키로 데이터를 암호화하고 복호화한다.</li>
<li>암호화, 복호화 키가 다르므로 키는 공개되어도 된다.</li>
<li>암호화 및 복호화 속도가 느리다.</li>
</ul>
</li>
</ul>
<hr/>
<p>참조 : <a href="https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95">Github repository</a></p></div></main><div class="sc-e5001ff0-0 hvYKNx"><p><strong>정보처리기사</strong> 카테고리의 다른 글</p><ul class="sc-e5001ff0-1 fGkysO"></ul></div><div class="sc-39211eb-3 jqcgtI"><p>COMMENTS</p><section id="comment-box"></section></div></main></article><aside class="sc-7eadfa91-0 cYGwoY"><nav class="sc-ef3fe011-0 fOQwiv"><ul class="sc-ef3fe011-1 gcpOaT"><p>Category</p><div><p class="sc-ef3fe011-2 jLZscn">FE</p><li class="sc-ef3fe011-3 frUPYo"><a href="/html">HTML</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/css">CSS</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/javascript">JavaScript</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/typescript">TypeScript</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/redux">Redux</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/react">React</a></li><li class="sc-ef3fe011-3 frUPYo"><a href="/nextjs">Nextjs</a></li></div><div><p class="sc-ef3fe011-2 jLZscn">BE</p><li class="sc-ef3fe011-3 frUPYo"><a href="/nestjs">Nestjs</a></li></div><div><p class="sc-ef3fe011-2 jLZscn">CS</p><li class="sc-ef3fe011-3 frUPYo"><a style="color:white;font-weight:bold" href="/sw">정보처리기사</a></li></div><div><p class="sc-ef3fe011-2 jLZscn">ETC</p><li class="sc-ef3fe011-3 frUPYo"><a href="/github">Simple Memo</a></li></div></ul></nav></aside></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"sw first test3","description":"정보처리기사 필기(3) - DB 구축","category":"sw","keyword":"정보처리기사, 정처기, 필기, DB 구축","date":"2023-12-26","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 자료 구조\r\n\r\n### 자료 구조의 분류\r\n\r\n1. 선형 구조\r\n   - 리스트\r\n     - 선형 리스트\r\n     - 연결 리스트\r\n2. 비선형 구조\r\n   - 트리\r\n   - 그래프\r\n\r\n### 자료 구조의 활용\r\n\r\n- 정렬\r\n  - 집합된 데이터 레코드를 일정 기준으로 재배열하는 것.\r\n  - 오름차순, 내림차순\r\n- 검색\r\n  - 저장된 데이터 레코드 중 원하는 값을 빠르게 찾는 것\r\n- 인덱스(Index)\r\n  - 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로, 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 별도로 구성한 순서 데이터를 말한다. (ex. 책의 맨 뒤에 빠르게 찾기 등)\r\n  - B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있다.\r\n  - BETWEEN 등 범위(Range) 검색에 활용될 수 있다.\r\n- 파일 편성\r\n  - 파일에서 레코드의 물리적인 배열 방법이다.\r\n\r\n## 선형 자료 구조\r\n\r\n### 리스트(List)\r\n\r\n- 선형 리스트(Linear List)\r\n  - 배열(Array)과 같이 연속되는 기억 장소에 저장되는 리스트이다.\r\n  - 가장 간단한 데이터 구조 중 하나로 데이터 항목을 추가 삭제하는 것이 불편하다.\r\n- 연결 리스트(Linked List)\r\n  - 노드의 포인터 부분을 서로 연결시킨 리스트로, 연속적인 기억 공간이 없어도 저장이 가능하다.\r\n  - 노트의 삽입/삭제가 용이하며 포인터를 위한 추가 공간이 필요하므로 기억 공간이 많이 소요된다.\r\n\r\n### 스택(Stack)\r\n\r\n- 리스트의 한쪽 끝에서만 자료의 삽입과 삭제가 이루어 지는 자료 구조이다.\r\n- 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO, Last In First Out) 방식이다.(PUSH and POP)\r\n- 마지막 삽입된 자료의 위치를 Top이라 하고, 가장 먼저 삽입된 자료의 위치를 Bottom이라고 한다.\r\n- 스택 가능 : 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술이다.\r\n- 스택 응용 분야\r\n  - 인터럽트 처리, 수식의 계산, 0-주소 지정 방식\r\n  - 재귀호출, 후위 표현(Post-fix expression)의 연산, 깊이 우선 탐색\r\n\r\n**스택의 삽입 알고리즘**\r\n\r\n```\r\n\r\nif TOP \u003e= n then call Stack-Full;\r\nelse TOP = TOP + 1;\r\nStack(TOP) = Data;\r\nend Insert\r\n\r\n```\r\n\r\n**스택의 삭제 알고리즘**\r\n\r\n```\r\nif TOP = 0\r\nthen Underflow\r\nElse\r\nRemove S(TOP)\r\nTOP = TOP - 1\r\n```\r\n\r\n**스택의 오버플로 알고리즘**\r\n\r\n```\r\nTOP \u003c- TOP + 1\r\nif TOP \u003e n then goto AA\r\nelse Stack(TOP) \u003c- item\r\n```\r\n\r\n### 큐(Queue)\r\n\r\n- 자료의 삽입 작업은 선형 리스트의 한쪽 끝에서, 제거 작업은 다른 쪽 끝에서 수행되는 자료 구조이다.\r\n- 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO: First In First Out) 방식이다.\r\n- 큐의 응용 분야 : 운영체제의 작업 스케줄링 등에서 응용된다.\r\n\r\n### 덱(Deque)\r\n\r\n- 자료의 삽입과 삭제가 리스트의 양쪽 끝에서 이루어지므로 두 개의 포인터를 사용하는 자료 구조이다.\r\n- 스택과 큐를 복합한 형태이다.\r\n- 입력 제한 덱을 Scroll, 출력 제한 덱을 Shelf라고 한다.\r\n\r\n## 비선형 구조\r\n\r\n### 트리(Tree)\r\n\r\n- 그래프(Graph)의 특수한 형태로써 노드(Node)와 브랜치(Branch)를 이용하여 사이클을 이루지 않도록 구성한 자료 구조이다.\r\n\r\n### 이진 트리(Binary Tree)\r\n\r\n- 차수(Degree)가 이 이하인 노트들로만 구성된 트리\r\n- 이 트리의 레벨 n에서 최대 노드의 수 : 2ⁿ-1\r\n- 깊이(레벨)가 4인 트리의 최대 노드 수는 2⁴-1로, 15이다.\r\n- 구조\r\n  - 정이진 트리 : 첫 번째 레벨부터 마지막 레벨까지 모두 2개씩 채워진 트리를 말한다.\r\n  - 전이진 트리 : 전이진 트리에서 한쪽 방향 노드가 아예 존재하지 않는 트리를 말한다.\r\n  - 사향 이진 트리 : 근노드로부터 한쪽 방향으로만 기울어진 트리를 말한다.\r\n\r\n### 그래프\r\n\r\n- 정점(Vertex)과 간선(Edge)의 집합으로 이루어지는 자료 구조.\r\n- 표현 방법 : 인접 행렬(Adjacency Matrix)\r\n- 신장 트리(Spanning Tree) : 간선들이 사이클을 이루지 않도록 정점들을 연결시킨 그래프이다.\r\n- 종류 : 방향 그래프, 무방향 그래프, 완전 그래프, 부 그래프\r\n- n개의 노드로 구성된 무방향 그래프의 최대 간선 수는 n(n-1)/2개다.\r\n- 제어 흐름 스래프에서 순환 복잡도 : V(G) - E(화살표 수) - N(노드 수) + 2\r\n\r\n### 인접 행렬(Adjacency Matrix)\r\n\r\n- 방향 그래프에서 ViVj 관계를 나타내는 행렬의 원소를 Aij라고 할 때, 방향 간선이 있으면 행렬의 Aij = 1, 방향 간선이 없으면 행렬의 Aij = 0 으로 나타낸다.\r\n- 무방향 그래프에서 Vi와 Vj가 서로 인접하면 Aij = 1, 서로 인접하지 않으면 Aij = 0으로 나타낸다.\r\n- 여기서 i, j는 첨자 (A₃의 3과 같음)\r\n\r\n# 정렬(Sort)\r\n\r\n- 정렬 알고리즘 선택 시 고려사항 : 데이터의 양, 초기 데이터의 배열 상태, 키 값들의 분포 상태, 사용 컴퓨터 시스템의 특성\r\n- 종류 : 내부 정렬(장치에서 정렬이 이루어짐), 외부 정렬(보조 기억 장치에서 정렬이 이루어짐)\r\n\r\n### 삽입 정렬(Insertion Sort)\r\n\r\n- 정렬된 파일에 새로운 하나의 레코드를 순서에 따라 삽입시켜 정렬하는 방법\r\n\r\n### 선택 정렬(Selection Sort)\r\n\r\n- n개의 레코드 중에서 최소값(또는 최대값)을 찾아 1st 레코드 위치에 놓고, 나머지 (n-1) 개의 레코드 중에서 최소값(또는 최대값)을 찾아 2nd 레코드 위치에 놓는 방법을 반복하여 정렬하는 방법이다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n²)\r\n\r\n### 병합 정렬(2-Way Merge Sort)\r\n\r\n- 두 개의 키들을 한 쌍으로 하여 각 쌍에 대해 순서를 정한다.\r\n- 순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브 리스트로 만든다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n log₂ n)\r\n\r\n### 퀵 정렬(Quick Sort)\r\n\r\n- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어가면서 정렬하는 방법으로, 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽에 모이도록 서로 교환시키는 부분 교환 정렬법이다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n log₂ n), 약=O(n²)\r\n\r\n### 힙 정렬(Heap Sort)\r\n\r\n- 전이진 트리를 이용하여 정렬하는 방법이다.\r\n- 정렬한 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다.\r\n- 평균 수행 시간 복잡도는 O(n log₂ n)이고, 최악의 수행 시간 복잡도는 O(log₂ n)이다.\r\n- 입력 자료의 레코드를 완전 이진 트리(Complete Binary Tree)로 구성한다.\r\n\r\n# 검색(Search)과 해싱(Hashing)\r\n\r\n### 검색\r\n\r\n- 기억 공간 내 기억된 자료 중에서 주어진 조건을 만족하는 자료를 찾는 것\r\n\r\n- 이분 검색(Binary Search, 이진 검색)\r\n  - 이분 검색을 실행하기 위한 전제 조건은 자료가 순차적으로 정렬되어 있어야 한다.\r\n  - 탐색 효율이 좋고 탐색 시간이 적게 소요된다.\r\n  - 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.\r\n- 선형 검색(Linear Search)\r\n  - 순차 검색(Sequential Search)이라고도 한다.\r\n  - 주어진 자료에서 원소를 첫 번째 레코드부터 순차적으로 비교하면서 해당키 값을 가진 레코드를 찾아내는 가장 간단한 검색 방법이다.\r\n  - 데이터를 특별히 조직화할 필요가 없고 다양한 상황에서도 사용될 수 있는 장점이 있지만 N개의 입력 자료에 대해서 평균적으로 (n+1)/2번의 비교를 해야 하므로 비효율적이다.\r\n- 피보나치 검색(Fibonacci Search)\r\n  - 이진 검색과 비슷한 원리로, 비교 대상 기준을 피보나치 수열로 결정한다.\r\n  - 피보나치 수열 : 1,2,3,5,8,11~로 앞의 두 수의 합이 다음 번 값이 된다.\r\n- 블록 검색\r\n  - 전체 레코드를 일정한 블록으로 분리한 뒤 각 블록 내의 키값을 순서대로 비교하여 원하는 값을 찾는 기법이다.\r\n- 이진 트리 검색\r\n  - 레코드를 2진 트리로 구성하여 검색하는 방식으로 데이터를 입력하는 순서대로 첫 번째 값을 근노드로 지정하고 근노드보다 작으면 왼쪽, 크면 오른쪽에 연결하여 구성한다.\r\n\r\n### 해싱\r\n\r\n- 해싱 함수(Hashing Function)를 이용하여 레코드키에 대한 해시 테이블(Hash Table) 내의 홈 주소(Home Address)를 계산하여 주어진 레코드에 접근하는 방식이다.\r\n- 직접 접근(Direct Access Method) 파일을 구성할 때 사용된다.\r\n- 속도는 가장 빠르지만 충돌 현상 시 오버플로우 해결의 부담이 가중되며, 많은 기억 공간을 요구한다.\r\n\r\n- 제산 방법(Division Method)\r\n  - 해싱 함수 기법에서 키값을 양의 정수인 소수로 나누어 나머지를 홈주소로 취하는 방법이다.\r\n- 중간 제곱 방법(Mid-Square Method)\r\n  - 레코드 키값을 제곱하고 나서 그 중간 부분의 값을 주소로 계산하는 방법이다.\r\n  - 해시 테이블의 크기에 따라서 중간 부분의 적당한 자릿수를 선택할 수 있다.\r\n  - 비트 단위로 n 자릿수를 중간 위치 자릿수로 가정하면 해시 테이블의 크기는 2n이다.\r\n- 중첩 방법(Folding Method)\r\n  - 해싱 함수 중 주어진 키를 여러 부분으로 나누고, 각 부분의 값을 더하거나 배타적 논리합(XOR: Exclusive OR) 연산을 통하여 나온 결과로 주소를 취하는 방법이다.\r\n- 기수 변환 방법(Radix Conversion Method)\r\n  - 해싱 함수 기법 중 어떤 진법으로 표현된 주어진 레코드 키값을 다른 진법으로 간주하고 키값을 변환하여 홈주소로 취하는 방식이다.\r\n- 계수 분석 방법(Digit Analysis Method)\r\n  - 주어진 모든 키값들에서 그 키를 구성하는 자릿수들의 분포를 조사하여 비교적 고른 분포를 보이는 자릿수들을 필요한 만큼 택하는 방법을 취하는 해싱 함수 기법이다.\r\n\r\n# 데이터베이스(Database) ★★★\r\n\r\n### 데이터베이스의 정의\r\n\r\n- 통합된 데이터(Integrated Data) : 각 사용자의 데이터를 한 곳에 모아 통합한 데이터이다.\r\n- 저장된 데이터(Stored Data) : 데이터베이스는 컴퓨터 하드웨어 저장 장치에 저장되어 있는 데이터이다.\r\n- 운영 데이터(Operational Data) : 데이터베이스는 어떤 조직의 고유 기능을 수행하기 위해 반드시 필요한 데이터이다.\r\n- 공용 데이터(Shared Data) : 데이터베이스를 여러 사용자가 공동 소유/관리/활용하는 데이터이다.\r\n\r\n### 데이터베이스의 특성\r\n\r\n- 실시간 접근성(Real Time Accessibility) : 수시적이고 비정형적인 질의에 대하여 실시간 처리로 응답할 수 있어야 한다.\r\n- 내용에 의한 참조(Content Reference) : 데이터베이스의 데이터는 그 주소나 위치에 의해 참조되는 것이 아니라 내용을 참조한다.\r\n- 동시 공유(Concurrent Sharing) : 같은 내용의 데이터를 여러 사람이 동시에 공용할 수 있다.\r\n- 계속적 변화(Continuous Evolution) : 데이터베이스는 데이터의 삽입, 삭제, 갱신으로 내용이 계속적으로 변한다.\r\n- 구성 : DBMS, 스키마, 데이터베이스 언어, 데이터베이스 사용자로 구성되어있다.\r\n\r\n## DBMS(DataBase Management System, 데이터베이스 관리 시스템)\r\n\r\n- 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다.\r\n- 응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리한다.\r\n- 데이터베이스의 구성, 접근 방법, 관리 유지에 대한 모든 책임을 진다.\r\n\r\n### DBMS의 필수 기능\r\n\r\n- 정의 기능(Definition Facility)\r\n  - 데이터베이스 구조를 정의한다.\r\n  - 데이터의 논리적 구조와 물리적 구조 사이에 변환이 가능하도록 두 구조 사이의 사상(Mapping)을 명시한다.\r\n- 조작 기능(Manipulation Facility)\r\n  - 데이터베이스에 접근하여 데이터의 검색/삽입/삭제/갱신 등의 연산 적업을 하기 위한 사용자와 데이터베이스 사이의 인터페이스 수단을 제공한다.\r\n- 제어 기능(Control Facility)\r\n  - 데이터베이스에 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 무결성이 유지되도록 제어해야 한다.\r\n  - 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안(Security)을 유지하고, 권한(Authority)을 검사할 수 있어야 한다.\r\n  - 여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때 처리 결과가 항상 정확성을 유지하도록 병행 제어를 할 수 있도록 한다.\r\n\r\n### DBMS의 장/단점\r\n\r\n- 장점\r\n  - 데이터의 중복 및 종속성 최소화\r\n  - 데이터 공유\r\n  - 데이터 무결성 및 일관성 유지\r\n  - 데이터 보안 보장 용이\r\n- 단점\r\n  - 예비와 회복 기법이 어려움\r\n  - 데이터베이스 전문가 부족\r\n  - 시스템이 복잡하고, 전산화 비용 증가\r\n\r\n### 데이터베이스 용어(일부)\r\n\r\n- 빅데이터 : 데이터의 생성 양, 주기, 형식 등이 기존 데이터에 비해 매우 크기 때문에, 종래의 방법으로는 수집/저장/검색/분석이 어려운 방대한 데이터이다.\r\n- 데이터 마이닝 : 데이터웨어하우징에서 수집되고 분석된 자료를 사용자에게 제공하기 위해 분류 및 가공되는 요소 기술이다.\r\n- Hadoop : 일반 컴퓨터로 가상화된 대형 스토리지를 구현한다. 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 빅데이터 분산 처리를 돕는 자바 소프트웨어 오픈소스 프레임워크이다.\r\n\r\n## 데이터베이스의 구성\r\n\r\n### 스키마\r\n\r\n- 데이터베이스의 구조(개체, 속성, 관계)에 대한 정의이다.\r\n\r\n#### 스키마의 3계층\r\n\r\n- 외부 스키마(External Schema)\r\n  - 사용자나 응용 프로그래머가 접근할 수 있는 정의르 기술한다.\r\n- 개념 스키마(Conceptual Schema)\r\n  - 데이터베이스 전체를 정의한 것으로 데이터 개체, 관계, 제약조건, 접근 권한, 무결성 규칙 등을 명세한 것이다.\r\n  - 범기관적 입장에서 데이터베이스를 정의한다.\r\n- 내부 스키마(Internal Schema)\r\n  - 데이터의 실제 저장 방법을 기술한다.\r\n  - 물리적 저장 장치의 입장에서 본 데이터베이스 구조로써 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.\r\n\r\n### 데이터베이스 언어(Database Language)\r\n\r\n- 데이터 정의어(DDL : Data Definition Language)\r\n  - 데이터베이스의 객체들, 즉 테이블, 뷰, 인덱스 등에 대한 구조인 스키마를 정의하고 변경하며 삭제할 수 있는 기능이 있다.\r\n  - 논리적 데이터 구조와 물리적 데이터 구조 간의 사상 정의이다.\r\n  - 번역한 결과가 데이터 사전에 저장된다.\r\n- 데이터 조작어(DML : Data Manipulation Language)\r\n  - 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.\r\n  - 데이터의 검색/삽입/삭제/변경을 구행한다.\r\n- 데이터 제어어(DCL : Data Control Language)\r\n  - 불법적인 사용자로부터 데이터를 보호한다.\r\n  - 무결성을 유지한다.\r\n  - 데이터 회복 및 병행 제어를 수행한다.\r\n\r\n## 데이터베이스 모델\r\n\r\n- 데이터 모델 : 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구이다.\r\n\r\n### 데이터 모델의 구성 요소\r\n\r\n- 데이터 구조(Structure) : 데이터 구조 및 정적 성질을 표현한다.\r\n- 연산(Operations) : 데이터의 인스턴스에 적용 가능한 연산 명세와 조작 기법을 표현한다.\r\n- 제약조건(Constraints) : 데이터의 논리적 제한 명시 및 조작의 규칙이다.\r\n\r\n### 데이터 모델의 구분\r\n\r\n- 데이터베이스 모델\r\n  - 개념적 모델\r\n    - ERD(Entity Relationship Diagram)\r\n  - 논리적 모델\r\n    - 계층형\r\n    - 네트워크(망)형\r\n    - 관계형\r\n    - 객체지향형\r\n\r\n#### 개념적 데이터 모델\r\n\r\n- 속성들로 기술된 개체 타입과 이 개체 타입 간의 관계를 이용하여 현실 세계를 표현하는 방법이다.\r\n- E-R 모델(Entity-Relationship 모델 , 개체-관계 모델)\r\n  - 대표적인 개념적 데이터 모델이다.\r\n  - 개체 타입과 이들 간의 관계 타입을 이용하여 현실 세계를 개념적으로 표현한 방법이다.\r\n  - E-R 다이어그램 : E-R 모델을 그래프 방식으로 표현하였다.\r\n\r\n#### 논리적 데이터 모델\r\n\r\n- 필드로 기술된 데이터 타입과 이 데이터 타입 간의 관계 현실 세계를 표현하는 방법이다.\r\n- 종류\r\n  - 관계형 데이터 모델 : 데이터베이스를 테이블(Table)의 집합으로 표현한다.\r\n  - 계층형 데이터 모델 : 데이터베이스를 트리(Tree) 구조로 표현한다.\r\n  - 네트워크형 데이터 모델 : 데이터베이스를 그래프(Graph) 구조로 표현(owner-member 관계)하며, CODASYL DBTG 모델이라고도 한다.\r\n\r\n## 관계형 데이터베이스 모델\r\n\r\n- 관계형 데이터베이스를 구성하는 개체나 관계를 릴레이션(Relation)으로 표현한다.\r\n\r\n### 관계형 데이터베이스 모델 구조\r\n\r\n| 속성(Attribute) |  학번   | 이름 |     학과     | 학년 |\r\n| :-------------: | :-----: | :--: | :----------: | :--: |\r\n|   튜플(Tuple)   | 2024010 |  A   |   심리학과   |  1   |\r\n|      튜플       | 2025015 |  B   |  전자공학과  |  2   |\r\n|      튜플       | 2026016 |  C   | 컴퓨터공학과 |  3   |\r\n\r\n- 튜플(Tuple)\r\n  - 테이블의 행(Row)에 해당하며 파일 구조의 레코드(Record)와 같은 의미이다.\r\n  - 카디널리티(Cardinality) : 튜플의 수(기수)\r\n  - 한 릴레이션의 튜플들의 값은 모두 상이하며, 튜플 간 순서가 없다.\r\n- 속성(Attribue)\r\n  - 테이블의 열(Column)에 해당하며 파일 구조의 항목(Item), 필드(Field)와 같은 의미이다.\r\n  - 차수(Degress) : 속성의 수\r\n  - 한 릴레이션의 속성은 원자값이며, 속성 간 순서가 없다.\r\n- 도메인(Domain) : 하나의 속성이 가질 수 있는 원자값들의 집합이다.\r\n\r\n### 릴레이션의 특징\r\n\r\n- 튜플의 유일성 : 모든 튜플은 서로 다른 값을 갖는다.\r\n- 튜플의 무순서성 : 하나의 릴레이션에서 튜플의 순서는 없다.\r\n- 속성의 원자성 : 속성은 원자값을 갖는다.\r\n- 속성의 무순서성 : 각 속성은 릴레이션 내에서 유일한 이름을 가지며, 속성의 순서는 큰 의미가 없다.\r\n\r\n## 키(Key)의 종류와 무결성\r\n\r\n### 키의 분류\r\n\r\n| 학번 | 주민번호 | 이름 | 나이 | \u003c-학생---수강-\u003e | 학번 |      과목      |\r\n| :--: | :------: | :--: | :--: | :-------------: | :--: | :------------: |\r\n|  1   | 123123-1 |  A   |  10  |       ---       |  1   |    운영체제    |\r\n|  2   | 123123-1 |  B   |  20  |       ---       |  2   | 소프트웨어공학 |\r\n|  3   | 123123-1 |  C   |  30  |       ---       |  3   |     C언어      |\r\n\r\n- 슈퍼키(Super Key)\r\n  - 두 개 이상의 속성으로 구성된 키 또는 혼합키를 의미한다.\r\n  - 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는다.\r\n- 외래키(Foreign Key)\r\n  - 다른 테이블의 기본키로 사용되는 속성이다.\r\n  - \u003c수강\u003e 테이블에서 \u003c학생\u003e 테이블을 참조할 때 \u003c학생\u003e 테이블의 학번은 참조키, \u003c수강\u003e 테이블의 학번이 외래 키가 된다.\r\n- 무결성(Integrity)\r\n  - 릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션을 조작하는 과정에서의 의미전 관계 (Semantic Relationship)를 명세한 것으로 정의 대항으로 도메인, 키, 종속성 등이 있다.\r\n  - 개체 무결성 : 기본키의 값은 Null 값이나 중복 값을 가질 수 없다는 제약조건이다.\r\n  - 참조 무결성 : 릴레이션 R1에 속성 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 한다. 이때 참조할 수 없는 외래키 값을 가질 수 없다는 제약조건이다.\r\n  - 도메인 무결성 : 릴레이션 중 하나의 속성은 반드시 원자 값이어야 한다는 것을 보장하는 제약조건이다.\r\n\r\n# 데이터베이스 설계와 구조화\r\n\r\n### 데이터베이스 설계 단계\r\n\r\n1. 요구조건 분석\r\n   - 데이터베이스 사용자로부터 요구조건 수집과 요구조건 명세서를 작성한다.\r\n2. 개념적 설계\r\n   - 목표 DBMS에 독립적인 개념 스키마를 설계한다.\r\n   - 개념 스키마 모델링(ERD)과 트랜잭션 모델링을 병행 수행한다.\r\n3. 논리적 설계\r\n   - 목표 DBMS에 종속적인 논리적 스키마를 설계한다.\r\n   - 스키마의 평가 및 정제를 한다.\r\n   - 논리적 데이터 모델로 변환 및 트랜잭션 인터페이스를 설계한다.\r\n4. 물리적 설계\r\n   - 목표 DBMS에 종속적인 물리적 구조를 설계한다.\r\n   - 저장 레코드 양식 설계와 레코드 집중의 분석/설계, 엑세스 경로 인덱싱, 클러스터링, 해싱 등의 설계가 포함된다.\r\n   - 접근 경로 설계 및 트랜잭션 세부 설계를 한다.\r\n5. 데이터베이스 구현\r\n   - 목표 DBMS의 DDL(데이터 정의어)로 스키마를 작성한다.\r\n   - 데이터베이스에 등록 후 트랜잭션을 작성한다.\r\n\r\n### 데이터베이스 정규화\r\n\r\n- 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다.\r\n- 좋은 데이터베이스 스키마를 생성하고 불필요한 데이터의 중복을 방지하여 정보 검색을 용이하게 할 수 있도록 허용한다.\r\n\r\n#### 정규화의 목적\r\n\r\n- 데이터 구조의 안정성 최대화\r\n- 중복 데이터의 최소화\r\n- 수정 및 삭제 시 이상 현상 최소화\r\n- 테이블 불일치 위험 간소화\r\n\r\n### 이상 현상(Anomaly)\r\n\r\n- 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미한다.\r\n- 종류\r\n  - 삽입 이상(Insertion Anomaly) : 데이터를 삽입할 떄 불필요한 데이터가 함께 삽입되는 현상\r\n  - 삭제 이상(Deletion Anomaly) : 릴레이션의 한 튜플을 삭제함으로써 연쇄 삭제로 인해 정보의 손실을 발생시키는 현상\r\n  - 갱신 이상(Update Anomaly) : 튜플 중에서 일부 속성을 갱신함으로써 정보의 모순성이 발생하는 현상\r\n\r\n# 정규화\r\n\r\n### 정규화 과정\r\n\r\n1. 비정규 릴레이션\r\n2. 1NF(도메인이 원자값)\r\n3. 2NF(부분적 함수 종속 제거)\r\n4. 3NF(이행적 함수 종속 제거)\r\n5. BCNF(결정자이면서 후보키가 아닌 함수 종속 제거)\r\n6. 4NF(다치 종속 제거)\r\n7. 6NF(조인 종속성 제거)\r\n\r\n### 반정규화(비정규화)\r\n\r\n- 정규화를 통하여 정합성과 데이터 무결성이 보장되지만, 테이블의 개수가 증가함에 따라 테이블 간의 조인이 증가하여 조회 성능이 떨어질 수 있는데, 이렇게 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능 향상과 개발(Development) 및 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다.\r\n- 반정규화 기법 : 테이블 반정규화, 컬럼 반정규화, 관계 반정규화\r\n- 테이블 반정규화 기법 : 테이블 병합, 테이블 분할, 테이블 추가\r\n- 테이블 추가 반정규화 유형 : 중복 테이블 추가, 집계 테이블 추가, 진행 테이블 추가, 부분 테이블 추가\r\n\r\n# SQL ★★★\r\n\r\n### SQL(Structured Query Language)\r\n\r\n- 관계형 데이터베이스의 표준 질의어\r\n- 종류\r\n  - DDL(데이터 정의어), DML(데이터 조작어), DCL(데이터 제어어)\r\n\r\n### DDL(Data Definition Language, 데이터 정의어)\r\n\r\n- 데이터베이스의 정의/변경/삭제에 사용되는 언어이다.\r\n- 논리적 데이터 구조와 물리적 데이터 구조로 정의할 수 있다.\r\n- 논리적 데이터 구조와 물리적 데이터 구조 간의 사상을 정의한다.\r\n- 번역한 결과가 데이터 사전에 저장된다.\r\n- 종류\r\n  - CREATE : 스키마, 도메인, 테이블, 뷰 정의\r\n  - ALTER : 테이블 정의 변경(필드 추가, 삭제, 갱신)\r\n  - DROP : 스키마, 도메인, 테이블, 뷰 삭제\r\n\r\n#### CREATE문 문법 구조\r\n\r\n- CREATE TABLE : 테이블을 생성하는 명령문\r\n\r\n```SQL\r\n\r\nCREATE TABLE 기본테이블\r\n    (\r\n        {열이름 데이터_타입 [NOT NULL] [DEFALUT 값]}\r\n        {[PRIMARY KEY(열이름_리스트)]},\r\n        {[UNIQUE(열이름_리스트,...)]},\r\n        {[FOREIGN KEY(열이름_리스트)]\r\n        REFERENCES 기본테이블[(기본키_열이름)]\r\n        [ON DELETE 옵션]\r\n        [ON UPDATE 옵션]}\r\n        [CHECK(조건식)]\r\n    );\r\n\r\n```\r\n\r\n- {}는 중복 가능한 부분\r\n- NOT NULL은 특정 열에 대해 NULL 값을 허용하지 않을 때 기술\r\n- PRIMARY KEY는 기본키를 구성하는 속성을 지정할 때 사용된다.\r\n- FOREIGN KEY는 외래키로 어떤 릴레이션의 기본키를 참조하는지를 기술한다.\r\n\r\n#### ALTER문 문법 구조\r\n\r\n- ALTER TABLE : 테이블 구조(필드 추가, 삭제, 변경) 변경문이다.\r\n\r\n```SQL\r\nALTER TABLE 테이블_이름 ADD 열_이름 데이터_타입 DEFAULT 값;\r\nALTER TABLE 테이블_이름 ALTER 열_이름 SET DEFAULT 값;\r\nALTER TABLE 테이블_이름 DROP 열_이름 CASCADE;\r\n```\r\n\r\n- ADD : 새로운 열(속성)을 추가할 때 사용한다.\r\n- ALTER : 특정 열(속성)의 디폴트 값을 변경할 때 사용한다.\r\n- DROP : 특정 열(속성)을 제거할 때 사용한다.\r\n\r\n#### DROP문 문법 구조\r\n\r\n- DROP : 테이블 삭제문\r\n\r\n```SQL\r\nDROP SCHEMA 스키마_이름 [CASCADE | RESTRICT];\r\nDROP DOMAIN 도메인_이름 [CASCADE | RESTRICT];\r\nDROP TABLE 테이블_이름 [CASCADE | RESTRICT];\r\nDROP INDEX 인덱스_이름;\r\n```\r\n\r\n- CASCADE : 옵션을 사용하면 삭제할 요소가 다른 개체에서 참조 중이라도 삭제가 수행된다.\r\n- RESTRICT : 옵션을 사용하면 삭제할 요소가 다른 개체에서 참조 중이라면 삭제가 수행되지 않는다.\r\n\r\n### DCL(Data Control Language, 데이터 제어어)\r\n\r\n- 데이터 제어 정의 및 기술에 사용되는 언어이다.\r\n- 불법적인 사용자로부터 데이터를 보호한다.\r\n- 무결성을 유지하고 데이터 복구 및 병행 제어를 한다.\r\n- 종류\r\n  - COMMIT : 명령어로 수행된 결과를 실제 물리적 디스크로 저장하고, 명령어로 수행을 성공적으로 완료하였음을 선언한다.\r\n  - ROLLBACK : 명령어로 수행에 실패하였음을 알리고, 수행된 결과를 원상 복귀시킨다.\r\n  - GRANT : 데이터베이스 사용자에게 사용 권한을 부여한다.\r\n  - REVOKE : 데이터베이스 사용자로부터 사용 권한을 취소한다.\r\n\r\n### DML(Data Maniqulation Language, 데이터 조작어)\r\n\r\n- 데이터의 검색/삽입/삭제/변경에 사용되는 언어이다.\r\n- 사용자와 DBMS 간의 인터페이스를 제공한다.\r\n- 종류\r\n  - SELECT\r\n    - 튜플 검색 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        SELECT 속성명[ALL | DISTINCT]\r\n        FROM 릴레이션명\r\n        WHERE 조건\r\n        [GROUP BY 속성명1, 속성명2, ... ]\r\n        [HAVING 조건]\r\n        [ORDER BY 속성명 [ASC | DESC]]\r\n    ```\r\n    - ALL : 모든 튜플을 검색(생략 가능)\r\n    - DISTINCT : 중복된 튜플 생략\r\n  - INSERT\r\n    - 튜플 삽입 명령어\r\n    - 기본 구조\r\n    ```SQL\r\n        INSERT INTO 테이블명(속성명1, 속성명2,...)\r\n        VALUES(데이터1, 데이터2 ...);\r\n    ```\r\n  - DELTETE\r\n    - 튜플 삭제 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        DELETE\r\n        FROM 테이블명\r\n        WHERE 조건;\r\n    ```\r\n  - UPDATE\r\n    - 튜플의 내용 변경 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        UPDATE 테이블명\r\n        SET 속성명 = 데이터\r\n        WHERE 조건;\r\n    ```\r\n\r\n### NoSQL\r\n\r\n- \"Not only SQL\"로, SQL만을 사용하지 않는 데이터베이스 관리 시스템(DBMS)을 지칭하며, 다양한 유형의 데이터베이스를 사용하는 것을 의미한다.\r\n- 데이터를 저장하는데 SQL 외에도 다른 방법도 있다는 개념하에 비정형 데이터의 저장을 위해 유연한 데이터 모델을 지원한다.\r\n- 전통적인 관계형 데이터베이스 관리 시스템과는 다른 비관계형(Non-Relational) DBMS이다.\r\n\r\n### 집계 함수\r\n\r\n- COUNT : 테이블의 행 수를 계산할 때 / 표현식: COUNT(\\*)\r\n- SUM : 하나 또는 여러 개의 열 합계를 구할 때 / 표현식 : SUM(열 이름)\r\n- AVG : 하나 또는 여러 개의 열 평균을 구할 때 / 표현식 : AVG(열 이름)\r\n- MAX : 해당 열의 최댓값을 구할 때 / 표현식 : MAX(열 이름)\r\n\r\n### HAVING 절을 사용한 조회 검색\r\n\r\n- GROUP BY절에 의해 선택된 그룹의 탐색 조건을 지정할 수 있으며 SUM, AVG, COUNT, MAX, MIN 등의 그룹 함수와 함께 사용할 수 있다.\r\n\r\n### ORDER BY 절을 이용한 정렬 검색\r\n\r\n- 특정 항목을 기준으로 검색 테이블의 행들을 오름차순(ASC) 또는 내림차순(DESC)으로 정렬할 때 사용한다. 생략하면 ASC가 디폴트 값이 되어 오름차순으로 정렬된다.\r\n\r\n# 트랜잭션 ★★★\r\n\r\n- 하나의 논리적 기능을 수행하기 위한 작업 단위이다.\r\n- 데이터베이스에서 일어나는 연산의 집합이다.\r\n\r\n### 트랜잭션의 특성\r\n\r\n- 원자성(Atomicity)\r\n  - 완전하게 수행이 완료되지 않으면 전혀 수행되지 않아야 한다.\r\n  - 연산은 Commit, Rollback을 이용하여 적용 또는 취소로 한꺼번에 완료되어야 한다.\r\n  - 중간에 하나의 오류가 발생되더라도 취소가 되어야 한다.\r\n- 일관성(Consistency)\r\n  - 시스템의 고정 요소는 트랜잭션 수행 전후가 같아야 한다.\r\n  - 트랜잭션 결과는 일관성을 유지해야 한다.\r\n- 격리성(Isolation, 고립성)\r\n  - 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 한다.\r\n- 영속성(Durability, 지속성)\r\n  - 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억된다.\r\n  - 은행계좌에서 100원 중 10원을 인출했을 때 계좌에는 90원이 남아 있어야 한다.\r\n\r\n# 보안과 권한 부여\r\n\r\n- 보안(Security)의 개념 : 권한이 없는 사용자로부터 데이터베이스를 보호하는 것\r\n\r\n### 권한 부여/회수\r\n\r\n#### GRANT\r\n\r\n- 데이터베이스 사용자에게 사용 권한을 부여한다.\r\n- 기본 구조\r\n  ```SQL\r\n      GRANT 권한 ON 데이터 객체 TO 사용자 [WITH GRANT OPTION];\r\n  ```\r\n- WITH GRANT OPTION : 사용자가 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여한다.\r\n- 부여 가능한 권한 : Update, Delete, Insert, Select\r\n\r\n#### REVOKE\r\n\r\n- 데이터베이스 사용자로부터 사용 권한을 취소한다.\r\n- 기본 구조\r\n  ```SQL\r\n      REVOKE [GRANT OPTION FOR] 권한 ON 데이터 객체 FROM 사용자 [CASCADE];\r\n  ```\r\n- GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소한다.\r\n- CASCADE : 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄 취소한다.\r\n- 부여 가능한 권한 : Update, Delete, Insert, Select\r\n\r\n# 암호화\r\n\r\n- 네트워크를 통하거나 컴퓨터 내부에 자료를 저장할때 권한을 가진 사람 외에는 데이터를 보지 못하도록 하는 것\r\n- 일반 평문을 다양한 방식의 암호화 기법으로 가공하여 저장하거나 전송 권한이 있는 사용자에 의해 복호화되어 사용한다.\r\n\r\n암호화 과정 : 평문 =\u003e 암호화(암호키) =\u003e 암호문 =\u003e 복호화(복호키) =\u003e 평문\r\n\r\n### 암호화 기법\r\n\r\n- 비밀키(Private Key, 대칭키) 암호화 기법\r\n  - 비밀키 암호화 기법을 동일한 키로 데이터를 암호화하고 복호화한다.\r\n  - 암호화, 복호화 키가 같아서 키를 공개하면 타인이 알게 된다.\r\n  - 암호화와 복호화 속도가 빠르다.\r\n- 공개키(Public Key, 비대칭키) 암호화 기법\r\n  - 공개키 암호화 기법은 각기 다른 키로 데이터를 암호화하고 복호화한다.\r\n  - 암호화, 복호화 키가 다르므로 키는 공개되어도 된다.\r\n  - 암호화 및 복호화 속도가 느리다.\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n"},"__N_SSG":true},"page":"/[slug]","query":{"slug":"sw-first-test3"},"buildId":"K8nG0fk5J7F1j1N6vDjxZ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>