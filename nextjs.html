<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Rain Sugar BangBang Front-End</title><meta name="description" content="developer&#x27;s blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Rain Sugar BangBang"/><meta property="og:description" content="welcome to developer&#x27;s blog"/><meta property="og:image" content="[object Module]"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/58c0bd87c8b633a7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/58c0bd87c8b633a7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-b0c8bcfd40968c52.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4d6ef6706c31a304.js" defer=""></script><script src="/_next/static/chunks/pages/nextjs-d4fea452a1be5d43.js" defer=""></script><script src="/_next/static/BZZ_OYBxy9EwlaU748_MJ/_buildManifest.js" defer=""></script><script src="/_next/static/BZZ_OYBxy9EwlaU748_MJ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="sc-659af5cc-0 hxMmoh"><h1>Rain Sugar BangBang</h1></header><div class="sc-91abfacf-0 hixHKa"><section class="sc-91abfacf-1 kJlAES"><article class="sc-91abfacf-2 dOLzYO"><p style="font-weight:bold">전체 글 (<!-- -->2<!-- -->)</p><ul class="sc-9d093bb8-0 iStfdu"><li class="sc-9d093bb8-1 cMppwp"><img alt="카테고리 이미지" loading="lazy" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/NEXTJS.b97846b2.png"/><h1>nextjs에 react responsive 적용하기</h1><p>nextjs에서 화면 크기에 따른 적응형 컴포넌트 를 구현하기 위해 responsive를 이용할 수 있다.</p><span>2023. 03. 04</span></li><li class="sc-9d093bb8-1 cMppwp"><img alt="카테고리 이미지" loading="lazy" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/NEXTJS.b97846b2.png"/><h1>nextjs에서의 로딩처리</h1><p>nextjs에서 페이지 전환을 유동적으로 바꿔줄 수 있다.</p><span>2023. 03. 04</span></li></ul></article><aside class="sc-e133a2b6-0 gcDQQn"><nav class="sc-3b401f8d-0 GgdHX"><div class="sc-9e3f195e-0 bTlfnu"><img alt="profile" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" style="color:transparent" src="https://avatars.githubusercontent.com/u/85297720?v=4"/><p>Hanbbi</p></div><div class="sc-9e3f195e-1 kyntDu"><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0 0 68.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"></path></svg><span>yhl0078@gmail.com</span></a><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>Github</span></a></div><ul class="sc-3b401f8d-1 gUXiWx"><li>Category</li><li class="sc-3b401f8d-2 dTJWtr">Simple Memo</li><li class="sc-3b401f8d-2 dTJWtr">HTML</li><li class="sc-3b401f8d-2 dTJWtr">CSS</li><li class="sc-3b401f8d-2 dTJWtr">JavaScript</li><li class="sc-3b401f8d-2 dTJWtr">TypeScript</li><li class="sc-3b401f8d-2 dTJWtr">Redux</li><li class="sc-3b401f8d-2 dTJWtr">React</li><li class="sc-3b401f8d-2 dTJWtr">Nextjs</li><li class="sc-3b401f8d-2 dTJWtr">Nestjs</li></ul></nav></aside></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"nextjs에 react responsive 적용하기","description":"nextjs에서 화면 크기에 따른 적응형 컴포넌트 를 구현하기 위해 responsive를 이용할 수 있다.","category":"nextjs","date":"2023-03-04","content":"\r\n### 이번에 새로 만들고 있는 토이 프로젝트를 작업하던 중, 모바일 화면일때만 화면을 보여주고 싶었다. 단, 모든 컴포넌트에 미디어쿼리를 통해 작성해줄 수는 없기에 react-responsive를 적용해 화면이 481px을 넘어가면 고정된 페이지를 보여줄 수 있도록 코드를 작성했다.\r\n\r\n## react-responsive 설치\r\n\r\n```bash\r\nyarn add react-responsive\r\n```\r\n\r\n## hook 설정\r\n\r\n```typescript\r\n// hook\r\n// useMideaQuery.tsx\r\nexport const Desktop = ({ children }: any) =\u003e {\r\n  const isDesktop = useMediaQuery({\r\n    minWidth: 481,\r\n  });\r\n  return isDesktop ? children : null;\r\n};\r\n\r\nexport const Mobile = ({ children }: any) =\u003e {\r\n  const isMobile = useMediaQuery({\r\n    minWidth: 481,\r\n  });\r\n  return Mobile ? children : null;\r\n};\r\n```\r\n\r\n## \\_app.ts 적용\r\n\r\n```typescript\r\n// _app.tsx\r\n\r\n// ...\r\nimport { Mobile } from \"src/hooks/useMideaQuery\";\r\nimport { CannotDesktop } from \"src/desktop/CannotDesktop\";\r\n\r\n\u003c\u003e\r\n  \u003cMobile\u003e\r\n    \u003cLayout\u003e\r\n      {isLoading ? \u003cLoadingSpinner /\u003e : null}\r\n      \u003cComponent {...pageProps} /\u003e\r\n    \u003c/Layout\u003e\r\n  \u003c/Mobile\u003e\r\n  \u003cDesktop\u003e\r\n    \u003cCannotDesktop /\u003e\r\n  \u003c/Desktop\u003e\r\n\u003c/\u003e;\r\n```\r\n\r\n똑같은 코드로 리액트 코드에 적용할 때는 문제가 없었지만, Nextjs를 이용한 이번 상황의 경우 Hydration 에러가 발생했다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbjYUXg%2FbtrTRCeaovE%2FwQr4OZdJectnkkG06XmTEk%2Fimg.png)\r\n\r\nvercel로 배포할 때는 정상적으로 빌드되기는 했지만\r\n\r\n로컬에서 작업할때 지속적으로 발생하는 오류 메세지 창이 불편하기도 하여 바로 처리해봤다.\r\n\r\n\u003e Hydration failed because the initial UI does not match what was rendered on the server\r\n\r\n초기 UI가 서버에서 렌더링된 것과 일치하지 않는다고 한다.\r\n\r\nhttps://nextjs.org/docs/messages/react-hydration-error\r\n\r\n공식 페이지를 보면 \"애플리케이션을 렌더링하는 동안 미리 렌더링된 React 트리(SSR/SSG)와 브라우저에서 첫 번째 렌더링 중에 렌더링된 React 트리 간에 차이가 있었기 때문에 발생한 오류\"라고 한다.\r\n\r\n일반적으로 이 문제는 사전 렌더링과 브라우저 간에 다를 수 있는 항목에 의존하는 특정 라리브러리 또는 애플리케이션 코드를 사용하여 발생한다고 하는데,\r\n\r\n나의 경우, react-responsive에 의한 경우였다.\r\n\r\n## 코드 수정\r\n\r\n```typescript\r\n// useMideaQuery.tsx\r\n\r\nimport { useEffect, useState } from \"react\";\r\nimport { useMediaQuery } from \"react-responsive\";\r\n\r\nexport const Mobile = () =\u003e {\r\n  const [mobile, setMobile] = useState\u003cboolean\u003e(false);\r\n  const isMobile = useMediaQuery({ maxWidth: 480 });\r\n\r\n  const checkResize = () =\u003e {\r\n    if (isMobile) {\r\n      setMobile(true);\r\n    } else {\r\n      setMobile(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() =\u003e {\r\n    checkResize();\r\n  }, [isMobile]);\r\n\r\n  return mobile;\r\n};\r\n//_app.tsx\r\n\r\n\u003cRecoilRoot\u003e\r\n  {isMobile ? (\r\n    \u003cLayout\u003e\r\n      {isLoading ? \u003cLoadingSpinner /\u003e : null}\r\n      \u003cComponent {...pageProps} /\u003e\r\n    \u003c/Layout\u003e\r\n  ) : (\r\n    \u003cCannotDesktop /\u003e\r\n  )}\r\n\u003c/RecoilRoot\u003e;\r\n```\r\n\r\nuseMideaQuery가 window 화면을 기준으로 동작하기 때문에,\r\n\r\n공식문서의 예제와 비슷하게 useState를 통한 boolean 값으로 화면을 노출시켜줬다.\r\n\r\n위의 방식을 적용하니 hydration 에러 없이 잘 작동하는 모습을 볼 수 있었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdH0CZg%2FbtrTRp0izJZ%2FiolwpQXLvGOommEBhpCkaK%2Fimg.png)\r\n"},{"title":"nextjs에서의 로딩처리","description":"nextjs에서 페이지 전환을 유동적으로 바꿔줄 수 있다.","category":"nextjs","date":"2023-03-04","content":"\r\n# Nextjs에서 로딩처리하기\r\n\r\n### 모든 페이지를 미리 렌더링하는 NextJS 특성상, 다른 페이지로 라우팅이 진행될때, 사용자는 가만히 멈춰있는 화면을 보게될 수 있다. 때문에 페이지 전환을 정지화면으로 두지 않기 위해 로딩 처리를 구현해볼 수 있다.\r\n\r\n## 로딩 스피너 세팅\r\n\r\n```typescript\r\n// _app.tsx\r\n\r\n// 미리 만들어놓은 로딩 훅과 로딩 스피너\r\nimport { useLoading } from \"src/hooks/useLoading\";\r\nimport { LoadingSpinner } from \"src/components/videos/video/LoadingSpinner\";\r\n\r\n\u003cLayout\u003e\r\n  {isLoading ? \u003cLoadingSpinner /\u003e : null}\r\n  \u003cComponent {...pageProps} /\u003e\r\n\u003c/Layout\u003e;\r\n```\r\n\r\n로딩스피너는 CSS로 만들어도 좋고, SVG나 GIF, 라이브러리 등 자유롭게 적용해도 좋다.\r\n\r\n## 라우팅 시 적용될 이벤트 설정\r\n\r\n```typescript\r\n// useLoading.ts\r\n\r\nimport Router from \"next/router\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\nexport const useLoading = () =\u003e {\r\n  const [nowLoading, setNowLoading] = useState\u003cboolean\u003e(false);\r\n  useEffect(() =\u003e {\r\n    const start = () =\u003e {\r\n      setNowLoading(true);\r\n    };\r\n    const end = () =\u003e {\r\n      setNowLoading(false);\r\n    };\r\n    Router.events.on(\"routeChangeStart\", start);\r\n    Router.events.on(\"routeChangeComplete\", end);\r\n    Router.events.on(\"routeChangeError\", end);\r\n    return () =\u003e {\r\n      Router.events.off(\"routeChangeStart\", start);\r\n      Router.events.off(\"routeChangeComplete\", end);\r\n      Router.events.off(\"routeChangeError\", end);\r\n    };\r\n  }, []);\r\n\r\n  return nowLoading ? true : false;\r\n};\r\n```\r\n\r\n- routeChangeStart(url, { shallow }) - 라우트가 변경되기 시작할때 트리거됨.\r\n\r\n- routeChangeComplete(url, { shallow }) - 라우트가 완전히 변경되었을 때 트리거됨.\r\n\r\n- routeChangeError(err, url, { shallow }) - 라우트 변경 중에 에러가 발생했거나, 취소되었을 때 트리거됨.\r\n\r\n\\_app.tsx(jsx)에 로딩 스피너나 로딩 페이지를 적용해 놓으면,\r\n\r\n라우팅으로 인한 페이지 이동이 일어날 때마다 원하는 로딩 창을 호출해줄 수 있다.\r\n\r\n## 적용된 페이지\r\n\r\n![image](https://blog.kakaocdn.net/dn/cWz72g/btrSmvngm4A/hgKg4FviDpAqQk5U6kGHXK/img.gif)\r\n"}]},"__N_SSG":true},"page":"/nextjs","query":{},"buildId":"BZZ_OYBxy9EwlaU748_MJ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>