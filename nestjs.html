<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Rain Sugar BangBang Front-End</title><meta name="description" content="developer&#x27;s blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta http-equiv="subject" content="nestjs"/><meta property="og:title" content="Rain Sugar BangBang"/><meta property="og:description" content="welcome to developer&#x27;s blog"/><meta property="og:image" content="[object Module]"/><meta name="naver-site-verification" content="af9c8049662a7c6c85ea946e9eb561086e70062c"/><meta name="google-site-verification" content="Zgp7rA3RAdcRnhPPsGLK-t4KVTO86AejlDIQQIGpvLg"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4077287316160146" crossorigin="anonymous"></script><link rel="icon" href="/favicon.ico"/><link rel="preload" as="image" href="/images/cards/NESTJS.png"/><meta name="next-head-count" content="13"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/f9bc783e634631d2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f9bc783e634631d2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7d0bddee48749f95.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-b0c8bcfd40968c52.js" defer=""></script><script src="/_next/static/chunks/pages/_app-630e47b195f5c30b.js" defer=""></script><script src="/_next/static/chunks/789-5376272209331100.js" defer=""></script><script src="/_next/static/chunks/pages/nestjs-1c9bb0e28a3c92eb.js" defer=""></script><script src="/_next/static/gvRFHA6ylUyeyOUUknmR4/_buildManifest.js" defer=""></script><script src="/_next/static/gvRFHA6ylUyeyOUUknmR4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-c845a976-0 icUnkm"><header class="sc-fe6a8-0 fZHroo"><span style="display:none" class="sc-fe6a8-1 kOlYBJ"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 17 17" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g></g><path d="M16 3v2h-15v-2h15zM1 10h15v-2h-15v2zM1 15h15v-2h-15v2z"></path></svg></span><h1><a href="/">Rain Sugar BangBang</a></h1><span style="display:none" class="sc-fe6a8-1 kOlYBJ"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg></span></header><section class="sc-c845a976-1 bePtAz"><aside class="sc-226f6af7-0 jzKfYm"><div class="sc-226f6af7-1 eudLNA"><a target="_blank" href="https://portfolio-sigma-wheat-63.vercel.app/"><img alt="profile" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" src="/images/profileImage/cat.png"/><span>Go Profile!</span></a><p>Hanbbi</p></div><div class="sc-226f6af7-2 fEJwOM"><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0 0 68.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"></path></svg><span>yhl0078@gmail.com</span></a><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>Github</span></a></div></aside><article class="sc-c845a976-2 jRRSKe"><div class="sc-b797c1b7-0 jSiudw"><div class="sc-b797c1b7-1 ctQsiT"><span>전체 글<!-- --> (<!-- -->5<!-- -->)</span><form><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg><input type="text" style="opacity:0" placeholder="키워드 입력 후 엔터를 눌러주세요" class="sc-15314a72-0 bDAivC"/></form></div><ul class="sc-b797c1b7-2 dwTYwt"><a href="/nestjs-localhost-https"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/NESTJS.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>Localhost 환경에서 HTTPS 적용하기</p><span>2023. 04. 30</span></div></li></a><a href="/nestjs-server-client-cookie2"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/NESTJS.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>NestJS에서 클라이언트로 쿠키 보내기 (왜 내 쿠키는...</p><span>2023. 04. 30</span></div></li></a><a href="/nestjs-server-client-cookie"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/NESTJS.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>NestJS에서 클라이언트로 쿠키 보내기 (왜 내 쿠키는...</p><span>2023. 04. 13</span></div></li></a><a href="/nestjs-use-bcrypt"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/NESTJS.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>Nestjs에서 bcrypt 사용하기</p><span>2023. 04. 13</span></div></li></a><a href="/nestjs-custom-repository"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/NESTJS.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>Entityrepository()를 대신한 Reposit...</p><span>2023. 03. 04</span></div></li></a></ul><ul class="sc-6f9dd46-0 eRBUSp"><li class="noPrev"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z"></path></svg></li><li id="1" class="activePage">1</li><li class="noNext"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z"></path></svg></li></ul></div></article><aside class="sc-25c0fcf1-0 hVEAVi"><nav class="sc-cd9d196f-0 eIKFyK"><ul class="sc-cd9d196f-1 ljGEKP"><li>Category</li><li class="sc-cd9d196f-2 itBJIo"><a href="/github">Simple Memo</a></li><li class="sc-cd9d196f-2 itBJIo"><a href="/html">HTML</a></li><li class="sc-cd9d196f-2 itBJIo"><a href="/css">CSS</a></li><li class="sc-cd9d196f-2 itBJIo"><a href="/javascript">JavaScript</a></li><li class="sc-cd9d196f-2 itBJIo"><a href="/typescript">TypeScript</a></li><li class="sc-cd9d196f-2 itBJIo"><a href="/redux">Redux</a></li><li class="sc-cd9d196f-2 itBJIo"><a href="/react">React</a></li><li class="sc-cd9d196f-2 itBJIo"><a href="/nextjs">Nextjs</a></li><li class="sc-cd9d196f-2 itBJIo"><a style="color:white;font-weight:bold" href="/nestjs">Nestjs</a></li></ul></nav></aside></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"nestjs localhost https","description":"Localhost 환경에서 HTTPS 적용하기","category":"nestjs","date":"2023-04-30","content":"\r\n### Local 환경에서 https 설정이 필요한 이유\r\n\r\n로컬 환경에서 내가 원하는대로 기능들이 작동한다고 해도, 배포 환경과 로컬 개발 환경의 차이로 인해 코드의 수정이 필요해질 수 있다. 이러한 이유로 개발 환경을 배포 환경과 최대한 동일하게 만들어주는 것이 좋다. 또한 최근의 배포 환경들은 대부분 https로 이뤄져 있기 때문에 그에 맞춰 설정해줄 필요가 있다.\r\n\r\n### 자체 서명 인증서 생성 (openssl 사용)\r\n\r\n```bash\r\n# 개인 키 생성\r\n$ openssl genrsa -out private-key.pem 2048\r\n\r\n# 개인 키를 사용한 새로운 인증서 요청서 생성\r\n$ openssl req -new -key private-key.pem -out cert-request.csr\r\n\r\n# 요청서를 사용한 자체 서명 인증서 생성\r\n$ openssl x509 -req -in cert-request.csr -signkey private-key.pem -out cert.pem\r\n```\r\n\r\n인증서 생성 시 입력사항은 모두 건너뛰어도 무관하다.\r\n\r\n### HTTPS 구성 설정 - main.ts\r\n\r\n```typescript\r\nimport * as fs from \"fs\";\r\nimport * as https from \"https\";\r\n\r\nasync function bootstrap() {\r\n  const httpsOptions = {\r\n    key: fs.readFileSync(\"./private-key.pem\"),\r\n    cert: fs.readFileSync(\"./cert.pem\"),\r\n  };\r\n  const app = await NestFactory.create(AppModule, {\r\n    httpsOptions,\r\n  });\r\n  // 필요에 따라 cors 설정도 가능\r\n  // app.enableCors({\r\n  //  origin: [url,...],\r\n  //  credentials: true, 쿠키를 사용하는 경우 설정\r\n  // });\r\n  await app.listen(3000);\r\n}\r\nbootstrap();\r\n```\r\n\r\n설정이 완료되면 로컬에서 https 환경처럼 적용할 수 있다.\r\n\r\n하지만 자체 인증서로 https를 만들어 SSR(ServerSideRendering)이나 API 요청 시 self certifi 에러가 발생할 수 있다. 이런 경우 프론트단 env에 다음과 같이 설정해주면 된다.\r\n\r\n```bash\r\n# .env\r\nNODE_TLS_REJECT_UNAUTHORIZED=0\r\n```\r\n\r\n그럼에도 오류가 발생하는 경우 아래의 링크를 통해 크롬 환경설정을 해주면 된다.\r\n\r\nchrome://flags/#allow-insecure-localhost\r\n\r\n유효하지 않은 인증서 허용으로 설정\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3WChm%2Fbtsdi3DwSL4%2F5cdQ9YFzgaKugT4u9ewDk0%2Fimg.png)\r\n"},{"title":"nestjs server client cookie2","description":"NestJS에서 클라이언트로 쿠키 보내기 (왜 내 쿠키는 안받아줘요?) - 배포환경","category":"nestjs","date":"2023-04-30","content":"\r\n### **[서버에서 브라우저로 쿠키 저장](https://lee-yo-han.github.io/nestjs-server-client-cookie)**\r\n\r\n분명 로컬에서는 쿠키가 정상적으로 브라우저에 저장되는 것을 볼 수 있었는데, 배포를 하고 나니 또다시 쿠키가 보이지 않았다. response headers에는 쿠키 값과 함께 다음과 같은 에러 문구를 볼 수 있었다.\r\n\r\n\u003e **this attempt to set a cookie via a set cookie header was blocked because its domain attribue was invalid with reqards to the current host url**\r\n\u003e\r\n\u003e \u003e \"설정된 쿠키 헤더를 통해 쿠키를 설정하려는 이 시도는 해당 도메인 속성이 현재 호스트 URL에 대해 유효하지 않기 때문에 차단되었습니다.\"\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcGZzIY%2FbtsdemcKoT1%2FcT16wBLzk5J48gv37fGyPK%2Fimg.png)\r\n\r\n쿠키 전송 옵션은 다음과 같다.\r\n\r\n```typescript\r\nres.cookie(\"cookie\", \"cookie\", {\r\n  maxAge: 0,\r\n  sameSite: process.env.COOKIE_PARSE_SAME_SITE as SameSite, // \"none\"\r\n  secure: true,\r\n  httpOnly: true,\r\n  domain: process.env.COOKIE_PARSE_DOMAIN, // \"www.backend.com\"\r\n});\r\n```\r\n\r\n프론트엔드의 URL이 https://www.frontend.com 이고,\r\n\r\n백엔드의 URL이 https://www.backend.com 이라고 했을 때, domain 속성을 백엔드 URL로 설정했을 때 발생한 오류이며, domain을 프론트엔드 URL로 바꾸면 response headers에 쿠키 값 자체가 확인되지 않았다.\r\n\r\ncors 설정도 credential: true나 origin 등을 정상적으로 해놓은 상태이기 때문에 쿠키 외 다른 데이터는 정상적으로 받아오는걸 확인할 수 있었다.\r\n\r\n다른 자료를 찾아보니, secure 속성을 적용하면 쿠키가 정상적으로 저장된다고는 하지만 본인은 이런 문제가 해결되지 않았다.\r\n\r\n결국 도메인을 구매해서 사용하게 되었다.\r\n\r\n예를 들어 프론트엔드의 URL은 https://www.product.com 로,\r\n\r\n백엔드의 URL은 https://api.product.com 으로 연동시켜주고, 쿠키 옵션은 아래처럼 바꿨다.\r\n\r\n```typescript\r\nres.cookie(\"cookie\", \"cookie\", {\r\n  maxAge: 0,\r\n  sameSite: process.env.COOKIE_PARSE_SAME_SITE as SameSite, // \"lax\"\r\n  secure: true,\r\n  httpOnly: true,\r\n  domain: process.env.COOKIE_PARSE_DOMAIN, // \".product.com\"\r\n});\r\n```\r\n\r\n같은 도메인을 사용하고 나서야 쿠키가 정상적으로 브라우저로 접속하는 것을 확인할 수 있었다.\r\n"},{"title":"nestjs server client cookie","description":"NestJS에서 클라이언트로 쿠키 보내기 (왜 내 쿠키는 안받아줘요?)","category":"nestjs","date":"2023-04-13","content":"\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpD9qr%2Fbtr9Oa0APIT%2FFuzZyjjney7aKkIXy6BAfK%2Fimg.png)\r\n\r\n## 쿠키(Cookie)란?\r\n\r\n쿠키는 서버에서 클라이언트에게 보내는 작은 데이터 조각이다. 일반적으로 브라우저에서 웹 사이트를 방문할 때 쿠키를 사용하여 사용자의 활동을 기록하고, 이후에 그 사용자가 같은 웹 사이트를 방문할 때 이 정보를 사용해 그에 맞게 동작하게 해준다. 하지만 쿠키는 당사자뿐만 아닌 제 3자가 조회하는 것도 가능하기 때문에 개인 정보를 담는 등 보안상 민감한 정보를 저장하는 데에는 적합하지 않기 때문에 탈취되거나 사용자에 의해 조작되어도 크게 문제 되지 않을 정보를 주로 저장한다. (ex. 다크 모드, 장바구니 목록 등)\r\n\r\n## 서버에서 클라이언트로 Cookie 전송 예제\r\n\r\n### 모듈 설치\r\n\r\n```bash\r\nyarn add cookie-parser @types/cookie-parser # 쿠키 관리 모듈\r\n```\r\n\r\n### 모듈 적용\r\n\r\n```typescript\r\n// main.ts\r\n\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { AppModule } from \"./app.module\";\r\nimport * as cookieParser from \"cookie-parser\";\r\n\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule);\r\n  app.enableCors({\r\n    // cors 설정\r\n    origin: \"http://localhost:3000\",\r\n    credentials: true, // 쿠키를 사용할 수 있게 해당 값을 true로 설정\r\n  });\r\n  app.use(cookieParser()); // 쿠키의 편리한 이용을 위해 cookieParser 적용\r\n  await app.listen(3001);\r\n}\r\nbootstrap();\r\n```\r\n\r\n### 쿠키 사용 로직\r\n\r\n```typescript\r\n// controller.ts\r\n\r\nimport { Response } from \"express\";\r\nimport { Controller, Get, Res } from \"@nestjs/common\";\r\n\r\n@Controller(\"myController\")\r\nexport class MyController {\r\n  @Get()\r\n  getCookie(@Res() res: Response) {\r\n    // express의 Response 객체를 불러와 사용해준다.\r\n    // 쿠키 설정\r\n    res.cookie(\"cookieName\", \"cookieValue\", { maxAge: 900000, httpOnly: true });\r\n    // maxAge : 유효기간을 밀리초 단위로 설정\r\n    // httpOnly : 클라이언트에서 쿠키에 접근할 수 없도록 설정\r\n\r\n    // HTTP 응답 반환\r\n    return res.send(\"쿠키가 설정되었습니다.\");\r\n  }\r\n}\r\n```\r\n\r\n쿠키를 요청하는 클라이언트에서도 withCredentials 값을 true로 설정해준다.\r\n\r\n```typescript\r\naxios.get(BASE_URL, {\r\n  withCredentials: true,\r\n  headers: {\r\n    \"Content-Type\": \"application/json\",\r\n  },\r\n});\r\n```\r\n\r\n## 문제상황\r\n\r\n보통 예제는 위와 같지만 나는 쿠키가 브라우저에 저장되지 않았다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd0P7QS%2Fbtr9SjoI9ke%2FIW9CJf8K5mS7kDuau67KDK%2Fimg.png)\r\n\r\n로직이 잘못된 것처럼 보이지도 않았고 별도의 에러 메시지도 없어서 문제 파악이 어려웠다.\r\n\r\n네트워크 탭을 통해 확인해 보니 response 헤더에 쿠키도 정상적으로 들어가 있었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDRJgW%2Fbtr9NnsBfTs%2FlGo4A2uw6n2UXPJJQVwbb1%2Fimg.png)\r\n\r\n그런데 노란 경고판이 눈에 띄었다.\r\n\r\n경고 문구는 다음과 같다.\r\n\r\n\u003e **this set-cookie header didn't specify a samesite attribute, was defaulted to sameSite=Lax, and was blocked because it came from a cross-site reponse which was not the response to a top-level navigation. this response is considered cross-site because the URL has a different scheme than the current site**\r\n\r\n요청 URL과 서버 URL의 체계가 달라서 차단됐다고 한다. 내 클라이언트는 http://localhost인데 서버가 https://localhost라서 그런 것 같았다.\r\n\r\nsameSite를 none으로 설정해주고 난 후에는 다음과 같은 경고 문구가 생겼다.\r\n\r\n\u003e **this attempt to set a cookie via a set-cookie header was blocked because it had the \"SameSite=None\" attribute but did not have the \"Secure\" attibute, which is required in order to user \"sameSite=None\"**\r\n\r\nsameSite=none을 적용하기 위해 필요한 Secure 속성이 없기 때문에 쿠키 설정이 차단되었단다.\r\n\r\n쿠키 생성 옵션을 마저 추가해 줬다.\r\n\r\n```typescript\r\nres.cookie(\"cookieName\", \"cookieValue\", {\r\n  maxAge: 300000,\r\n  // none, lax, strict 중 none은 쿠키가 항상 전송되도록 허용.\r\n  sameSite: \"none\", // HTTPS 프로토콜을 사용하고 secure 옵션이 설정된 경우에만 사용 가능\r\n  secure: true, // 쿠키가 HTTPS 프로토콜을 사용하는 경우에만 전송되도록 제한\r\n  httpOnly: true, // 쿠키에 접근할 수 있는 영역을 HTTP(S) 프로토콜로 제한하여,\r\n  // 브라우저의 자바스크립트 코드로부터 쿠키에 접근할 수 없게 함\r\n});\r\n```\r\n\r\nsecure 속성을 사용하기 위한 https 설정은 아래를 참고할 수 있다.\r\n\r\n### [Localhost 환경에서 https 적용하기](https://lee-yo-han.github.io/nestjs-localhost-https)\r\n\r\n그 결과 쿠키를 브라우저에서 잘 받는 것을 볼 수 있었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJwJs6%2Fbtr9SkupB08%2FbXf0Hf9swCaY3uL8cxMh7K%2Fimg.png)\r\n\r\n마지막으로 서버에서 쿠키를 받아 사용하는 방법이다.\r\n\r\n```typescript\r\nimport { Response, Request } from \"express\";\r\nimport { Controller, Get, Post, Res, Req } from \"@nestjs/common\";\r\n\r\n@Controller(\"myController\")\r\nexport class MyController {\r\n  @Get()\r\n  getCookie(@Res() res: Response) {\r\n    // express의 Response 객체를 불러와 사용해준다.\r\n    // 쿠키 설정\r\n    res.cookie(\"cookieName\", \"cookieValue\", { maxAge: 900000, httpOnly: true });\r\n    // maxAge : 유효기간을 밀리초 단위로 설정\r\n    // httpOnly : 클라이언트에서 쿠키에 접근할 수 없도록 설정\r\n\r\n    // HTTP 응답 반환\r\n    return res.send(\"쿠키가 설정되었습니다.\");\r\n  }\r\n\r\n  @Get()\r\n  postCookie(@Req() req: Request) {\r\n    // express의 Request 객체를 불러와 사용해준다.\r\n    // request 객체의 cookies를 통해 생성했던 쿠키의 이름을 통해 값을 가져온다.\r\n    req.cookies[\"cookieName\"];\r\n  }\r\n}\r\n```\r\n\r\n클라이언트 단에서는 withCredentials:true 옵션 설정 외에는 특별히 해줄 것이 없다.\r\n\r\n---\r\n\r\n참조 : https://docs.nestjs.com/techniques/cookies\r\n"},{"title":"nestjs use bcrypt","description":"Nestjs에서 bcrypt 사용하기","category":"nestjs","date":"2023-04-13","content":"\r\n## bycrypt란?\r\n\r\n비밀번호 등을 안전하게 암호화하여 저장하고 검증할 수 있도록 도와주는 라이브러리로, 랜덤한 salt를 생성하고 이를 비밀번호와 함께 암호화하여 저장한다. 이후 비밀번호 검증 시에도 같은 salt를 사용하여 입력받은 비밀번호를 암호화한 후, 저장된 암호화된 비밀번호와 비교하여 일치하는지 검증한다.\r\n\r\nbcrypt는 암호화 강도를 선택할 수 있는 기능을 제공한다. 기본값은 10으로, 숫자가 클수록 강도가 높아지며 암호화에 소요되는 시간도 늘어난다. 보안을 위해 기본값 이상의 값을 권장한다.\r\n\r\n## 사용법\r\n\r\n```bash\r\nyarn add bcrypt @types/bcrypt # nestjs는 타입스크립트가 기본이기 때문에 타입으로 설치\r\n```\r\n\r\n따로 module이나 main에 등록할 필요 없이 사용하고자 하는 파일에 불러오면 된다.\r\n\r\n```typescript\r\nimport * as bcrypt from 'bcrypt';\r\n\r\n// 암호화 후 저장\r\nconst someFN = async (userData:UserData) =\u003e {\r\n\tconst hashPassword = await bcrypt.hash(userData.password,10)\r\n\tconst saveData = {\r\n    \temail:userData.email,\r\n        password: hashPassword,\r\n    }\r\n    // 정보 저장 로직\r\n}\r\n\r\n// 저장된 데이터를 통해 비밀번호 확인\r\nconst checkFN = async (userData:UserData) =\u003e{\r\n\tconst hashedPassword = // 저장된 정보 불러오는 로직\r\n\r\n    // true or false\r\n    const match = await bcrypt.compare(userData.password,hashedPassword)\r\n    if(match) // 인증 후 로직\r\n}\r\n```\r\n\r\n---\r\n\r\n참조 : https://github.com/kelektiv/node.bcrypt.js#readme\r\n"},{"title":"nestjs custom repository","description":"Entityrepository()를 대신한 Repository 생성","category":"nestjs","date":"2023-03-04","content":"\r\n## 포스팅 시점 nestjs 버전 : 9.x.x\r\n\r\n새로운 토이 프로젝트를 만들면서 백엔드를 구축할 프레임워크로 nestjs를 이용하기로 마음먹었다.\r\n\r\n원래 사용하고 있던 javascript/typescript와 동일한 언어를 사용하기 때문에 백엔드 구축에 비교적 진입장벽이 낮다고 생각했기 때문에다.\r\n\r\n# nest 작동순서\r\n\r\nrequest -\u003e controller -\u003e service -\u003e controller -\u003e response 순으로 작동하나, DB와 관련된 일을 시키기 위해서는 repository를 생성해야한다고 한다. 즉,\r\n\r\nrequest -\u003e controller -\u003e service -\u003e repo\\* -\u003e service -\u003e controller -\u003e response\r\n로 한 단계가 추가된다. (Repostitory pattern)\r\n\r\n@EntityRepository를 통해 레포지토리를 설정해주는 방식이 많이 보였지만\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlkldE%2FbtrUQbTjKZA%2FA6hFzyRy8SsueBbUk8cTA1%2Fimg.png)\r\n\r\n현재 버전에서는 사용할 수 없어 다른 방법을 알아봤다.\r\n\r\n## 기본 설정\r\n\r\nconfig 설정\r\n\r\n```typescript\r\n// src/configs/typeorm.configs.ts\r\n\r\nexport const typeORMConfig: TypeOrmModuleOptions = {\r\n  // Database Type\r\n  type: \"postgres\", // 본인은 pg를 사용\r\n  host: \"localhost\",\r\n  port: 5432,\r\n  username: \"postgres\",\r\n  password: \"password\",\r\n  database: \"database\",\r\n  entities: [__dirname + \"/../**/*.entity.{js,ts}\"], // 해당 경로 + 엔티티이름.entity.{js.ts}로 된 엔티티를 이용\r\n  // autoLoadEntities: true, // 위와 다르게 entity들 알아서 찾아줌\r\n  synchronize: true, // @@@@@@@@ 배포할때 true 사용 시 데이터 삭제될 수 있음. production 단계에서는 필히 false로 해줄 것 권장 @@@@@@\r\n};\r\n```\r\n\r\nconfig 설정 후 root 모듈에 import\r\n\r\n```typescript\r\n// app.module.ts\r\n\r\nimport { Module } from \"@nestjs/common\";\r\nimport { AppController } from \"./app.controller\";\r\nimport { PostlistModule } from \"./postlist/postlist.module\";\r\nimport { typeORMConfig } from \"./configs/typeorm.configs\";\r\nimport { TypeOrmModule } from \"@nestjs/typeorm/dist\";\r\n\r\n@Module({\r\n  imports: [TypeOrmModule.forRoot(typeORMConfig), PostlistModule],\r\n  controllers: [AppController],\r\n  providers: [],\r\n})\r\nexport class AppModule {}\r\n```\r\n\r\nentity 생성\r\n\r\n```typescript\r\n// src/postlist/entities/postlist.entity.ts\r\n\r\nimport { BaseEntity, Column, PrimaryGeneratedColumn, Entity } from \"typeorm\";\r\n\r\n@Entity()\r\nexport class Postlist extends BaseEntity {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column()\r\n  title: string;\r\n\r\n  @Column()\r\n  content: string;\r\n\r\n  @Column()\r\n  nickname: string;\r\n\r\n  @Column()\r\n  imageUrl?: string;\r\n}\r\n```\r\n\r\n\u003e config 설정 시 entities에 이름을 ~~.entity.{js.ts} 로 설정해놓고, 정작 entity 파일 이름을 설정한 형식과 다르게 작성하면 [EntityMetadataNotFound] 에러를 띄우게 되기 때문에 설정한대로 이름을 지어줘야 한다.\r\n\r\n참조 : https://github.com/typeorm/typeorm/issues/1327\r\n\r\n## custumRepository 만들기\r\n\r\n본인은 src에 database 디렉토리를 만들어, 데코레이터와 모듈을 그 안에 넣어줬다.\r\n\r\n```typescript\r\n// src/database/typeorm-ex.decorator.ts\r\n\r\nimport { SetMetadata } from \"@nestjs/common\";\r\n\r\nexport const TYPEORM_EX_CUSTOM_REPOSITORY = \"TYPEORM_EX_CUSTOM_REPOSITORY\";\r\n\r\nexport function CustomRepository(entity: Function): ClassDecorator {\r\n  return SetMetadata(TYPEORM_EX_CUSTOM_REPOSITORY, entity);\r\n}\r\n\r\n// typeorm-ex.module.ts\r\n\r\nimport { DynamicModule, Provider } from \"@nestjs/common\";\r\nimport { getDataSourceToken } from \"@nestjs/typeorm\";\r\nimport { DataSource } from \"typeorm\";\r\nimport { TYPEORM_EX_CUSTOM_REPOSITORY } from \"./typeorm-ex.decorator\";\r\n\r\nexport class TypeOrmExModule {\r\n  public static forCustomRepository\u003cT extends new (...args: any[]) =\u003e any\u003e(\r\n    repositories: T[],\r\n  ): DynamicModule {\r\n    const providers: Provider[] = [];\r\n\r\n    for (const repository of repositories) {\r\n      const entity = Reflect.getMetadata(\r\n        TYPEORM_EX_CUSTOM_REPOSITORY,\r\n        repository,\r\n      );\r\n\r\n      if (!entity) {\r\n        continue;\r\n      }\r\n\r\n      providers.push({\r\n        inject: [getDataSourceToken()],\r\n        provide: repository,\r\n        useFactory: (dataSource: DataSource): typeof repository =\u003e {\r\n          const baseRepository = dataSource.getRepository\u003cany\u003e(entity);\r\n          return new repository(\r\n            baseRepository.target,\r\n            baseRepository.manager,\r\n            baseRepository.queryRunner,\r\n          );\r\n        },\r\n      });\r\n    }\r\n\r\n    return {\r\n      exports: providers,\r\n      module: TypeOrmExModule,\r\n      providers,\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n## 사용할 repository 생성\r\n\r\n```typescript\r\n// src/postlist/repository/postlist.repository.ts\r\n\r\nimport { CustomRepository } from \"src/database/typeorm-ex.decorator\";\r\nimport { Repository } from \"typeorm\";\r\nimport { Postlist } from \"../entities/postlist.entity\";\r\n\r\n@CustomRepository(Postlist)\r\nexport class PostlistRepository extends Repository\u003cPostlist\u003e {}\r\n```\r\n\r\n## module에 생성한 repository import\r\n\r\n```typescript\r\n// src/postlist/postlist.module.ts\r\n\r\nimport { Module } from \"@nestjs/common\";\r\nimport { PostlistController } from \"./postlist.controller\";\r\nimport { PostlistService } from \"./postlist.service\";\r\nimport { PostlistRepository } from \"./repository/postlist.repository\";\r\nimport { TypeOrmExModule } from \"src/database/typeorm-ex.module\";\r\n\r\n@Module({\r\n  imports: [TypeOrmExModule.forCustomRepository([PostlistRepository])],\r\n  controllers: [PostlistController],\r\n  providers: [PostlistService],\r\n})\r\nexport class PostlistModule {}\r\n```\r\n\r\n### Module에 import 후 service 비즈니스 로직에만 repository를 넣어주면 된다.\r\n\r\n```typescript\r\n// src/postlist/postlist.service.ts\r\n\r\nimport { Injectable, NotFoundException } from \"@nestjs/common\";\r\nimport { UpdatePostDto } from \"./dto/update-postlist.dto\";\r\n\r\nimport { PostlistRepository } from \"./repository/postlist.repository\";\r\nimport { Postlist } from \"./entities/postlist.entity\";\r\nimport { CreatePostDto } from \"./dto/create-postlist.dto\";\r\n\r\n@Injectable()\r\nexport class PostlistService {\r\n  constructor(private readonly postlistRepository: PostlistRepository) {}\r\n\r\n  async getAllPost(): Promise\u003cPostlist[]\u003e {\r\n    const found = await this.postlistRepository.find();\r\n    return found;\r\n  }\r\n\r\n  async getPostById(id: number): Promise\u003cPostlist\u003e {\r\n    const found = await this.postlistRepository.findOne({ where: { id: id } });\r\n    if (!found) {\r\n      throw new NotFoundException(`Cannot find post with id ${id}`);\r\n    }\r\n    return found;\r\n  }\r\n}\r\n\r\n// src/postlist/postlist.controller.ts\r\n\r\nimport { Body, Controller, Get, Param, Patch, Post } from \"@nestjs/common\";\r\nimport { CreatePostDto } from \"./dto/create-postlist.dto\";\r\nimport { PostlistService } from \"./postlist.service\";\r\nimport { UpdatePostDto } from \"./dto/update-postlist.dto\";\r\nimport { Delete } from \"@nestjs/common/decorators\";\r\nimport { Postlist } from \"./entities/postlist.entity\";\r\n\r\n@Controller(\"postlist\")\r\nexport class PostlistController {\r\n  constructor(readonly postlistService: PostlistService) {}\r\n\r\n  @Post()\r\n  createOne(@Body() createPostDto: CreatePostDto): Promise\u003cPostlist\u003e {\r\n    return this.postlistService.createPost(createPostDto);\r\n  }\r\n\r\n  @Get()\r\n  getAll(): Promise\u003cPostlist[]\u003e {\r\n    return this.postlistService.getAllPost();\r\n  }\r\n\r\n  @Get(\":id\")\r\n  getOne(@Param(\"id\") id: number): Promise\u003cPostlist\u003e {\r\n    return this.postlistService.getPostById(id);\r\n  }\r\n\r\n  @Patch(\":id\")\r\n  updateOne(\r\n    @Param(\"id\") id: number,\r\n    @Body() updateData: UpdatePostDto,\r\n  ): Promise\u003cPostlist\u003e {\r\n    return this.postlistService.updatePost(id, updateData);\r\n  }\r\n\r\n  @Delete(\":id\")\r\n  deleteOne(@Param(\"id\") id: number): Promise\u003cvoid\u003e {\r\n    return this.postlistService.deletePost(id);\r\n  }\r\n}\r\n```\r\n\r\n필요한 로직을 설정한 후 postman을 작동시켜주면 정상적으로 실행되는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbMxspb%2FbtrUIZG6vWP%2F0dVetFuaUfkfuI9EXCKeN0%2Fimg.png)\r\n\r\nnextjs와 동시에 작업하기 위해 nestjs 포트를 3001로 설정했지만, 보통은 nest 설치 시 app에 3000으로 설정된다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcOfHG5%2FbtrUOQBYHjX%2FoGOqOJtiF2KbPiyKu9JCdK%2Fimg.png)\r\n\r\nDB는 postgreSQL을 이용했다.\r\n정상적으로 테이블에 있는 데이터가 추출되는 것이 잘 확인된다.\r\n\r\n### 참고 :\r\n\r\nhttps://orkhan.gitbook.io/typeorm/readme_ko\r\n\r\nhttps://docs.nestjs.com/techniques/database\r\n"}]},"__N_SSG":true},"page":"/nestjs","query":{},"buildId":"gvRFHA6ylUyeyOUUknmR4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>