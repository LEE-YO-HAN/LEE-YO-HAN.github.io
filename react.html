<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Rain Sugar BangBang Front-End</title><meta name="description" content="developer&#x27;s blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta http-equiv="subject" content="react"/><meta property="og:title" content="Rain Sugar BangBang"/><meta property="og:description" content="welcome to developer&#x27;s blog"/><meta property="og:image" content="[object Module]"/><meta name="naver-site-verification" content="af9c8049662a7c6c85ea946e9eb561086e70062c"/><meta name="google-site-verification" content="Zgp7rA3RAdcRnhPPsGLK-t4KVTO86AejlDIQQIGpvLg"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4077287316160146" crossorigin="anonymous"></script><link rel="icon" href="/favicon.ico"/><link rel="preload" as="image" href="/_next/static/media/REACT.a98a0657.png"/><meta name="next-head-count" content="13"/><link rel="preload" href="/_next/static/css/b4f97ab2e5eec96e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b4f97ab2e5eec96e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-f164db4954bac6ec.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-b0c8bcfd40968c52.js" defer=""></script><script src="/_next/static/chunks/pages/_app-882c6320043e5869.js" defer=""></script><script src="/_next/static/chunks/879-e2932e387b3cdda8.js" defer=""></script><script src="/_next/static/chunks/pages/react-51bfda10934e06fc.js" defer=""></script><script src="/_next/static/f3nUh6NMxmxPn7-70ZrQs/_buildManifest.js" defer=""></script><script src="/_next/static/f3nUh6NMxmxPn7-70ZrQs/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="sc-e301a42a-0 hHncwW"><h1><a href="/">Rain Sugar BangBang</a></h1></header><div class="sc-ba37e1ab-0 jsuXVA"><section class="sc-ba37e1ab-1 flRwaC"><aside class="sc-66bc730f-0 khiCBg"><div class="sc-66bc730f-1 IEUha"><img alt="profile" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" src="https://avatars.githubusercontent.com/u/85297720?v=4"/><p>Hanbbi</p></div><div class="sc-66bc730f-2 irHvHG"><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0 0 68.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"></path></svg><span>yhl0078@gmail.com</span></a><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>Github</span></a></div></aside><article class="sc-ba37e1ab-2 kOvCyN"><div class="sc-17644e81-0 klFkYG"><p style="font-weight:bold;width:660px">전체 글 (<!-- -->12<!-- -->)</p><ul class="sc-17644e81-1 dHJEYG"><a href="/react-memo"><li class="sc-17644e81-2 gwPgUV"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/REACT.a98a0657.png"/><div class="sc-17644e81-3 ebvFqS"><p>React.memo() 를 통한 컴포넌트 최적화</p><span>2023. 03. 16</span></div></li></a><a href="/react-usecallback"><li class="sc-17644e81-2 gwPgUV"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/REACT.a98a0657.png"/><div class="sc-17644e81-3 ebvFqS"><p>useCallback을 이용한 컴포넌트 최적화하기</p><span>2023. 03. 16</span></div></li></a><a href="/react-usememo"><li class="sc-17644e81-2 gwPgUV"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/REACT.a98a0657.png"/><div class="sc-17644e81-3 ebvFqS"><p>useMemo를 이용한 컴포넌트 최적화하기</p><span>2023. 03. 16</span></div></li></a><a href="/react-context-api"><li class="sc-17644e81-2 gwPgUV"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/REACT.a98a0657.png"/><div class="sc-17644e81-3 ebvFqS"><p>ContextAPI 사용하기</p><span>2023. 03. 15</span></div></li></a><a href="/react-datepicker"><li class="sc-17644e81-2 gwPgUV"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/REACT.a98a0657.png"/><div class="sc-17644e81-3 ebvFqS"><p>React datepicker 사용하기</p><span>2023. 03. 03</span></div></li></a><a href="/react-media-query"><li class="sc-17644e81-2 gwPgUV"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/_next/static/media/REACT.a98a0657.png"/><div class="sc-17644e81-3 ebvFqS"><p>React mediaQuery 사용법</p><span>2023. 03. 03</span></div></li></a></ul><ul class="sc-1c9fae35-0 hLQkxC"><li style="background-color:gray"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z"></path></svg></li><li id="1" class="activePage">1</li><li id="2" class="page">2</li><li><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z"></path></svg></li></ul></div></article><aside class="sc-a8eb4d0-0 hPXHcC"><nav class="sc-ca204857-0 eNWXGi"><ul class="sc-ca204857-1 Jmuhj"><li>Category</li><li class="sc-ca204857-2 SRJNA"><a href="/github">Simple Memo</a></li><li class="sc-ca204857-2 SRJNA"><a href="/html">HTML</a></li><li class="sc-ca204857-2 SRJNA"><a href="/css">CSS</a></li><li class="sc-ca204857-2 SRJNA"><a href="/javascript">JavaScript</a></li><li class="sc-ca204857-2 SRJNA"><a href="/typescript">TypeScript</a></li><li class="sc-ca204857-2 SRJNA"><a href="/redux">Redux</a></li><li style="color:white;font-weight:bold" class="sc-ca204857-2 SRJNA"><a href="/react">React</a></li><li class="sc-ca204857-2 SRJNA"><a href="/nextjs">Nextjs</a></li><li class="sc-ca204857-2 SRJNA"><a href="/nestjs">Nestjs</a></li></ul></nav></aside></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"react memo","description":"React.memo() 를 통한 컴포넌트 최적화","category":"react","date":"2023-03-16","content":"\r\n\u003e 유저에게 UI를 빠르게 제공하기 위해서는 컴포넌트의 렌더링을 최소화해 성능을 향상시킬 필요가 있다. 이를 위해 React.memo()에 대한 간단한 사용법을 기록해본다.\r\n\r\n# 1. React.memo()\r\n\r\n컴포넌트가 React.memo()로 래핑될 때, React는 컴포넌트를 렌더링하고 결과를 Memoizing한다.\r\n\r\n그리고 다음 렌더링이 일어날 때 props가 값다면, React는 Memoizing된 내용을 재사용한다.\r\n\r\n## 사용법\r\n\r\n```javascript\r\nimport React from \"react\";\r\n\r\nexport const MemoTest = ({ someProps }) =\u003e {\r\n  console.log(\"Memo test, props 바뀔때만 콘솔 작동\");\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cp\u003eMemoTest 컴포넌트\u003c/p\u003e\r\n      \u003cp\u003eprops가 바뀔때만 렌더링\u003c/p\u003e\r\n      \u003cspan\u003ecount와 연동된 props: {someProps}\u003c/span\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 다른 컴포넌트에서 불러올 때, 해당 컴포넌트를 import 해주면 된다.\r\nexport const MemoTestComponent = React.memo(MemoTest);\r\n```\r\n\r\n## 사용 예시\r\n\r\n```javascript\r\nexport const TestApp = () =\u003e {\r\n  const values = useContextValue();\r\n  const update = useContextUpdate();\r\n  const [count, setCount] = useState(0);\r\n  console.log(\"최상위 컴포넌트 : 렌더링 될때마다 콘솔 작동\");\r\n\r\n  const contextHandler = () =\u003e {\r\n    values === \"someData\" ? update(\"dataSome\") : update(\"someData\");\r\n  };\r\n\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cNormalComponent /\u003e\r\n      \u003cMemoTestComponent someProps={count} /\u003e\r\n      \u003cbutton\r\n        onClick={() =\u003e {\r\n          setCount(pre =\u003e pre + 1);\r\n        }}\r\n      \u003e\r\n        +count버튼\r\n      \u003c/button\u003e\r\n      \u003cbutton\r\n        onClick={() =\u003e {\r\n          setCount(pre =\u003e pre - 1);\r\n        }}\r\n      \u003e\r\n        -count버튼\r\n      \u003c/button\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003econtext value\u003c/p\u003e\r\n        \u003cspan\u003evalue : {values}\u003c/span\u003e\r\n        \u003cbutton onClick={contextHandler}\u003econtext 변경 버튼\u003c/button\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVQkSV%2Fbtr37vCBXzm%2FVXiqfYdD4H2FTcw3tGVFzk%2Fimg.png)\r\n\r\n위 이미지는 TestApp 코드의 초기 화면이다.\r\n\r\n모든 컴포넌트가 첫 렌더링을 거쳐 각각 콘솔을 찍어내고 있다.\r\n\r\n### TestApp의 count state는 MemoTest 컴포넌트에 props로 전달해주고 있기 때문에 React.memo()의 효과는 사용되지 않고, 일반 컴포넌트와 마찬가지로 TestApp count state가 변경될 때마다 렌더링되는 것을 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/Hl6oT/btr4gSJ05tT/kipvw3VkehYfnxf2Pbq780/img.gif)\r\n\r\n### 하지만 contextAPI처럼 MemoTest의 props와 연관되지 않은 다른 방식을 통해 통해 리렌더링을 발생시키는 경우라면, memoTest 컴포넌트의 props가 변경되지 않기 때문에 MemoTest는 렌더링을 발생시키지 않는다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/cmaheq/btr36GRW8J1/uhzNP5d6ymqDxVDGFK4Ay1/img.gif)\r\n\r\n\u003e contextAPI의 기본 사용법 : https://lee-yo-han.github.io/react/react-context-api\r\n\r\n---\r\n\r\n## 1-1 - props 동등 비교 커스터마이징\r\n\r\nReact.memo()는 props 혹은 props의 객체를 비교할 때 얕은 비교를 하기 때문에, 비교 방식을 수정하고 싶다면 React.memo() 두 번째 매개변수로 비교함수를 만들어 수동으로 연산 후 넘겨주면 된다.\r\n\r\n```javascript\r\nimport React from \"react\";\r\n\r\nexport const MemoTest = ({ someProps }) =\u003e {\r\n  console.log(\"Memo test, props 바뀔때만 콘솔 작동\");\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cp\u003eMemoTest 컴포넌트\u003c/p\u003e\r\n      \u003cp\u003eprops가 바뀔때만 렌더링\u003c/p\u003e\r\n      \u003cspan\u003ecount와 연동된 props: {someProps}\u003c/span\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\nconst propsAreEqual = (prev, next) =\u003e {\r\n  return (\r\n    prev.someProps === next.someProps\r\n    // 다른 props들이 있는 경우 \u0026\u0026을 통해 연산 추가\r\n  );\r\n};\r\n\r\nexport const MemoTestComponent = React.memo(MemoTest, propsAreEqual);\r\n```\r\n\r\n# 2. React.memo()는 언제 사용해야 하는가?\r\n\r\n### - 함수형 컴포넌트가 같은 props로 자주 렌더링 될거라 예상될 경우\r\n\r\nprops가 변경되지 않는 경우에도 상위 컴포넌트의 지속적인 렌더링에 의해 하위 컴포넌트의 불필요한 렌더링이 예상되는 경우라면 React.memo()를 통해 오직 props의 변화에만 반응시켜주는 것이 효율적이다.\r\n\r\n### - 무겁고 비용이 큰 연산이 있는 경우\r\n\r\n한 번 렌더링 될 때 큰 연산이 발생한다고 했을때 불필요한 렌더링이 일어난 경우 연산에 사용되는 비용이 낭비될 수 있기 때문에 이러한 경우 또한 React.memo()를 통한 memoization이 적절하다고 볼 수 있다.\r\n\r\n# 3. React.memo()를 언제 사용하지 말아야 하는가?\r\n\r\n### - 위에 언급한 상황과 맞지 않는 경우 React.memo()를 사용할 필요가 없을 가능성이 높다.\r\n\r\n경험적으로 ㅅ어능적인 이점을 얻지 못한다면 memoization을 사용하지 않는 것이 좋다. 성능 관련 변경이 잘못 적용된다면 성능이 오히려 악화될 수 있다.\r\n\r\n### - 기술적으로는 가능하지만 클래스 기반의 컴포넌트를 React.memo()로 래핑하는 것은 적절하지 않다.\r\n\r\n클래스 기반의 컴포넌트에서 memoization이 필요하다면, pureComponent를 확장하여 사용하거나, shouldComponentUpdate() 메서드를 구현하는 것이 적절하다.\r\n\r\n### - props가 자주 바뀌는 경우\r\n\r\nprops가 자주 바뀌는 경우도 React.memo()로 래핑하더라도 이전 props와 다음 props를 비교 함수를 통해 비교할때 거의 false를 반환할 것이기 때문에 props가 자주 바뀌는 경우도 React.memo()의 사용이 적절하지 않다.\r\n\r\n## 결론\r\n\r\n\u003e React.memo는 memoization의 장점을 얻게 해주는 좋은 도구이지만, 렌더링 방지를 위해 memoization에만 의존하면 안된다.\r\n\r\n---\r\n\r\n## 참조\r\n\r\nhttps://dmitripavlutin.com/use-react-memo-wisely/\r\n\r\nhttps://ui.toast.com/weekly-pick/ko_20190731\r\n"},{"title":"react usecallback","description":"useCallback을 이용한 컴포넌트 최적화하기","category":"react","date":"2023-03-16","content":"\r\n# useCallback이란?\r\n\r\n\u003e 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용하는 함수 메모이제이션용 React hook이다.\r\n\r\n```javascript\r\nconst memoFn = useCallback(() =\u003e {}, [dep]);\r\n```\r\n\r\n첫번째 인자의 함수를 두번째 인자의 종속성 배열 내의 값이 변경될 때까지 저장하여 재사용할 수 있도록 해준다.\r\n\r\njavascript에서 함수(function () {} or () =\u003e {})는 객체 리터럴( {...} )이 항상 새 객체를 생성하는 것과 유사하게 항상 다른 함수를 생성한다. 그렇다면 함수를 props 로 내려준다고 하면 하위 컴포넌트는 props가 변경되었다고 인식하게 된다.\r\n\r\n그렇게되면 React.memo를 이용한 최적화가 원하는대로 작동하지 않을 수 있기 때문에 이러한 점을 useCallback이 메꿔줄 수 있게 된다.\r\n\r\n\u003e 종속성 배열이 없는 경우 매번 새 함수를 반환하기 때문에 항상 dependencises 배열을 포함해줘야 한다. (특정 상황에서 빈 배열 [] 은 있을 수 있지만, 배열 자체가 없으면 의미가 없어진다.)\r\n\r\n## 사용예\r\n\r\n```javascript\r\nconst add = useCallback(() =\u003e x + y, [x, y]);\r\n```\r\n\r\n# useCallback과 React.memo를 통한 최적화\r\n\r\n```javascript\r\n// 최상단 (1번) 컴포넌트\r\nimport { useState } from \"react\";\r\nimport { UseCallbackChildren } from \"./UseCallbackChildren\";\r\n\r\nexport const UseCallbackTest = () =\u003e {\r\n  const [isDark, setIsDark] = useState(false);\r\n  return (\r\n    \u003c\u003e\r\n      \u003clabel\u003e\r\n        \u003cinput\r\n          type=\"checkbox\"\r\n          checked={isDark}\r\n          onChange={e =\u003e setIsDark(e.target.checked)}\r\n        /\u003e\r\n        Dark mode\r\n      \u003c/label\u003e\r\n      \u003chr /\u003e\r\n      \u003cUseCallbackChildren\r\n        productId={123}\r\n        referrer=\"wizard_of_oz\"\r\n        theme={isDark ? \"dark\" : \"light\"}\r\n      /\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n\r\n// 중간 (2번) 컴포넌트\r\nimport React, { useCallback } from \"react\";\r\nimport { CallbackForm } from \"./UseCallbackForn\";\r\n\r\nexport const UseCallbackChildren = ({ referrer, productId, theme }) =\u003e {\r\n  const post = (url, data) =\u003e {\r\n    console.log(\"POST /\" + url);\r\n    console.log(data);\r\n  };\r\n\r\n  const handleSubmit = useCallback(\r\n    orderDetails =\u003e {\r\n      post(\"/product/\" + productId + \"/buy\", {\r\n        referrer,\r\n        orderDetails,\r\n      });\r\n    },\r\n    [productId, referrer],\r\n  );\r\n\r\n  return (\r\n    \u003cdiv\r\n      style={\r\n        theme === \"dark\" ? { backgroundColor: \"black\", color: \"white\" } : {}\r\n      }\r\n    \u003e\r\n      \u003cCallbackForm onSubmit={handleSubmit} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 하위 (3번) 컴포넌트\r\nimport React, { useState } from \"react\";\r\n\r\nexport const UseCallbackForm = ({ onSubmit }) =\u003e {\r\n  const [count, setCount] = useState(1);\r\n\r\n  console.log(\"강제로 느리게\");\r\n  let startTime = performance.now();\r\n  while (performance.now() - startTime \u003c 500) {\r\n    // Do nothing for 500 ms to emulate extremely slow code\r\n  }\r\n\r\n  const handleSubmit = e =\u003e {\r\n    e.preventDefault();\r\n    const formData = new FormData(e.target);\r\n    const orderDetails = {\r\n      ...Object.fromEntries(formData),\r\n      count,\r\n    };\r\n    onSubmit(orderDetails);\r\n  };\r\n\r\n  return (\r\n    \u003cform\r\n      onSubmit={handleSubmit}\r\n      style={{ display: \"flex\", flexDirection: \"column\", width: \"200px\" }}\r\n    \u003e\r\n      \u003cp\u003e\r\n        \u003cb\u003e\r\n          Note: \u003ccode\u003eShippingForm\u003c/code\u003e is artificially slowed down!\r\n        \u003c/b\u003e\r\n      \u003c/p\u003e\r\n      \u003clabel\u003e\r\n        Number of items:\r\n        \u003cbutton type=\"button\" onClick={() =\u003e setCount(count - 1)}\u003e\r\n          -\r\n        \u003c/button\u003e\r\n        {count}\r\n        \u003cbutton type=\"button\" onClick={() =\u003e setCount(count + 1)}\u003e\r\n          +\r\n        \u003c/button\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        Street:\r\n        \u003cinput name=\"street\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        City:\r\n        \u003cinput name=\"city\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        Postal code:\r\n        \u003cinput name=\"zipCode\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n};\r\n\r\nexport const CallbackForm = React.memo(UseCallbackForm);\r\n```\r\n\r\n위 코드를 보면, 최상단(1)에 있는 다크모드는 중간(2) 컴포넌트까지만 전달해주고, 중간(2) 컴포넌트는 하위(3) 컴포넌트에 useCallback 함수만 전달해주고 있다.\r\n\r\nuseCallback은 함수를 캐시해 재사용할 수 있도록 도와주기 때문에 종속성이 변하지 않으면 계속 재사용할 수 있다. 즉, 동일한 props로써 함수를 하위(3) 컴포넌트에 내려주고 있기 때문에 하위 컴포넌트의 렌더링에 영향이 없다.\r\n\r\n이 상태로 코드를 작동시키면 하위(3) 컴포넌트에 있는 count를 동작할때마다 느려지겠지만, 다크모드와 submit 이벤트에는 영향을 주지 않는다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/bEYsKw/btr4gSLc8BG/hJKpnBKbFziku3fjI6hphK/img.gif)\r\n\r\n만약 하위(3) 컴포넌트의 React.memo()를 없애게 되면 submit 이벤트에는 영향이 없지만, 최상위(1) 컴포넌트의 다크모드 state 변경에 의해 하위(3) 컴포넌트의 렌더링이 일어나게 되어 다크모드와 count의 동작이 느려지는걸 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/mfxA0/btr4iTijPZD/XNzKmFrScoUZ6qSyiCMV2K/img.gif)\r\n\r\n자세히 보면 콘솔이 먼저 찍히고 0.5초정도 뒤에 동작하는 것을 볼 수 있다.\r\n\r\n# useMemo와의 차이점\r\n\r\n\u003e useMemo는 함수의 호출 결과를 캐시하고, useCallback은 함수 자체는 캐시한다. 그러므로 useCallback은 useMemo와 달리 제공한 함수를 호출하지 않는다. 대신 사용자가 제공한 함수를 캐시하기 때문에 불필요한 렌더링 없이 함수를 전달할 수 있다.\r\n\r\n## useMemo와 useCallback의 동시 사용\r\n\r\n```javascript\r\nfunction useCallback(fn, dependencies) {\r\n  return useMemo(() =\u003e fn, dependencies);\r\n}\r\n```\r\n\r\n## useCallback이 유용한 경우\r\n\r\n- useCallback을 통해 props로 하위 컴포넌트에 넘겨줄때\r\n- useEffect 등 다른 hook의 종속성으로 이용할때\r\n- 종속성 변화가 적고 재사용이 용이할때\r\n\r\n## useCallback 남용 시 문제점\r\n\r\n\u003e 모든 함수를 useCallback으로 감싸게 되면 컴포넌트가 리렌더 될 때마다 모든 함수가 다시 재생성될 필요가 있는지 검사하는 연산이 수행된다. 따라서 보통은 특정 함수가 props로 전달되어 불필요한 컴포넌트 리렌더를 유발할 때에만 적용하는 것이 좋다.\r\n\r\n### memo, useMemo, useCallback 등 어떤 Memoization이나 부적절하게 사용할 경우 오히려 성능이 떨어질 수 있기 때문에 상황에 맞게 적절하게 사용하는 것이 좋은 것 같다.\r\n\r\n---\r\n\r\n참조: https://beta.reactjs.org/reference/react/useCallback\r\n"},{"title":"react usememo","description":"useMemo를 이용한 컴포넌트 최적화하기","category":"react","date":"2023-03-16","content":"\r\n# useMemo란?\r\n\r\n\u003e useMemo는 React.memo(), useCallback과 같이 컴포넌트를 최적화하기 위한 훅 중 하나이다.\r\n\r\n# useMemo를 사용하는 이유\r\n\r\nReact의 컴포넌트는 부모 컴포넌트가 렌더링되거나, 자신의 state변경, 상위 컴포넌트에서 내려받는 props가 변경될 때마다 다시 렌더링된다. 그런데 내려받는 props나 state가 여러 가지일때 한 개 props의 변경으로 모든 값이 다시 계산되는 경우 불필요한 비용이 누적되게 된다.\r\n\r\nuseMemo는 이러한 현상을 효율적으로 전환하기 위한 hook이다.\r\n\r\n## useMemo를 적용하기 전\r\n\r\n```javascript\r\n// 상위 컴포넌트\r\nimport { useState } from \"react\";\r\nimport { UseMemoChildren } from \"./UseMemoChildren\";\r\n\r\nexport const UseMemoTest = () =\u003e {\r\n  const [number, setNumber] = useState(0);\r\n  const [text, setText] = useState(\"\");\r\n\r\n  const changeNumber = e =\u003e {\r\n    setNumber(e.target.value);\r\n  };\r\n  const changeText = e =\u003e {\r\n    setText(e.target.value);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eUseMemoText\u003c/p\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003enumber\u003c/p\u003e\r\n        \u003cinput type=\"number\" onChange={changeNumber} value={number} /\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003etext\u003c/p\u003e\r\n        \u003cinput type=\"text\" onChange={changeText} value={text} /\u003e\r\n      \u003c/div\u003e\r\n      \u003cUseMemoChildren number={number} text={text} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 하위 컴포넌트\r\nexport const UseMemoChildren = ({ number, text }) =\u003e {\r\n  const getNumber = number =\u003e {\r\n    console.log(\"숫자 변경\");\r\n    return number;\r\n  };\r\n\r\n  const getText = text =\u003e {\r\n    console.log(\"글자 변경\");\r\n    return text;\r\n  };\r\n\r\n  const showNumber = getNumber(number);\r\n\r\n  const showText = getText(text);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eMemo Child Component\u003c/p\u003e\r\n      \u003cp\u003enumber: {showNumber}\u003c/p\u003e\r\n      \u003cp\u003etext: {showText}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n상위 컴포넌트는 각 input 값이 변경될 때마다 그 값을 저장해 하위 컴포넌트로 내려준다.\r\n\r\n하위 컴포넌트는 내려받은 props를 통해 화면에 노출시켜줄 값을 return해주는 역할을 한다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/9hqzj/btr4hQeyTmU/PzYhcCiwuZq08zOkhBqeWk/img.gif)\r\n\r\n이 상태에서 input을 업데이트하면 숫자를 바꾸든 텍스트를 바꾸든 getNumber 함수와 getText 함수 둘 다 다시 연산되는 것을 볼 수 있다.\r\n\r\n이런 경우 변경된 props에 대해서만 다시 연산될 수 있도록 useMemo를 적용해볼 수 있다.\r\n\r\n## useMemo 사용법\r\n\r\n```javascript\r\nconst cachedValue = useMemo(calculateValue, dependencies);\r\n```\r\n\r\n### 적용 예시\r\n\r\n```javascript\r\n// 하위 컴포넌트\r\n\r\nimport { useMemo } from \"react\";\r\n\r\nexport const UseMemoChildren = ({ number, text }) =\u003e {\r\n  //   console.log(\"useMemoChildren start\");\r\n  const getNumber = number =\u003e {\r\n    console.log(\"숫자 변경\");\r\n    return number;\r\n  };\r\n\r\n  const getText = text =\u003e {\r\n    console.log(\"글자 변경\");\r\n    return text;\r\n  };\r\n\r\n  const showNumber = useMemo(() =\u003e {\r\n    return getNumber(number);\r\n  }, [number]);\r\n\r\n  const showText = useMemo(() =\u003e {\r\n    return getText(text);\r\n  }, [text]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eMemo Child Component\u003c/p\u003e\r\n      \u003cp\u003enumber: {showNumber}\u003c/p\u003e\r\n      \u003cp\u003etext: {showText}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 useMemo를 적용하고 나면 다음과 같이 useMemo 적용 이후 변경된 props에 대한 연산만 처리해주는 것을 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/4Vcyh/btr4hPz1xwm/0zNRNCdyJKwpsWk2LU73KK/img.gif)\r\n\r\n\u003e useMemo 마지막의 dependencies [ ] 배열은 필수적으로 어떤 값을 변경에 반응할 것인지 포함시켜줘야 한다.\r\n\r\n# 연산 비용이 비싸다는 기준은?\r\n\r\nReact 공식 사이트에서 권장하는 useMemo 적용 기준은 연산에 소요된 시간이 1ms 이상일 경우로 안내하고 있다.\r\n\r\nconsole.time/timeEnd 등을 통해 useMemo를 적용하고자 하는 함수의 총 연산시간을 도출해볼 수 있다.\r\n\r\n```javascript\r\nconst getText = text =\u003e {\r\n  console.time(\"memo\");\r\n  console.log(\"글자 변경\");\r\n  console.timeEnd(\"memo\");\r\n  return text;\r\n};\r\n```\r\n\r\n위와 같이 코드 작성 후 text를 변경해보면 다음과 같은 콘솔을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8mGtS%2Fbtr4iU19jHE%2FH0huW2SytbAtalR3urepr0%2Fimg.png)\r\n\r\n\u003e 입력하는 계산이 눈에 띄게 느리고, 종속성이 거의 변경되지 않는 경우에는 useMemo를 이용한 최적화가 적합하지만, 컴포넌트 구조 변경과 상태 관리의 최소화, state를 업데이트하는 Effect의 불필요한 종속성을 제거하거나 특정 함수들을 별도로 관리하는 방법이 useMemo보다 적합할 수 있다.\r\n\r\n\u003e 실제로 React의 성능 문제 대부분은 Effect에서 발생하는 업데이트 체인으로 인해 발생한다고 한다.\r\n\r\n---\r\n\r\n참조 : https://beta.reactjs.org/reference/react/useMemo\r\n"},{"title":"react context api","description":"ContextAPI 사용하기","category":"react","date":"2023-03-15","content":"\r\n# ContextAPI\r\n\r\n\u003e 간단한 데이터의 변화를 props drilling 없이 전역적으로 관리해주기 위해 ContextAPI를 사용해볼 수 있다.\r\n\r\n## 사용법\r\n\r\n## 1. context component 생성\r\n\r\n```javascript\r\n// context.jsx\r\nimport { createContext, useContext, useState } from \"react\";\r\n\r\n// context 생성\r\nconst AnyContextValue = createContext();\r\nconst AnyContextUpdate = createContext();\r\n\r\n// useContext 생성\r\nexport const useContextValue = () =\u003e {\r\n  const context = useContext(AnyContextValue);\r\n  return context;\r\n};\r\nexport const useContextUpdate = () =\u003e {\r\n  const update = useContext(AnyContextUpdate);\r\n  return update;\r\n};\r\n\r\n// context Component 생성\r\n// children props를 Contextname.provider로 감싸준다.\r\nexport const SomeContext = ({ children }) =\u003e {\r\n  const [someData, setSomeData] = useState(\"someData\");\r\n  return (\r\n    \u003cAnyContextValue.Provider value={someData}\u003e\r\n      \u003cAnyContextUpdate.Provider value={setSomeData}\u003e\r\n        {children}\r\n      \u003c/AnyContextUpdate.Provider\u003e\r\n    \u003c/AnyContextValue.Provider\u003e\r\n  );\r\n};\r\n```\r\n\r\n## 2. context import\r\n\r\n```javascript\r\nimport { TestApp } from \"./components/blogtest/TestApp\";\r\nimport { SomeContext } from \"./components/context/RenderingContext\";\r\n\r\n// import된 Context를 적용하고자 하는 컴포넌트들의 최상위에 감싸준다.\r\nfunction App() {\r\n  return (\r\n    \u003cSomeContext\u003e\r\n      \u003cChildrenComponent /\u003e\r\n    \u003c/SomeContext\u003e\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n## 3. context 사용\r\n\r\n```javascript\r\nimport { useState } from \"react\";\r\n// 생성한 useContext import\r\nimport { useContextUpdate, useContextValue } from \"../context/RenderingContext\";\r\n\r\nexport const ChildrenComponent = () =\u003e {\r\n  const values = useContextValue();\r\n  const update = useContextUpdate();\r\n\r\n  const contextHandler = () =\u003e {\r\n    values === \"someData\" ? update(\"dataSome\") : update(\"someData\");\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003econtext value\u003c/p\u003e\r\n      \u003cspan\u003evalue : {values}\u003c/span\u003e\r\n      \u003cbutton onClick={contextHandler}\u003econtext 변경 버튼\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 설정이 완료된 후 정상적으로 contextAPI를 사용할 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/d0hnZa/btr35w9FvGX/zDcTOjtXxg23vMKk6LxaM0/img.gif)\r\n\r\n\u003e contextAPI는 간단하게 상태를 관리해줄 수 있지만, provider를 전역으로 감쌌을 때 컴포넌트들이 전반적으로 렌더링이 일어날 수 있기 때문에 상황과 구조에 맞게 적절하게 사용해주는 것이 좋다.\r\n\r\n---\r\n\r\n## 참고 : typescript에서의 contextAPI 사용\r\n\r\n### TypeScript에서는 context 초기값 등의 설정이 필요하다.\r\n\r\n```typescript\r\n// context component\r\n\r\nimport { createContext, useContext, useState } from \"react\";\r\nimport { PostType } from \"@/types/pages\";\r\nimport { ProviderProps, ContextType } from \".\";\r\n\r\n// context 초기화\r\nconst initialContext = {\r\n  posts: [],\r\n  setPosts: () =\u003e {},\r\n};\r\n\r\n// context 생성\r\nconst PostContextValue = createContext\u003cPostType[]\u003e(initialContext.posts);\r\nconst PostContextUpdate = createContext\u003cContextType\u003e(initialContext.setPosts);\r\n\r\n// useContext 생성\r\nexport const useMdContextValue = () =\u003e {\r\n  const context = useContext(PostContextValue);\r\n  return context;\r\n};\r\nexport const useMdContextUpdate = () =\u003e {\r\n  const update = useContext(PostContextUpdate);\r\n  return update;\r\n};\r\n\r\n// context component 생성\r\nexport const MdContext = ({ children }: ProviderProps) =\u003e {\r\n  const [posts, setPosts] = useState\u003cPostType[]\u003e([]);\r\n\r\n  return (\r\n    \u003cPostContextValue.Provider value={posts}\u003e\r\n      \u003cPostContextUpdate.Provider value={setPosts}\u003e\r\n        {children}\r\n      \u003c/PostContextUpdate.Provider\u003e\r\n    \u003c/PostContextValue.Provider\u003e\r\n  );\r\n};\r\n\r\n// 다른 컴포넌트에서의 사용\r\nimport { useEffect } from \"react\";\r\nimport { useMdContextUpdate } from \"@/context/mdContext\";\r\n\r\nexport default function Home({ posts }: { posts: PostType[] }) {\r\n  const update = useMdContextUpdate();\r\n\r\n  useEffect(() =\u003e {\r\n    if (posts) {\r\n      update(posts);\r\n    }\r\n  }, [posts, update]);\r\n```\r\n"},{"title":"react datepicker","description":"React datepicker 사용하기","category":"react","date":"2023-03-03","content":"\r\n# React Datepicker 사용하기\r\n\r\n공식 문서\r\n\r\nhttps://reactdatepicker.com/\r\n\r\n### package 설치\r\n\r\n```bash\r\nyarn add react-datepicker\r\n```\r\n\r\n패키지 설치 후 아래와 같이 import해 사용할 수 있다.\r\n\r\n```javascript\r\nimport DatePicker from \"react-datepicker\"; // 데이트픽커 import\r\nimport \"react-datepicker/dist/react-datepicker.css\"; // 데이트픽커 기본 CSS\r\nimport { ko } from \"date-fns/esm/locale\"; // 한국어 변환\r\n\r\nexport default function DatePickerTest() {\r\n  const [startDate, setStartDate] = useState(new Date());\r\n  const [endDate, setEndDate] = useState(null);\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003cDatePicker local={ko} /\u003e\r\n    \u003c/\u003e\r\n  );\r\n}\r\n```\r\n\r\n달력은 props 설정을 통해 다양한 방식의 달력을 설정해줄 수 있다.\r\n\r\n아래는 범위 지정 달력을 만드는 코드이다.\r\n\r\n```javascript\r\nexport default function DatePickerTest() {\r\n  const [startDate, setStartDate] = useState(new Date());\r\n  const [endDate, setEndDate] = useState(null);\r\n\r\n  const onChange = dates =\u003e {\r\n    const [start, end] = dates;\r\n    setStartDate(start);\r\n    setEndDate(end);\r\n  };\r\n\r\n  return (\r\n    \u003cDatePicker\r\n      elected={startDate}\r\n      onChange={onChange}\r\n      startDate={startDate}\r\n      endDate={endDate}\r\n      locale={ko}\r\n      selectsRange\r\n      inline\r\n    /\u003e\r\n  );\r\n}\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F5DkxI%2FbtrMUTz6YZb%2FpYNfcGfYjpM5GZlENLALTk%2Fimg.png)\r\n\r\n위 코드는 selectsRange라는 속성의 달력을 이용한다.\r\n다양한 속성은 상단의 공식 페이지 링크를 참고하면 좋다.\r\n\r\n## 스타일 적용\r\n\r\ncustom header 같은 props 옵션 등을 통해 css 스타일을 줄 수 있지만, 스타일이 원하는대로 입히기 어려운 점도 있었고 전체적인 코드가 보기 불편하다는 생각이 들어 styled component를 통해 css를 적용해줬다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzDzqF%2FbtrMWeKqb6T%2FkKiJfjfF1fP7vPcnWpyHOK%2Fimg.png)\r\n\r\n```javascript\r\n\r\nconst StyledDatePickerWrapper = styled.section`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 300px;\r\n  height: 380px;\r\n  border-radius: 20px;\r\n  box-shadow: 0 0 5px 0 rgb(71, 181, 255);\r\n\r\n  .react-datepicker {\r\n    background-color: white;\r\n    border-color: rgb(198, 232, 255);\r\n    border-radius: 20px;\r\n  }\r\n\r\n  /* ... */\r\n\r\n```\r\n\r\n코드가 길어지더라도 jsx와 철저하게 분리하고 싶다면 이런 방법도 나쁘지 않은 것 같다.\r\n"},{"title":"react media query","description":"React mediaQuery 사용법","category":"react","date":"2023-03-03","content":"\r\n# react-responsive 사용해보기\r\n\r\n공식 사이트 : https://yarnpkg.com/package/react-responsive\r\n\r\nCSS의 mediaQuery를 사용해볼 수도 있지만, 간편하게 적용할 수 있는 패키지가 있어서 사용해봤다.\r\n\r\n### 패키지 설치\r\n\r\n```bash\r\nyarn add react-responsive\r\n```\r\n\r\n### useMediaQuery 세팅\r\n\r\n```javascript\r\n// useMideaQuery.js\r\n\r\nimport { useMediaQuery } from \"react-responsive\";\r\n\r\nexport const Desktop = ({ children }) =\u003e {\r\n  const isDesktop = useMediaQuery({\r\n    minWidth: 481,\r\n  });\r\n  return isDesktop ? children : null;\r\n};\r\n\r\nexport const Mobile = ({ children }) =\u003e {\r\n  const isMobile = useMediaQuery({ maxWidth: 480 });\r\n  return isMobile ? children : null;\r\n};\r\n```\r\n\r\n위의 경우 모바일과 PC만 나눴지만 대략적인 분기점은 아래와 같이 설정해도 괜찮다\r\n\r\n1. 낮은 해상도의 PC, 태블릿 가로 : ~1024px\r\n2. 태블릿 가로 : 768px ~ 1023px\r\n3. 모바일 가로, 태블릿 : 480px ~ 767px\r\n4. 모바일 : ~480\r\n\r\n### useMediaQuery 사용\r\n\r\n```javascript\r\n// Responsive.jsx\r\n\r\nimport { Desktop, Mobile } from \"../../hooks/useMideaQuery\";\r\n\r\nexport const Responsive = () =\u003e {\r\n  return (\r\n    \u003c\u003e\r\n      \u003cDesktop\u003e\r\n        \u003cdiv\u003ePC화면\u003c/div\u003e\r\n      \u003c/Desktop\u003e\r\n      \u003cMobile\u003e\r\n        \u003cdiv\u003e모바일화면\u003c/div\u003e\r\n      \u003c/Mobile\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n```\r\n\r\n편의상 한 컴포넌트에 다 집어넣을 수도 있지만, 모바일과 데스크탑 환경의 view는 아예 다른 경우가 많기 때문에, 코드 관리를 편하게 하기 위해서는 모바일 컴포넌트를 따로 만드는게 더 나을 것 같다는 생각이 든다.\r\n"},{"title":"react modal non library","description":"라이브러리 없이 React Modal 만들기","category":"react","date":"2023-03-03","content":"\r\n# 라이브러리 없이 모달창 만들어보기\r\n\r\n모달 버튼이 있는 페이지\r\n\r\n```javascript\r\n// ModalTest.jsx\r\n\r\nimport ModalPage from \"./ModalPage\";\r\nimport { useState } from \"react\";\r\n\r\nexport default function ModalTest() {\r\n  // 모달을 보여줄지 말지 상태를 관리하는 state를 만들어준다.\r\n  const [showModal, setShowModal] = useState(false);\r\n\r\n  // 모달 버튼을 클릭하면 열리고\r\n  const openModal = () =\u003e {\r\n    setShowModal(true);\r\n  };\r\n  // 활성화된 모달창 밖을 클릭하면 닫힌다.\r\n  const closeModal = () =\u003e {\r\n    setShowModal(false);\r\n  };\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003cbutton onClick={openModal}\u003e모달이에옹\u003c/button\u003e\r\n      // 모달상태가 true면 ModalPage를 보여주고, 아니면 null // props로 showModal과\r\n      closeModal을 전달한다.\r\n      {showModal === true ? (\r\n        \u003cModalPage showModal={showModal} closeModal={closeModal} /\u003e\r\n      ) : null}\r\n    \u003c/\u003e\r\n  );\r\n}\r\n```\r\n\r\n모달 컴포넌트\r\n\r\n```javascript\r\nimport styled from \"styled-components\";\r\n\r\nexport default function ModalPage({ showModal, closeModal }) {\r\n  return (\r\n    // 모달 밖을 클릭하면 모달창을 닫게 만든다.\r\n    \u003cStyledModalBackground onClick={closeModal}\u003e\r\n      // stopPropagation은 부모태그로부터의 이벤트 전파를 중지시킨다. // 이\r\n      친구가 없으면 모달창 안쪽을 클릭해도 closeModal이 실행된다.\r\n      \u003cStyledModalContainer onClick={e =\u003e e.stopPropagation()}\u003e\r\n        \u003cStyledModal\u003e열린 모달창이에옹\u003c/StyledModal\u003e\r\n      \u003c/StyledModalContainer\u003e\r\n    \u003c/StyledModalBackground\u003e\r\n  );\r\n}\r\n\r\n// 위치를 대략 가운대로 정해주고\r\nconst StyledModalContainer = styled.div`\r\n  position: fixed;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n`;\r\n\r\n// 모달 밖 배경색은 우리에게 익숙한 어두운 색으로 만들어주자\r\nconst StyledModalBackground = styled.div`\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  bottom: 0;\r\n  right: 0;\r\n  background-color: rgba(0, 0, 0, 0.4);\r\n  z-index: 0;\r\n  cursor: auto;\r\n`;\r\n\r\n// 모달창 사이즈는 용도에 맞춰 설정해준다.\r\nconst StyledModal = styled.div`\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: white;\r\n`;\r\n```\r\n\r\n브라우저 화면\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOLJGf%2FbtrNjUdVndT%2FvgVskBO2xWeRwi01YQPzkk%2Fimg.png)\r\n\r\n스타일은 용도에 맞게 다양하게 변경시킬 수 있다.\r\n"},{"title":"react navigate props","description":"React navigate로 props 넘기기","category":"react","date":"2023-03-03","content":"\r\n# useNavigate를 이용한 props 전달\r\n\r\n### useNavigate로 다른 페이지의 화면으로 이동할 때, props처럼 값을 넘기는 방법을 사용해볼 수 있다.\r\n\r\n```javascript\r\n\r\n// 보내는컴포넌트.jsx\r\n\r\nimport { useNavigate } from \"react-router-dom\";\r\n\r\nconst Component1 = () =\u003e {\r\nconst navigate = useNavigate()\r\n\r\nlet someDatas = {\r\n\tname:\"hihi\"\r\n    value:\"here\"\r\n}\r\n\r\nreturn\r\n\u003cdiv onClick={() =\u003e navigate(`/다른페이지주소`,{ state: someDatas });}\u003e\r\n\t다른페이지로 이동\r\n\u003c/div\u003e\r\n}\r\n\r\n\r\n\r\n// 받는 컴포넌트.jsx\r\n\r\nimport { useLocation } from \"react-router-dom\";\r\n\r\nconst Component2 = () =\u003e {\r\n\tconst location = useLocation();\r\n\tconsole.log(location);\r\n}\r\n\r\n```\r\n\r\n위와 같이 작성은 아래와 같이 데이터를 받아오는 것을 보여준다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FedpbW9%2FbtrRGwsRGuz%2FKp5GIecYeABXw1FPbGLdsK%2Fimg.png)\r\n\r\n하지만 데이터를 받는 페이지가 직접적으로 접속할 수 있는 페이지라면 그렇게 접속한 페이지는 아무 데이터가 없는 화면으로 노출될 수 있기 때문에, 전역 상태를 관리해줄지, 데이터를 넘겨줄지 상황에 알맞는 방식을 적용하는 것이 중요하다.\r\n"},{"title":"react simple formdata code","description":"react formdata 코드간소화","category":"react","date":"2023-03-03","content":"\r\n# FormData 저장 코드 간소화하기\r\n\r\n하나의 폼에서 여러 개의 input 값을 변경하기 위해 함수를 만들어 간단하게 코드를 간소화시킬 수 있다.\r\n\r\n```typescript\r\n// form.tsx\r\n\u003cContainer onSubmit={e =\u003e onSubmitHandler(e, dispatch)}\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"profile_url\"\r\n    placeholder=\"https://picsum.photos/id/1/50/50 - 필수 X\"\r\n    value={formData.profile_url}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"author\"\r\n    placeholder=\"작성자\"\r\n    value={formData.author}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n    required\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003ctextarea\r\n    name=\"content\"\r\n    placeholder=\"내용\"\r\n    value={formData.content}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n    required\r\n  \u003e\u003c/textarea\u003e\r\n  \u003cbr /\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"createdAt\"\r\n    placeholder={`${todayDate()}`}\r\n    disabled\r\n    required\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003cbutton type=\"submit\"\u003e{isEdit ? \"수정하기\" : \"등록\"}\u003c/button\u003e\r\n\u003c/Container\u003e;\r\n\r\n// useForm.tsx\r\nconst [formData, setFormData] = useState\u003cFormData\u003e({\r\n  profile_url: \"\",\r\n  author: \"\",\r\n  content: \"\",\r\n  createdAt: todayDate(),\r\n});\r\n\r\nconst onChangeHandler = (e: InputEvent) =\u003e {\r\n  let type = e.target.name;\r\n  let value = e.target.value;\r\n  if (type === \"profile_url\")\r\n    setFormData(prev =\u003e ({ ...prev, profile_url: value }));\r\n  if (type === \"author\") setFormData(prev =\u003e ({ ...prev, author: value }));\r\n  if (type === \"content\") setFormData(prev =\u003e ({ ...prev, content: value }));\r\n  setFormData(prev =\u003e ({ ...prev, [type]: value }));\r\n};\r\n```\r\n\r\n하지만 위와 같이 if문이 많아져 코드의 성능과 가독성을 떨어뜨릴 수 있기 때문에, 아래와 같이 변경해볼 수 있다.\r\n\r\n```typescript\r\n// useForm.tsx\r\n\r\nconst [formData, setFormData] = useState\u003cFormData\u003e({\r\n  profile_url: \"\",\r\n  author: \"\",\r\n  content: \"\",\r\n  createdAt: todayDate(),\r\n});\r\n\r\nconst onChangeHandler = (e: InputEvent) =\u003e {\r\n  const { name, value } = e.target.name;\r\n  setFormData(prev =\u003e ({ ...prev, [name]: value }));\r\n};\r\n```\r\n\r\nhtml input의 name 속성을 이용해 setState 코드를 간소화시킬 수 있는 방법이다.\r\n"},{"title":"react styled components hover","description":"react에 styled-components를 이용해 hover 적용하기","category":"react","date":"2023-03-03","content":"\r\n# 리액트 스타일 컴포넌트에 hover 적용하기\r\n\r\n```typescript\r\n// \u0026:hover를 넣는다.\r\n\r\nconst ButtonStyle = styled.button`\r\n  \u0026:hover {\r\n    background-color: skyblue;\r\n    color: blue;\r\n  }\r\n`;\r\n```\r\n\r\n비슷한 상황에서 a 태그를 사용할때 자동으로 설정되는 스타일도 수정해줄 수 있다.\r\n\r\n```typescript\r\nconst LinkTag = styled.a`\r\n  /* 밑줄 제거 */\r\n  text-decoration: none;\r\n\r\n  /* 마우스를 링크에 올려뒀을 때의 스타일 */\r\n  \u0026:hover {\r\n  }\r\n  /* 아직 방문하지 않은 링크의 스타일 */\r\n  \u0026:link {\r\n  }\r\n  /* 사용자가 방문한 적이 있는(클릭한 이후) 링크의 스타일 */\r\n  \u0026:visited {\r\n  }\r\n  /* 마우스로 링크를 클릭하고 뗄 때까지의 스타일 */\r\n  \u0026:active {\r\n  }\r\n`;\r\n```\r\n"},{"title":"react submit prevent default","description":"form 태그에서 submit 이벤트 방지하기","category":"react","date":"2023-03-03","content":"\r\n# react form에서 submit 이벤트 방지하기\r\n\r\n### submit 이벤트가 발생하면 페이지가 새로고침이 된다.\r\n\r\n단순히 페이지가 리프레시 되는 것도 좋은 사용자 경험이 아닌데, 임시로 저장돼있던 데이터(회원가입 정보 등)가 날아가면 React의 작동 방식을 거스를 뿐 아니라 사용자 경험에도 치명적이다.\r\n\r\n떄문에 우리는 sumbit 이벤트를 멈춰줄 필요가 있다.\r\n\r\n```javascript\r\nconst Header = () =\u003e {\r\n  const onSubmit = e =\u003e {\r\n    e.preventDefault(); // 해당 코드로 이벤트를 멈춰줄 수 있다.\r\n  };\r\n\r\n  return (\r\n    \u003cform\u003e\r\n      \u003cinput type=\"text\" /\u003e\r\n      // 버튼 타입도 submit으로 꼭 변경해준다.\r\n      \u003cbutton type=\"submit\" onSubmit={e =\u003e onSubmit(e)}\u003e\r\n        입력\r\n      \u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 작성하면 같은 폼 안에 있는 경우에 대해 submit 방지가 잘 되는 것을 확인할 수 있다.\r\n"},{"title":"react z index error","description":"z-index가 올바르게 적용되지 않을때 적용해볼 수 있는 방법","category":"react","date":"2023-03-03","content":"\r\n# z-index 미적용시 해결방법\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2c0QV%2FbtrXD8G7Ar9%2FpCFQ6eujsGgA0bKCKx1kpk%2Fimg.png)\r\n\r\n위와 같이 z-index를 999로 적용해도 원하는대로 작동하지 않는 경우를 볼 수 있다.\r\n\r\n### MDN 공식 문서 : https://developer.mozilla.org/ko/docs/Web/CSS/z-index\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8pPBj%2FbtrXCijsq0h%2FkdCdCRUKvZIGe7dk8KPJf0%2Fimg.png)\r\n\r\n해당 사진의 마지막 줄의 \"자손의 z-index를 자기 외의 바깥 요소와 비교하지 않습니다.\" 이 부분으로 인한 문제로 생각됐다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fct1Z18%2FbtrXH8zek29%2Fjwx0ckk9YgnPRLS2sM06k0%2Fimg.png)\r\n\r\n부모 요소는 부모 요소끼리, 자식 요소는 자식 요소끼리 경쟁하기 때문에, 기존 코드는 이와 같이 HeaderNav 안에 SideMenu가 있어 HeaderNav 내에서만 z-index를 비교하고 있던 것이었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbUIap4%2FbtrXCicOSRi%2FzWiWf6wrtlUx9aK2uYKK7K%2Fimg.png)\r\n\r\n이처럼 SideMenu를 HeaderNav 밖으로 빼주니, 아래와 같이 정상적으로 작동하는 모습을 볼 수 있었다.\r\n\r\n### 정상 적용된 화면\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FwMc3x%2FbtrXFupLVFz%2FWH6kLZ1IbRxHnXK2bqkHa0%2Fimg.png)\r\n\r\n## z-index가 제대로 작동하지 않을때 참고할만한 사항\r\n\r\n1. 부모 요소는 부모 요소끼리 경쟁되고 있는지 확인한다.\r\n2. Element가 static(position 속성의 default 값)이 아닌 position 속성이 설정되어있는지 확인한다.(relative, absolute, fixed, sticky)\r\n3. opacity나 transform과 같은 css 속성이 설정돼있는지 확인한다. 해당 css요소가 설정돼있다면 1번의 기준에 맞춰 코드를 다시 작성해준다.\r\n\r\n이정도면 버그를 수정하는데 충분하지만 더 싶도 깊은 내용은 아래를 참고해보면 좋을 것 같다.\r\n\r\n참조 : https://coder-coder.com/z-index-isnt-working/\r\n"}]},"__N_SSG":true},"page":"/react","query":{},"buildId":"f3nUh6NMxmxPn7-70ZrQs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>