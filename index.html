<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Rain Sugar BangBang Front-End</title><meta name="description" content="developer&#x27;s blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta http-equiv="subject" content="developer blog"/><meta property="og:title" content="Rain Sugar BangBang"/><meta property="og:description" content="welcome to devLog"/><meta property="og:image" content="/images/cards/GITHUB.png"/><meta name="naver-site-verification" content="af9c8049662a7c6c85ea946e9eb561086e70062c"/><meta name="google-site-verification" content="Zgp7rA3RAdcRnhPPsGLK-t4KVTO86AejlDIQQIGpvLg"/><link rel="icon" href="/favicon.ico"/><link rel="preload" as="image" href="/images/cards/SW.png"/><meta name="next-head-count" content="12"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/f9bc783e634631d2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f9bc783e634631d2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7d0bddee48749f95.js" defer=""></script><script src="/_next/static/chunks/framework-73b8966a3c579ab0.js" defer=""></script><script src="/_next/static/chunks/main-b0c8bcfd40968c52.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ed405f4d132c66f8.js" defer=""></script><script src="/_next/static/chunks/789-6e729330f76e9f3d.js" defer=""></script><script src="/_next/static/chunks/pages/index-aa2231804f7a52cb.js" defer=""></script><script src="/_next/static/7MVUNX53bjILeXNTpzEEK/_buildManifest.js" defer=""></script><script src="/_next/static/7MVUNX53bjILeXNTpzEEK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="sc-c845a976-0 icUnkm"><header class="sc-fe6a8-0 fZHroo"><span style="display:none" class="sc-fe6a8-1 kOlYBJ"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 17 17" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g></g><path d="M16 3v2h-15v-2h15zM1 10h15v-2h-15v2zM1 15h15v-2h-15v2z"></path></svg></span><h1><a href="/">Rain Sugar BangBang</a></h1><span style="display:none" class="sc-fe6a8-1 kOlYBJ"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg></span></header><section class="sc-c845a976-1 bePtAz"><aside class="sc-226f6af7-0 jzKfYm"><div class="sc-226f6af7-1 eudLNA"><a target="_blank" href="https://portfolio-sigma-wheat-63.vercel.app/"><img alt="profile" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" src="/images/profileImage/cat.png"/><span>Go Profile!</span></a><p>Hanbbi</p></div><div class="sc-226f6af7-2 fEJwOM"><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 110.8V792H136V270.8l-27.6-21.5 39.3-50.5 42.8 33.3h643.1l42.8-33.3 39.3 50.5-27.7 21.5zM833.6 232L512 482 190.4 232l-42.8-33.3-39.3 50.5 27.6 21.5 341.6 265.6a55.99 55.99 0 0 0 68.7 0L888 270.8l27.6-21.5-39.3-50.5-42.7 33.2z"></path></svg><span>yhl0078@gmail.com</span></a><a target="_blank" href="https://github.com/LEE-YO-HAN"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>Github</span></a></div></aside><article class="sc-c845a976-2 jRRSKe"><div class="sc-b797c1b7-0 jSiudw"><div class="sc-b797c1b7-1 ctQsiT"><span>전체 글<!-- --> (<!-- -->59<!-- -->)</span><form><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg><input type="text" style="opacity:0" placeholder="키워드 입력 후 엔터를 눌러주세요" class="sc-15314a72-0 bDAivC"/></form></div><ul class="sc-b797c1b7-2 dwTYwt"><a href="/sw-last-test"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 실기</p><span>2023. 12. 29</span></div></li></a><a href="/sw-first-test5"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(5) - 정보처리시스템 구축 관리</p><span>2023. 12. 28</span></div></li></a><a href="/sw-first-test4"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(4) - 프로그래밍 언어 활용</p><span>2023. 12. 27</span></div></li></a><a href="/sw-first-test3"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(3) - DB 구축</p><span>2023. 12. 26</span></div></li></a><a href="/sw-first-test2"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(2) - 소프트웨어 개발</p><span>2023. 12. 25</span></div></li></a><a href="/sw-first-test1"><li class="sc-b797c1b7-3 ecIaXB"><img alt="카테고리 이미지" width="200" height="150" decoding="async" data-nimg="1" style="color:transparent" src="/images/cards/SW.png"/><div class="sc-b797c1b7-4 bLwsMg"><p>정보처리기사 필기(1) - 소프트웨어 설계</p><span>2023. 12. 24</span></div></li></a></ul><ul class="sc-4a3f34e2-0 dBfZty"><li class="noPrev"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m3.86 8.753 5.482 4.796c.646.566 1.658.106 1.658-.753V3.204a1 1 0 0 0-1.659-.753l-5.48 4.796a1 1 0 0 0 0 1.506z"></path></svg></li><li id="1" class="activePage">1</li><li id="2" class="page">2</li><li id="3" class="page">3</li><li id="4" class="page">4</li><li id="5" class="page">5</li><li class=""><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z"></path></svg></li></ul></div></article><aside class="sc-7eadfa91-0 cYGwoY"><nav class="sc-7add3e4e-0 fnrcex"><ul class="sc-7add3e4e-1 jERCOF"><p>Category</p><div><p class="sc-7add3e4e-2 seojt">FE</p><li class="sc-7add3e4e-3 gUTLrq"><a href="/html">HTML</a></li><li class="sc-7add3e4e-3 gUTLrq"><a href="/css">CSS</a></li><li class="sc-7add3e4e-3 gUTLrq"><a href="/javascript">JavaScript</a></li><li class="sc-7add3e4e-3 gUTLrq"><a href="/typescript">TypeScript</a></li><li class="sc-7add3e4e-3 gUTLrq"><a href="/redux">Redux</a></li><li class="sc-7add3e4e-3 gUTLrq"><a href="/react">React</a></li><li class="sc-7add3e4e-3 gUTLrq"><a href="/nextjs">Nextjs</a></li></div><div><p class="sc-7add3e4e-2 seojt">BE</p><li class="sc-7add3e4e-3 gUTLrq"><a href="/nestjs">Nestjs</a></li></div><div><p class="sc-7add3e4e-2 seojt">CS</p><li class="sc-7add3e4e-3 gUTLrq"><a href="/sw">정보처리기사</a></li></div><div><p class="sc-7add3e4e-2 seojt">ETC</p><li class="sc-7add3e4e-3 gUTLrq"><a href="/github">Simple Memo</a></li></div></ul></nav></aside></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"sw last test","description":"정보처리기사 실기","category":"sw","keyword":"정보처리기사, 정처기, 실기","date":"2023-12-29","content":"\r\n## 실기 시험 공략\r\n\r\n실기 시험도 필기와 마찬가지로 정보 보안이나 테스트 기법, GoF, 프로토콜 외에도 다양한 문제가 많이 분포돼있어서 기출 문제를 많이 풀어보면 도움은 된다.\r\n\r\n그러나 최근 복원 문제들을 봤을 때 프로그래밍 언어, DB(SQL 등) 문제가 많이 출제되는 경향이 있기 때문에 프로그래밍 언어와 어느정도 친해진 후에 시험을 보면 좋을 것 같다.\r\n\r\n나의 경우 javascript가 베이스여서 C, Java, Python은 잘 몰랐지만 언어 특성만 알면 구조는 비슷하다고 느껴졌다. (그래도 C의 포인터, Java의 메소드 오버라이딩/오버로딩 문제는 많이 봐두면 좋을 것 같다.)\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n[실기 기출 종합 키워드](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C)\r\n\r\n---\r\n\r\n# 실기 기출 종합 키워드 2020-2022\r\n\r\n# SW 기본\r\n\r\n## 인터페이스 전송 데이터\r\n\r\n- JSON(JavaScript Object Notation)\r\n  - Javascript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷\r\n  - JSON 데이터는 이름과 값의 쌍으로 이루어진다.\r\n- XML(eXtensible Markup Language)\r\n  - 웹에서 구조화한 문서를 표현하고 전송하도록 설계한 마크업 언어\r\n- CSV(Comma Separated Values)\r\n  - 몇 가지 필드를 쉼표(,)로 구분한 텍스트 데이터 및 텍스트 파일\r\n- YAML\r\n  - XML, C, 파이썬, 펄, RFC2822에서 정의된 e-mail 양식에서 개념을 얻어 만들어진 '사람이 쉽게 읽을 수 있는' 데이터 직렬화 양식\r\n\r\n## REST\r\n\r\n- 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것\r\n- HTTP URI를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.\r\n- RESTful : REST라는 아키텍처를 구현하는 웹 서비스\r\n\r\n## 시맨틱 웹\r\n\r\n- 의미론적인 웹, 즉 문서의 의미에 맞게 애플리케이션의 의미에 맞게 구성된 웹\r\n- 컴퓨터가 사람을 대신하여 정보를 읽고, 이해하고 가공하여 새로운 정보를 만들어 낼 수 있도록 이해하기 쉬운 의미를 가진 차세대 지능형 웹\r\n\r\n## SSO(통합 인증)\r\n\r\n\u003e SSO(Same Sign-on - 통합 인증)란 한 번의 인증 과정으로 여러 컴퓨터 상의 자원을 이용 가능하게 하는 인증 기능이다. 싱글 사인온, 단일 계정 로그인, 단일 인증이라고 한다.\r\n\r\n## 프로토콜의 기본 3요소\r\n\r\n- 구문 : 데이터의 구조나 형태와 포맷을 정의한다.\r\n- 타이밍 : 어떤 데이터를 보낼 것인지, 얼마나 빨리 보낼 것인지를 결정한다.\r\n- 의미 : 데이터의 각 부분이 무엇을 뜻하는지 알 수 있게 미리 정해둔 규칙이다.\r\n\r\n## 프로세스 스케줄링 ★★★\r\n\r\n- **비선점 스케줄링**\r\n  - FCFS(First Come First Service)\r\n    - 먼저 들어간 것을 먼저 실행한다.\r\n  - SJF(Shortest Job First)\r\n    - 진행 중인 프로세스를 멈추지는 않는다.\r\n    - CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식으로, 평균 대기시간을 최소로 만드는 것을 최적으로 두고 있는 알고리즘이다.\r\n  - HRN(Highest Response Ratio Next)\r\n    - 최고응답률 계산식 : (대기시간 + 서비스시간) / 서비스시간\r\n    - 최고응답률의 값이 큰 순으로 우선순위를 정하는 방식\r\n  - 기한부(Deadline)\r\n    - 작업들이 명시된 기간이나 기한 내에 완료되도록 계획\r\n  - 우선순위(Priority)\r\n    - 우선순위 스케줄링은 각 프로세스의 우선순위가 정해지면, 우선순위가 제일 높은 프로세스에게 CPU를 할당하되, 우선순위가 같은 경우에는 FCFS 방식을 적용한다.\r\n    - 일반적인 연산 위주 프로세스보다 입출력 위주 프로세스에게 높은 우선순위를 부여하여 대화성을 증진시킨다.\r\n- **선점 스케줄링**\r\n  - SRT(Shortest Remaining Time Scheduling)\r\n    - 최단 잔여시간을 우선으로 하는 스케줄링 기법으로, 진행 중인 프로세스가 있어도, 최단 잔여시간인 프로세스를 위해 sleep 시키고 짧은 프로세스를 먼저 할당한다.\r\n  - RR(Round Robin Scheduling)\r\n    - 시분할 시스템을 위해 설계되었다.\r\n    - FCFS(FIFO) 알고리즘을 선점 형태로 변형한 기법이다.\r\n    - 준비 큐를 원형 큐로 간주하고 순환식으로 각 프로세스에게 작은 단위의 시간량(타임 퀀텀)만큼씩 CPU를 할당하는 방식이다.\r\n    - FCFS 기법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만, 각 프로세스는 시간 할당량(Time Slice, Quantum) 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치된다.\r\n    - 이론상 n개의 프로세스가 1/n의 속도로 동시에 실행된다.\r\n    - 일반적으로 평균 반환시간이 SJF보다 크지만, 프로세스가 공정하게 기회를 얻게 되어 기아상태가 발생하지는 않는다.\r\n    - 타임 퀀텀의 크기가 작으면 잦은 문맥 교환 오버헤드 증가로 처리율이 감소할 수 있으며, 성능은 타임 퀀텀의 크기에 많은 영향을 받는다.\r\n    - 할당되는 시간의 크기가 작으면 작은 프로세스들에게 유리하다.\r\n  - MLQ(Multi-Level Queue - 다단계 큐)\r\n  - MLFQ(Multi-Level Feedback Queue - 다단계 피드백 큐)\r\n\r\n# SW 설계/개발\r\n\r\n## 형상관리 절차\r\n\r\n- 형상 식별 -\u003e 형상 통제 -\u003e 형상 감사 -\u003e 형상 기록\r\n\r\n※ 버전 관리 도구 분류\r\n\r\n- 공유 폴더 방식\r\n  - SCCS, RCS, PVCS\r\n- 클라이언트/서버 방식\r\n  - CVS, SVN, Clear Case\r\n- 분산 저장소 방식\r\n  - Git, Gnu arch, Bazaar, Bitkeeper\r\n\r\n## 형상 관리/형상 통제\r\n\r\n- 소프트웨어 형상 변경 요청을 검토하고 승인하여 현재의 베이스라인에 반영될 수 있도록 통제하는 것을 의미한다.\r\n- 형상관리 절차 : 형상 식별 -\u003e 형상 통제 -\u003e 형상 감사 -\u003e 형상 기록\r\n- 통제 : 소프트웨어 형상 변경 요청을 검토하고 승인하여 현재의 베이스라인에 반영될 수 있도록 통제\r\n\r\n## UI의 설계 원칙\r\n\r\n| 설계 원칙 |                              설명                              |\r\n| :-------: | :------------------------------------------------------------: |\r\n|  직관성   |          누구나 쉽게 이해하고 사용할 수 있어야 한다.           |\r\n|  유효성   |           사용자의 목적을 정확하게 달성하여야 한다.            |\r\n|  학습성   |            누구나 쉽게 배우고 익힐 수 있어야 한다.             |\r\n|  유연성   | 사용자의 요구사항을 최대한 수용하며, 오류를 최소화하여야 한다. |\r\n\r\n## 객체지향 설계원칙(SOLID)\r\n\r\n- 단일 책임 원칙(SRP, Single Responsibility Principle)\r\n  - 한 클래스는 하나의 책임만을 가져야 한다.\r\n- 개방 폐쇄 원칙(OCP, Open-Close Principle)\r\n  - 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.\r\n- 리스코프 치환 원칙(LSP, Liskov substitution principle)\r\n  - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다.\r\n- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)\r\n  - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.\r\n- 의존성 역전 원칙(DIP, Dependency Inversion Principle)\r\n  - 의존 관계를 맺을 때 자주 변화하는 것보다, 변화가 거의 없는 것에 의존해야 한다.\r\n\r\n## 릴리즈 노트 작성 항목\r\n\r\n|                 |                                                                                        |\r\n| :-------------: | -------------------------------------------------------------------------------------- |\r\n| 머리말 (Header) | 릴리즈 노트명, 제품 이름, 작성일, 릴리즈 노트 버전 등의 정보 고지                      |\r\n|      개요       | 소프트웨어 및 변경사항에 관한 간략하고 전반적인 내용                                   |\r\n|      목적       | 해당 릴리즈 버전에서의 새로운 기능, 수정된 기능, 릴리즈 노트의 목적에 대한 간략한 개요 |\r\n| 이슈(문제) 요약 | 발견된 문제에 대한 요약                                                                |\r\n|    재현 항목    | 버그 발견에 대한 재현 단계 기술                                                        |\r\n| 수정/개선 내용  | 발견된 버그의 수정/개선 사항을 간단히 기술                                             |\r\n\r\n## UML 관계\r\n\r\n- 일반화 관계(Generalization)\r\n  - 한 클래스가 다른 클래스를 포함하는 상위 개념일 때의 관계\r\n- 연산 관계(Accociation)\r\n  - 2개 이상 사물이 서로 관련된 관계\r\n  - 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때의 표시\r\n- 의존 관계(Dependency)\r\n  - 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때 표시\r\n  - 클래스의 관계가 한 메서드를 실행하는 동안과 같이 매우 짧은 시간만 유지\r\n- 실체화 관계(Realization)\r\n  - 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정\r\n  - 인터페이스를 구현받아 추상 메서드를 오버라이딩하는 의미\r\n- 집합 관계-집약 관계(Aggregation)\r\n  - 한 객체가 다른 객체를 소유하는 'has a'관계\r\n  - 전체 객체의 라이프타임과 부분 객체의 라이프타임은 독립적\r\n- 집합 관계-합성관계(Composition)\r\n  - 부분 객체가 전체 객체에 속하는 관계로 긴밀한 필수적 관계\r\n\r\n## 유스케이스 다이어그램 관계\r\n\r\n- 연관관계(Association)\r\n  - 유스케이스와 액터 간의 상호작용이 있음을 표현\r\n- 포함관계(Include)\r\n  - 유스케이스를 수행할 때 반드시 실행되어야 하는 경우\r\n- 확장 관계(Extend)\r\n  - 유스케이스를 수행할 때 특정 조건에 따라 확장 기능 유스케이스를 수행하는 경우\r\n\r\n## 결합도 유형\r\n\r\n|                       구분                        |                                                  설명                                                  |\r\n| :-----------------------------------------------: | :----------------------------------------------------------------------------------------------------: |\r\n|  자료 결합도 (Data Coupling) (결합도 가장 낮음)   |                                모듈간의 인터페이스로 값이 전달되는 경우                                |\r\n|          스탬프 결합도 (Stamp Coupling)           |                 모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우                  |\r\n|          제어 결합도 (Control Coupling)           |     단순 처리할 대상인 값만 전달되는게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우      |\r\n|          외부 결합도 (External Coupling)          |                 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조하는 경우                 |\r\n|           공통 결합도 (Common Coupling)           | 파라미터가 아닌 모듈 밖에서 선언된 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호 작용하는 경우 |\r\n| 내용 결합도 (Content Coupling) (결합도 가장 높음) |                    다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우                     |\r\n\r\n## 응집도 유형\r\n\r\n|                      구분                       |                                            설명                                            |\r\n| :---------------------------------------------: | :----------------------------------------------------------------------------------------: |\r\n| 우연적 응집도 (Coincidental) (응집도 가장 낮음) |                       모듈 내부의 각 구성 요소들이 연관이 없을 경우                        |\r\n|             논리적 응집도 (Logicla)             |     유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우      |\r\n|            시간적 응집도 (Temporal)             |    연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우    |\r\n|           절차적 응집도 (Procedural)            | 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우 |\r\n|          통신적 응집도 (Communication)          |         동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있는 경우         |\r\n|           순차적 응집도 (Sequential)            |             모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우              |\r\n|  기능적 응집도 (Functional) (응집도 가장 높음)  |                  모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우                  |\r\n\r\n# 테스트\r\n\r\n## 소프트웨어 테스트의 원리\r\n\r\n- 테스팅은 결함이 존재함을 밝히는 활동이다.\r\n- 완벽한 테스팅은 불가능하다.\r\n- 테스팅은 개발 초기에 시작해야 한다.\r\n- 결함 집중(파레토 원칙)\r\n  - 많은 성과에서 결과의 약 80%가 20%의 원인에서 발생한다\r\n- 살충제 패러독스\r\n  - 동일한 테스트로 동일한 절차를 반복 수행하면 새로운 결함을 찾을 수 없다.\r\n- 테스팅은 정황(Context)에 의존한다.\r\n- 오류 - 부재의 궤변\r\n  - 결함이 없어도, 요구사항을 충족시켜주지 못한다면 해당 소프트웨어의 품질이 높다고 할 수 없다\r\n\r\n## 애플리케이션 테스트 유형 분류\r\n\r\n- 프로그램 실행 여부\r\n  - 정적 테스트(실행하지 않고 행하는 테스트)\r\n  - 동적 테스트(실행하면서 확인하는 테스트)\r\n- 테스트 기법\r\n  - 화이트박스 테스트\r\n    - 소스코드를 보면서 실행시킴\r\n    - 제어흐름(조건문, 반복문), 데이터 흐름(변수, 자료구조), 분기, 경로 테스트 등이 있음\r\n  - 블랙박스 테스트\r\n    - 기능/부분적인 코드 실행을 통한 테스트\r\n    - 원인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법\r\n    - 경계값 검사 : 입력 조건의 경계값을 테스트 케이스로 선정하는 방법\r\n    - 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법\r\n    - 동등 분할 기법 : 입력 자료에 초점을 맞춰 테스트 케이스를 만들어 검사하는 방법\r\n    - 오류 예측 검사 : 과거의 경험이나 테스터의 감각으로 테스트하는 기법\r\n- 테스트에 대한 시각\r\n  - 검증 테스트(개발자 테스트)\r\n  - 확인 테스트(사용자 테스트)\r\n- 테스트 목적\r\n  - 회복 테스트 : 소프트웨어가 다양한 방법으로 실패하도록 유도하고 회복이 적절하게 수행되는지를 검증하면서 회복이 시스템에 의해 자동으로 수행되면 재초기화, 데이터회복, 재시작 방법 등에 의해 정상적으로 회복되는지를 평가\r\n  - 안전 테스트 : 안전성 검증\r\n  - 강도 테스트 : stress test - 과다한 정보량 투입\r\n  - 성능 테스트 : 응답속도, 처리량 등을 측정\r\n  - 구조 테스트 : 내부 논리경로, 복잡도 평가\r\n  - 회귀 테스트 : 변경 또는 교정이 새로운 오류를 발생시키는지 여부 확인\r\n  - 병행 테스트 : 변경 전과 변경 후 프로그램을 동등한 데이터로 테스트하여 결과 비교\r\n- 테스트 기반\r\n  - 명세 기반 테스트\r\n  - 구조 기반 테스트\r\n  - 경험 기반 테스트\r\n\r\n## 코드 커버리지(Code Coverage)\r\n\r\n- 구문 커버리지\r\n  - 코드 구조 내의 모든 구문에 대해 한 번 이상 수행하는 테스트 커버리지\r\n- 조건 커버리지\r\n  - 결정 포인트 내의 모든 개별 조건식에 대해 수행하는 테스트 커버리지\r\n- 결정 커버리지\r\n  - 결정 포인트 내의 모든 분기문에 대해 수행하는 테스트 커버리지\r\n- 조건/결정 커버리지\r\n  - 결정포인트 T/F, 개별조건식 T/F를 가져야 한다.\r\n- 변경/조건 커버리지\r\n  - 모든 결정 포인트 내의 개별 조건식은 적어도 한 번 T, F를 가져야 한다.\r\n- 다중 조건 커버리지\r\n  - 결정 포인트 내 모든 개별 조건식의 가능한 조합을 100% 보장해야 한다.\r\n\r\n## V 모델과 테스트 레벨\r\n\r\n![V Model Image](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-5.png)\r\n\r\n# 데이터베이스\r\n\r\n## 반정규화의 유형\r\n\r\n|     구분      |       유형       | 설명                    |\r\n| :-----------: | :--------------: | ----------------------- |\r\n|  테이블 분할  |     수평분할     | 레코드 단위로 분할      |\r\n|               |     수직분할     | 컬럼 단위로 분할        |\r\n|  테이블 중복  | 통계 테이블 추가 | DW,OLAP 데이터용        |\r\n|               | 진행 테이블 추가 | 업무 프로세스 상태      |\r\n| 컬럼기반 분할 |  조회 빈도 기반  | 고빈도 컬럼 분리        |\r\n|               |  크기 기반 분할  | 일정 용량 컬럼 분리     |\r\n|   컬럼 중복   |  중복 컬럼 추가  | 자주 조회되는 컬럼 추가 |\r\n|               |  파생 컬럼 추가  | 연산 결과 별도 저장     |\r\n\r\n## 데이터베이스 스키마\r\n\r\n- 외부 스키마\r\n  - VIEW와 연계돼있으며 여러 개가 존재할 수 있다.\r\n- 개념 스키마\r\n  - 데이터베이스의 전체적인 구조와 제약조건을 의미한다.\r\n- 내부 스키마\r\n  - 저장장치 입장에서 본 구조\r\n- 논리적 독립성 : 개념 스키마나 내부 스키마가 바뀌어도 외부 스키마에 영향을 주지 않는다.\r\n- 물리적 독립성 : 내부 스키마가 바뀌어도 개념 스키마와 외부 스키마에 영향을 주지 않는다.\r\n\r\n## SQL 기본문법\r\n\r\nSELECT\r\n\r\n\\*, a, b\r\n\r\nFROM [테이블명]\r\n\r\nWHERE ~~\r\n\r\nAND/OR ~~\r\n\r\nGROUP BY [속성]\r\n\r\nhaving ~~\r\n\r\nORDER BY [컬럼] ASC/DESC\r\n\r\n## SQL ALTER\r\n\r\n- 속성 추가\r\n  - ALTER TABLE [테이블 이름] ADD [속성명] [데이터 타입];\r\n- 속성 변경\r\n  - ALTER TABLE [테이블 이름] MODIFY [속성명] [데이터 타입];\r\n- 속성 삭제\r\n  - ALTER TABLE [테이블 이름] DROP [속성명] [데이터 타입];\r\n\r\n## 관계대수 연산자\r\n\r\n|                  |                                                            |\r\n| :--------------: | ---------------------------------------------------------- |\r\n| 순수 관계 연산자 | SELECT(∑-시그마), PROJECT(π - 파이), JOIN(▶◀), DIVISION(÷) |\r\n| 일반 집합 연산자 | 합집합(∪), 교집합(∩), 차집합(-), 카티션 프로덕트(×)        |\r\n\r\n- SELECT(∑) : 릴레이션에서 조건을 만족하는 수평적 부분 집합(튜플)을 구하기 위한 연산\r\n\r\n![select](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-1.png)\r\n\r\n- PROJECT(π) : 릴레이션에서 수직적 부분으로 집합(속성의 값)을 구하는 연산으로 원하는 속성을 추출하기 위한 연산.\r\n\r\n![project](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-2.png)\r\n\r\n- JOIN(▶◀) : 두 테이블로부터 조건에 맞는 관련된 튜플들을 하나의 튜플로 결합하여 하나의 테이블로 만드는 연산\r\n\r\n![join](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-3.png)\r\n\r\n- DIVISION(÷) : A, B 두 테이블에 대해 'A DIVISION B'는 B 테이블의 조건을 만족하는 튜플들을 테이블 A에서 추출하는 연산\r\n\r\n![division](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-4.png)\r\n\r\n![연산자](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-10.png)\r\n\r\n### 관계 대수\r\n\r\n![관계 대수](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-7.png)\r\n\r\n- 시그마 = ∑\r\n\r\n## 구조적 다이어그램(Structure Diagram)\r\n\r\n- 클래스 다이어그램\r\n  - 시스템을 구성하는 클래스들 사이의 관계를 표현한다.\r\n- 패키지 다이어그램\r\n  - 클래스나 유스케이스 등을 포함한 여러 모델 요소들을 그룹화하여 패키지를 구성하고 패키지들 사이의 관계를 표현한다.\r\n- 복합체 구조 다이어그램\r\n  - 복합 구조의 클래스와 컴포넌트 내부 구조를 표현한다.\r\n- 객체 다이어그램\r\n  - 객체 정보를 보여준다.\r\n- 컴포넌트 다이어그램\r\n  - 컴포넌트 구조 사이의 관계를 표현한다.\r\n- 배치 다이어그램\r\n  - 소프트웨어, 하드웨어, 네트워크를 포함한 실행 시스템의 물리 구조를 표현한다.\r\n\r\n## 행위 다이어그램(Behavior Diagram)\r\n\r\n- 유스 케이스 다이어그램\r\n  - 사용자 관점에서 시스템 행위를 표현한다.\r\n- 활동 다이어그램\r\n  - 업무 처리 과정이나 연산이 수행되는 과정을 표현한다.\r\n- 콜라보레이션 다이어그램\r\n  - 순차 다이어그램(Sequence Diagram)과 같으며, 모델링 공간에 제약이 없어 구조적인 면을 중시한다.\r\n- 상태 머신 다이어그램\r\n  - 객체의 생명주기를 표현한다.\r\n- 순차 다이어그램\r\n  - 시간 흐름에 따른 객체 사이의 상호작용을 표현한다.\r\n- 통신 다이어그램\r\n  - 객체 사이의 관계를 중심으로 상호작용을 표현한다.\r\n- 상호작용 개요 다이어그램\r\n  - 여러 상호작용 다이어그램 사이의 제어 흐름을 표현한다.\r\n- 타이밍 다이어그램\r\n  - 객체 상태 변화와 시간 제약을 명시적으로 표현한다.\r\n\r\n## 테스트 오라클\r\n\r\n- 휴리스틱(Heuristic) 오라클\r\n  - 임의의 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리\r\n- 참(True) 오라클\r\n  - 모든 입력값에 적합한 결과를 생성하여, 발생한 오류를 모두 검출\r\n- 일관성 검사(Consistent) 오라클\r\n  - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 같은지 확인\r\n- 샘플링(Sampling) 오라클\r\n  - 임의로 선정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공\r\n\r\n## 데이터베이스 정규화\r\n\r\n비정규 릴레이션\r\n\r\n↓ 도메인이 원자값\r\n\r\n제1정규형\r\n\r\n↓ 부분적 함수 종속 제거\r\n\r\n제2정규형\r\n\r\n↓ 이행적 함수 종속 제거\r\n\r\n제3정규형\r\n\r\n↓ 결정자이면서 후보키가 아닌 것 제거\r\n\r\nBCNF\r\n\r\n↓ 다치 종속 제거\r\n\r\n제4정규형\r\n\r\n↓ 조인 종속성 이용\r\n\r\n제5정규형\r\n\r\n## 데이터베이스 회복 기법\r\n\r\n- 즉시 갱신 기법\r\n  - 트랜잭션이 실행(활동) 상태에서 변경되는 내용을 그때그때 바로 데이터베이스에 적용하는 기법\r\n  - 변경되는 모든 내용은 로그(Log)에 기록하여 장애 발생 시 로그(Log)의 내용을 토대로 회복\r\n  - Redo, Undo 모두 수행\r\n- 지연 갱신 기법\r\n  - 트랜잭션이 수행되어 부분완료 될 때까지 데이터베이스에 적용하지 않고 지연시킨 후 부분완료가 되면 로그(Log)의 내용을 토대로 데이터베이스에 적용하는 기법\r\n  - Redo만 수행\r\n- 검사점 회복 기법(Checkpoint Recovery)\r\n  - 트랜잭션이 실행되는 중간에 검사 시점(Check Point)을 지정하여 검사 시점까지 수행 후 완료된 내용을 데이터베이스에 적용하는 기법\r\n- 그림자 페이징(Shadow Paging) 기법\r\n  - 로그(Log)를 사용하지 않고, 데이터베이스를 동일한 크기의 단위인 페이지로 나누어 각 페이지마다 복사하여 그림자 페이지를 보관\r\n  - 데이터베이스의 변경되는 내용은 원본 페이지에만 적용하고, 장애가 발생되는 경우 그림자 페이지를 이용해 회복\r\n\r\n## 데이터베이스에서의 이상현상\r\n\r\n- 삽입 이상 : 릴레이션에서 데이터를 삽입할 때 의도와는 상관없이 원하지 않는 값들로 함께 삽입되는 현상\r\n- 삭제 이상 : 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들로 함께 삭제되는 연쇄 삭제 현상\r\n- 갱신 이상 : 릴레이션에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상\r\n\r\n## 트랜젝션의 특성\r\n\r\n\u003e 트랜젝션이란, 데이터베이스에서 하나의 그룹으로 처리되어야 하는 명령문들을 모아 놓은 논리적인 작업 단위이다. 여러 개의 명령어의 집합이 정상적으로 처리되면 정상 종료되며, 하나의 명령어라도 잘못되면 전체가 롤백된다.\r\n\r\n### 트랜잭션을 사용하는 이유\r\n\r\n- 데이터의 일관성을 유지하면서 안정적으로 데이터를 복구하기 위해 사용한다.\r\n- 데이터베이스에서는 테이블에서 데이터를 읽어 온 후 다른 테이블에 데이터를 입력하거나 갱신, 삭제하는데 처리 도중 오류가 발생하면 모든 작업을 원상태로 되돌린다. 처리 과정이 모두 성공했을 때만 최종적으로 데이터베이스에 반영한다.\r\n\r\n### 트랜잭션의 특징(ACID)\r\n\r\n- 원자성(Atomicity)\r\n  - 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력\r\n  - 트랜잭션이 DB에 모두 반영되거나 전혀 반영되지 않는 것. (All or Nothing)\r\n- 일관성(Consistency)\r\n  - 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.\r\n  - 만약 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.\r\n- 독립성(Isolation)\r\n  - 트랜잭션 수행 시 다른 트랜잭션의 연산 적업이 끼어들지 못하도록 보장하는 것을 의미한다.\r\n  - 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 제 3자가 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽 데이터에 접근할 수 없다.\r\n- 지속성(Durability)\r\n  - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 즉, 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다.\r\n  - 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.\r\n\r\n## 데이터베이스 무결성\r\n\r\n- 개체 무결성(Entity Integrity)\r\n  - 고유 키(유일 키)의 개념과 관련되며, 개체 무결성은 모든 테이블이 기본 키(primary key)를 가져야 하며 기본 키로 선택된 열은 고유하여야 하며 빈 값은 허용하지 않음을 규정한다.**(Not Null 제약조건)**\r\n- 참조 무결성(Referential Integrity)\r\n  - 외래 키(외부 키)의 개념과 관련되며, 참조 무결성 규칙은 모든 외래 키 값은 두 가지 상태 가운데 하나에만 속함을 규정한다.\r\n  - 일반적인 상태는 외래 키 값이 데이터베이스의 특정 테이블의 기본 키 값을 참조하는 것이다. 이는 비즈니스의 규칙에 따라 달라질 수 있으며 외래 키 값은 빈 값을 허용한다.\r\n  - **릴레이션 R1에 속성 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 한다. 이때 참조할 수 없는 외래키 값을 가질 수 없다는 제약조건이다.**\r\n- 도메인 무결성(Domain Integrity)\r\n  - **릴레이션 중 하나의 속성은 반드시 원자 값**이어야 한다는 것을 보장하는 제약조건이다.\r\n\r\n# SW 보안/암호\r\n\r\n## IPSec의 헤더 프로토콜\r\n\r\n- AH(Authentication Header)\r\n  - 무결성을 보장하기 위한 프로토콜이며, IP패킷이 전송중에 변조되지 않았음을 보장하는 서비스를 제공한다.\r\n- ESP(Encapsulation Security Payload)\r\n  - IP 페이로드를 암호화하여 데이터 기밀성을 제공함으로써 제3자에게 데이터가 노출되는 것을 차단한다.\r\n\r\n## LINUX 파일 보안\r\n\r\n예문 : d rwx1 rwx2 rwx3\r\n\r\n- d\r\n  - 파일 종류\r\n  - d : 디렉토리\r\n  - \\- : 일반 파일\r\n  - | : 심볼릭 링크\r\n  - b : 블록형 장치\r\n  - c : 글자형 장치\r\n- rwx1 : 소유자(owner)의 권한\r\n- rwx2 : 그룹(group)의 권한\r\n- rwx3 : 기타 사용자(others)의 권한\r\n\r\n## 암호화 방식의 분류\r\n\r\n- 대칭키(비밀키)\r\n  - Stream - LFSR, RC4\r\n  - Block 방식 - DES, AES, IDEA\r\n- 비대칭키(공개키)\r\n  - 인수분해 이용 - RSA, Robin\r\n  - 이산대수 - Elgamal, DSA\r\n  - 타원곡선 - ECC\r\n\r\n\u003e 대칭키(비밀키)란, 암호화/복호화에 사용하는 키가 동일한 암호화 방식으로, 비대칭키(공개키)에 비해 빠르지만 키를 교환해야 한다는 문제(키 배송 문제)가 발생한다. 키를 교환하는 중 키가 탈취될 가능성도 있고, 사람이 증가할수록 따로 키 교환을 해야하기 때문에 관리해야 할 키가 방대하게 많아진다.\r\n\r\n\u003e 비대칭(공개키)키란, 암호화/복호화에 사용하는 키가 서로 다른 것으로, 송수신자 모두 한 쌍의 키(개인키, 공개키)를 갖고 있게 된다. 일종의 인증 기능을 통해 보안에 용이하나 속도가 느리다.\r\n\r\n### 비밀키(대칭키) 알고리즘\r\n\r\n- DES(Data Encryption Standard - 최근에는 잘 사용되지 않음)\r\n  - 블록 암호의 일종으로, 미국 NBS 에서 국가 표준으로 정한 암호\r\n- AES(DES 보완)\r\n- ARIA(Academy Research Institute Agency,- 학계, 연구소, 정부기관이 공동으로 개발했다는 함축적 의미)\r\n  - 대한민국의 국가보안기술연구소에서 개발한 블록 암호 체계\r\n- SEED\r\n  - 한국정보보호진흥원의 기술진이 개발한 128비트 및 256비트 대칭 키 블록 암호 알고리즘으로, 미국에서 수출되는 웹 브라우저 보안 수준이 40비트로 제한됨에 따라 128비트 보안을 위해 별도로 개발된 알고리즘\r\n- IDEA(International Data Encrption Algorithm)\r\n  - 스위스에서 1990년 Xuejia Lai, James Messey가 만든 PES를 개량하여, 1991년에 제작된 블록 암호 알고리즘이다. 현재 가장 안전하고 최고라고 여겨지는 알고리즘으로, 블록 초당 177Mbit의 빠른 처리가 가능\r\n\r\n### 공개키(비대칭키) 알고리즘\r\n\r\n- RSA(Ron **R**ivest, Adi **S**hamir, Leonard **A**dleman 세 사람의 성을 따서 RSA 라고 이름이 붙은 암호 방식)\r\n  - 2023년 기준 SSL/TLS에 가장 많이 사용되는 공개키 암호화 알고리즘으로, 소인수분해하기 어려움을 이용한다.\r\n- ELGamal(엘가말 알고리즘)\r\n  - 이산대수 문제의 어려움에 근거해 만든 시스템\r\n  - 디지털 서명, 암호화, 키 교환에 사용될 수 있는 공개키 알고리즘\r\n  - 단점은 타 알고리즘에 비해 가장 느림\r\n\r\n### 해시 알고리즘\r\n\r\n- SHA(Secure Hash Algorithm)\r\n  - 미 국가안보국(NSA)이 설계한 암호학적 해시 함수들의 모음으로, MD5를 수정한 버전\r\n- MD5(최근에는 잘 사용되지 않음)\r\n  - 프로그램이 위변조 되었는지를 확인하는 무결성 검사에 사용되며, 입력받은 메시지를 128비트로 압축하는 방식\r\n- HAS-16\r\n  - 한국의 국산 알고리즘으로, 임의의 입력값을 160비트의 고정된 출력값으로 변환하는 알고리즘\r\n  - SHA-1과 출력값의 길이는 같으며, 512비트 단위가 한 블록이다.\r\n\r\n## 암호 방식에 따른 분류\r\n\r\n![암호 방식에 따른 분류](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-8.png)\r\n\r\n## 서비스 공격 유형의 종류\r\n\r\n**※ 보안의 3요소**\r\n\r\n\u003e 정보보안 3원칙\r\n\r\n- 기밀성\r\n  - 타인에게 노출되면 안된다.\r\n  - 인가된 사용자만 정보 자산에 접근할 수 있다.\r\n  - 방화벽, 암호\r\n- 무결성\r\n  - 타인에게 수정되면 안된다.\r\n  - 시스템 내의 정보는 오직 인가된 사용자가 인가된 방법으로만 수정할 수 있다.\r\n- 가용성\r\n\r\n  - 인가된 사용자에게는 언제든지 사용되어야 한다.\r\n  - 사용자가 필요할 때 데이터에 접근할 수 있는 능력을 말한다.\r\n\r\n- DoS(Denial Of Service, 서비스 거부) : DDoS와 마찬가지로 가용성을 해침\r\n  - Smurf Attack\r\n    - IP, ICMP를 사용하는 공격으로 나의 IP 주소를 속여 다른 IP로 데이터를 전송하여 다른 IP를 소유한 기기에 장애를 일으킨다.\r\n    - ICMP : 인터넷 제어 메시지 프로토콜(Internet Control Message Protocol, ICMP)은 네트워크 내 장치가 데이터 전송과 관련된 문제를 전달하기 위해 사용하는 프로토콜\r\n    - EX : 공격자의 ip가 1인 경우 발신 header의 발신 ip를 2로 변경해 2번 ip를 가진 서버의 가용성을 해치는 경우\r\n  - SYN flooding\r\n    - 직역 : SYN 패킷이 흘러 넘친다.\r\n    - 과도한 SYN 패킷을 서버에 서버에 부하를 일으킨다.\r\n    - ![런잇메이트 이미지](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image.png)\r\n  - UDP 플러딩\r\n    - 대량의 UDP 패킷을 이용하여 대상 호스트의 네트워크 자원을 소모시키는 공격\r\n  - Ping 플러딩\r\n    - 네트워크가 정상적으로 작동하는지 여부를 확인하기 위해 사용하는 Ping Test를, 해커가 해킹을 하기 위한 대상 컴퓨터를 확인하기 위한 방법으로 사용한다.\r\n    - 대상 시스템에 ICMP 패킷을 지속적으로 보내서 대상 시스템이 Request에 응답하느라 다른 일을 하지 못하도록 하는 공격이며, 해당 시스템은 끊임없는 응답에 내부 Queue Counter 자원의 고갈로 서비스 불능에 빠진다.\r\n    - 네트워크에 Over Load를 발생시키는 치명적인 공격이 될 수도 있다.\r\n  - Ping of Death\r\n    - 규정 크기 이상의 ICMP(Internet Control Message Protocol) 패킷으로 시스템을 마비시키는 공격\r\n  - Teardrop Attack\r\n    - 구형 컴퓨터 시스템에서 대량의 데이터를 처리할 때 사용하는 코드에 내재하는 버그를 이용하는 공격 방식으로, 시스템이 모든 비트를 올바른 순서대로 결합하여 정상적으로 이용하지 않고, 비트가 수신될 때까지 기다리기만 하여 결국 비트가 영원히 수신되지 않고 시스템 전체가 마비될 수 있다.\r\n  - Land Attack\r\n    - 출발지 IP와 목적지 IP가 같은 패킷을 만들어 보내는 공격 방법\r\n    - 수신자가 응답을 보낼 때, 목적지 주소가 자기 자신이므로 SYN 신호가 계속 자신의 서버를 돌게 되어 서버의 자원을 고갈시켜 가용성을 파괴한다.\r\n- DDoS(Distributed Denial of Service, 분산 서비스 거부)\r\n  - 피싱(Phishing) : 개인정보(Private Data)를 낚는다(Fishing) 라는 의미의 합성어로, 이메일 또는 메신저를 사용해 신뢰할 수 있는 사람 또는 기업이 보낸 메시지인 거처럼 가장함으로써 중요 정보를 얻어내는 소셜 엔지니어링의 한 종류\r\n  - 파밍(Pharming) : 악성코드에 감염된 PC를 조작해 이용자 자신의 브라우저에 정확한 웹 페이지 주소를 입력해도 가짜 웹 페이지에 접속하게 하여 개인정보를 훔치는 것\r\n  - 스니핑(Sniffing) : 네트워크 상에서 자신이 아닌 다른 사용자들의 패킷 교환을 엿듣는 것\r\n  - 스미싱(Smishing) : 문자 메시지를 이용한 피싱으로, SMS와 피싱의 합성어이다. 신뢰할 수 있는 사람 또는 기업이 보낸 것처럼 가정하여 개인정보를 요구하거나 휴대 전화의 소액 결제를 유도한다.\r\n  - 큐싱(Qshing) : QR코드를 이용한 피싱으로, 사용자를 속이기 위한 진화된 금융사기 수법이다.\r\n  - 랜섬웨어(RansomWare) : 데이터를 암호화하고 암호화된 파일의 잠금 해제를 위해 대금을 요구하는 일종의 멜웨어이다.\r\n  - 키 로거(Key Logger) : 사용자의 키보드를 통해 입력한 내용을 몰래 가로채는 기술이나 행위를 의미한다.\r\n  - SQL 삽입(SQL Injection) : 응용 프로그램 보안 상의 허점을 의도적으로 이용해 악의적인 SQL문을 실행되게 함으로써 DB를 비정상적으로 조작하는 코드 인젝션 공격이다.\r\n  - XSS(Cross Site Scripting) : 웹사이트 관리자가 아닌 자가 웹 페이지에 악성 스크립트를 삽입할 수 있는 취약점이다.\r\n\r\n### 기타 서비스 공격 유형의 종류\r\n\r\n- 무작위 대입 공격(Brute-Force Attack) : 무차별 암호 대입 공격으로 모든 경우의 수를 입력함으로써 해킹을 시도하는 공격 방식\r\n- 스피어 피싱(Spear Phising) : 조직의 특정 개인 또는 그룹을 대상으로 한 피싱 공격의 유형으로, 공격자는 피해자가 알거나 신뢰하는 사람으로 가장해 피해자가 민감한 정보를 유출하거나 멜웨어를 다운로드하거나, 공격자에 대한 지급을 승인하거나 송금하도록 시키는 등의 행위를 하도록 조종한다.\r\n- APT(Advanced Persistent Threat, 지능적 지속 위협) : 지능적인 방법을 사용해 지속적으로 특정 대상을 공격하는 것으로, 하나의 대상을 정해 성공할 때까지 공격을 멈추지 않는 것이 특징이다. 기업이나 기관의 시스템은 보안이 단단해 침투가 어렵기 때문에, 회사 개인 PC를 먼저 장악한 후, 합법적인 권한을 획득해 내부로 들어가는 방법을 주로 사용한다.\r\n- 제로데이(Zero - day) 공격 : 특정 소프트웨어의 패치되거나 공표되지 않은 보안 취약점을 이용한 해킹의 통칭이다.\r\n- 백도어(Back Door) : 정상적인 보안 조치를 우회하여 시스템에 액세스할 수 있는 모든 경로를 의미한다. 소프트웨어는 엔지니어와 개발자가 자체 방어를 우회하여 사용자의 문제를 해결할 수 있도록 코드에 백도어가 내장되어 있는 경우가 많다.\r\n- Rainbow Table Attack : 패스워드 별로 해시 값을 미리 생성해 크래킹 하고자 하는 해시 값을 테이블에서 검색하여 역으로 패스워드를 찾는 방법\r\n- CSRF(Cross Site Request Forgery - 사이트 간 요청 위조) : 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격이다.\r\n- TOCTOU(Time Of Check To Time Of Use) : 두 시점 사이의 타이밍을 노리는 공격이나 그런 공격을 가능하게 하는 버그 유형이다.\r\n\r\n## 스푸핑(Spoofing)\r\n\r\n- IP 스푸핑\r\n  - IP 자체의 보안 취약성을 악용한 것으로 자신의 IP 주소를 속여서 접속하는 공격\r\n  - IP 스푸핑을 통해 서비스 거부 공격(DoS)도 수행 가능하며, 공격 대상 컴퓨터와 서버 사이의 연결된 세션을 끊을 수도 있다.\r\n  - 종단 인증(end point authentication) 같은 방법으로 해결한다.\r\n- DNS 스푸핑\r\n  - 공격대상에게 전달되는 DNS IP 주소를 조작하여 의도치 않는 주소로 접속하는 공격\r\n  - 공격대상은 정상적인 URL을 통해서 접속하지만, 실제로 가짜 사이트로 접속된다.\r\n- ARP 스푸핑\r\n  - MAC 주소를 속여 랜에서의 통신 흐름을 왜곡시키는 공격.\r\n  - 공격 대상 컴퓨터로부터 정보를 빼낸다.\r\n\r\n## 블록암호 알고리즘\r\n\r\n- AES\r\n  - 128bit 평문을 128/192/256bit로 암호화\r\n  - 키 크기에 따라 10/12/14회 Round 수행\r\n  - 1997년 NIST에 의해 제정\r\n  - 레인달(Rijndeal)에 기반한 암호화 방식\r\n  - SPN 암호 방식을 사용한다.\r\n- SEED\r\n  - 순수 국내기술로 개발한 128비츠 및 256비트 대칭키 블록 암호 알고리즘\r\n- ARIA\r\n  - 국가 보안 기술 연구소(NSRI) 필두로 학계, 국가 정보원 등의 암호 기술 전문가들이 개발한 국가 암호화 알고리즘\r\n  - AES 알고리즘과 똑같이 128/192/256비트 암호화키를 지원한다.\r\n  - SPN 암호 방식을 사용한다.\r\n- IDEA\r\n  - 1990년 스위스에서 만들어진 PES를 개량하여 만들어진 블록 암호 알고리즘\r\n  - 키길이가 128bit, 블록길이가 64bit\r\n  - Feistel 방식과 SPN의 중간형태 구조\r\n\r\n## 보안 솔루션\r\n\r\n- 방화벽(Firwall)\r\n  - 네트워크 간에 전송되는 정보를 선별하는 기능을 가진 침입 차단 시스템\r\n- 웹 방화벽(Web Firewall)\r\n  - 웹 기반 공격을 방어할 목적으로 만들어진 웹서버 특화 방화벽\r\n- 침입탐지 시스템(IDS - Intrusion Detection System)\r\n  - 컴퓨터 시스템의 비정상적인 사용, 오용 등을 실시간으로 탐지하는 시스템\r\n  - 이상탐지, 오용탐지\r\n- 침입방지 시스템(IPS - Intrusion Prevention System)\r\n  - 방화벽과 침입탐지 시스템을 결합한 것\r\n- 데이터유출방지(DLP - Data Leakage/Loss Prevention)\r\n  - 내부 정보의 유출을 방지하기 위한 보안솔루션\r\n- NAC(Network Access Control)\r\n  - 네트워크에 접속하는 내부 PC의 MAC 주소(고유랜카드주소)를 IP관리 시스템에 등록한 후 일관된 보안관리 기능을 제공하는 보안솔루션\r\n- ESM(Enterprise Security Management)\r\n  - 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합관리 하는 보안 솔루션\r\n\r\n## SIEM(Security Information and Event Management) 보안\r\n\r\n\u003e SIEM란? 소프트웨어 제품 및 서비스가 보안 정보 관리와 보안 이벤트 관리를 결합하는 컴퓨터 보안의 한 분야로, 애플리케이션 및 네트워크 하드웨어에서 생성된 보안 경고에 대한 실시간 분석을 제공한다. 빅데이터 수준의 데이터를 장시간 심층 분석한 인덱싱 기반이며 주요기능은 데이터 통합, 상관관계, 알림, 대시보드 등이 있다.\r\n\r\n# 네트워크\r\n\r\n## IPv4/IPv6 전환 기술\r\n\r\n|                                 |                                                                                                                    |\r\n| :-----------------------------: | ------------------------------------------------------------------------------------------------------------------ |\r\n|     듀얼 스택 (Dual Stack)      | IPv4/IPv6를 동시에 지원 (IPv4/IPv6 패킷을 주고받을 수 있음)                                                        |\r\n|       터널링 (Tunneling)        | 두 IPv6 네트워크 간에 터널을 이용하는 기술 (IPv4/IPv6 호스트와 라우터에서 IPv6 패킷을 IPv4 패킷에 캡슐화하여 전송) |\r\n| 주소 변환 (Address Translation) | IPv4와 IPv6 간에 주소를 변환하여 두 버전을 연동                                                                    |\r\n\r\n# 프로토콜 및 기타\r\n\r\n## 라우팅 프로토콜\r\n\r\n![라우팅 프로토콜](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-9.png)\r\n\r\n## RIP(Routing Information Protocol)\r\n\r\n- 가장 널리 사용되는 라우팅 프로토콜로, 최단 경로 탐색에 Bellman-Ford 알고리즘이 사용된다.\r\n- 소규모 동종의 자율 시스템 내에서 효율적인 방법이며, 최대 홉 수가 15로 제한된다.\r\n\r\n## EAI(Enterprise Architecture Integration - 기업 어플 통합) 구축 유형\r\n\r\n|          유형          |                                                                         설명                                                                         |\r\n| :--------------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------: |\r\n|     point to point     |         중간에 미들웨어를 두지 않고 각 애플리케이션 간 직접 연결 솔루션 구매 없이 통합, 상대적으로 저렴하게 통합 가능 (변경, 재사용 어려움)          |\r\n|      hub \u0026 spoke       |      단일 접점이 허브 시스템을 통해 데이터를 전송하는 중앙 집중적 방식 - 모든 데이터 전송 보장, 확장 및 유지 보수 용이 (허브 장애 시 전체 영향)      |\r\n| Message Bus (ESB 방식) | 애플리케이션 사이 미들웨어(버스)를 두어 처리하며 미들웨어를 통한 통합함. 어댑터가 각 시스템과 버스를 두어 연결하므로 뛰어난 확장성, 대용량 처리 가능 |\r\n|         Hybrid         |                                          유연한 통합 작업이 가능 (표준 통합 기술, 데이터 병목 현상 최소화)                                           |\r\n\r\n## 라우팅 영역에 따른 분류\r\n\r\n|                                 |                                                        |\r\n| :-----------------------------: | ------------------------------------------------------ |\r\n| IGP (Interior Gateway Protocol) | AS(Autonomous System) 내부 라우터 간 (RIP, OSPF, IGRP) |\r\n| EGP (Exterior Gateway Protocol) | AS(Autonomous System) 외부 라우터 상호간 (EGP, BGP)    |\r\n\r\n### IGP(Interior Gateway Protocol)\r\n\r\n- RIP(Routing Information Protocol - 라우팅 정보 프로토콜)\r\n  - RIP는 경유할 가능성이 있는 라우터를 홉수로 수치화하여, DVA(Distance Vector Algorithm - 거리 벡터 알고리즘)라는 알고리즘으로 인접 호스트와의 경로를 동적으로 교환하는 일이다.\r\n  - **홉 카운트의 제한은 15개**로 제한한다.\r\n- OSPF(Open Shortest Path First - 동적 라우팅 프로토콜)\r\n  - 최단 경로 탐색에 다익스트라 알고리즘 기반 방식을 사용하며, 최적 경로 선택을 위해 홉수, 대역폭, 지연시간 등을 고려한다.\r\n  - 링크상태 변화시에만 라우팅정보를 전송한다.\r\n- IGRP(Internet Gateway Routing Protocol - 인터넷 게이트웨이 라우팅 프로토콜)\r\n  - RIP의 단점을 보완하기 위한 프로토콜로, 최대 홉 수를 255로 늘렸다.\r\n\r\n### EGP\r\n\r\n- EGP(Exterior Gateway Protocol - 게이트웨이 역외 프로토콜)\r\n- 다른 그룹과 라우팅 정보를 교환하는 프로토콜\r\n- 시스템 사이에 경로 설정 정보 등을 교환하기 위해 사용하는 프로토콜\r\n- 다른 도메인 사이에 라우팅 시 정리된 관리가 거의 없고 많은 경우에 신용도가 매우 낮아 빠른 수행보다는 보안과 제어가 EGP의 본래 목적이다.\r\n- BGP(Boarder Gateway Protocol - 종속 게이트웨이 프로토콜)\r\n  - AS 간에 라우팅 정보를 전달하는데 사용되고 있는 대규모 라우팅 프로토콜\r\n  - 인터넷 코어 라우터, 중간 ISP 라우터, ISP CPE(Customer Premises Equipment) 또는 소규모 개인 BGP 네트워크의 라우터 등 다양한 토폴로지 설정으로 배치될 수 있다.\r\n  - 작동 원리 =\u003e 통신에 TCP 포트 179를 사용한다. Path-Vector 프로토콜로 간주되며 대상에 대한 전반적인 경로 설명을 포함한다. iBGP은 인접 항목이 동일한 AS에 있고eBGP는 인접 항목이 다른 AS에 있다.\r\n\r\n## RARP\r\n\r\n- RARP(Reverse Address Resolution Protocol - 역순 주소 결정 프로토콜)\r\n  - IP호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우, 서버로부터 IP주소를 요청하기 위해 사용한다.\r\n\r\n## AC와 DAC\r\n\r\n- AC(Access Control - 접근 통제)\r\n  - 디렉토리나 파일, 네트워크 소켓 같은 시스템 자원을 적절한 권한을 가진 사용자나 그룹이 접근하고 사용할 수 있게 통제하는 것\r\n- DAC(Discretionary Access Control - 임의 접근 통제)\r\n  - 시스템 객체에 대한 접근을 사용자 또는 그룹의 신분을 기준으로 제한하는 방법\r\n  - 사용자나 그룹이 객체의 소유자라면 다른 주체에 대해 이 객체에 대한 접근 권한을 설정할 수 있다.\r\n- MAC(Mandatory Access Control - 강제 접근 통제)\r\n  - 미리 정해진 정책과 보안 등급에 의거하여 주체에게 허용된 접근 권한과 객체에게 부여된 허용 등급을 비교하여 접근을 통제하는 모델\r\n  - 높은 보안을 요구하는 정보는 낮은 보안 수준의 주체가 접근할 수 없으며, 소유자라고 할지라도 정책에 어긋나면 객체에 접근할 수 없으므로 강력한 보안을 제공한다.\r\n\r\n## WSDL (Web Service Description Language)\r\n\r\n\u003e WSDL은 웹 서비스 기술언어 또는 기술된 정의 파일의 총징으로 XML로 기술된다. 웹 서비스의 구체적 내용이 기술되어 있어 서비스 제공 장소, 서비스 메시지 포맷, 프로토콜 등이 기술된다.\r\n\r\n## SOAP (Simple Object Access Protocol)\r\n\r\n\u003e SOAP는 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. SOAP는 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다.\r\n\r\n## IPC(Inter-Process Communication - 프로세스 간 통신)\r\n\r\n\u003e IPC란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다. IPC는 마이크로커널과 나노커널의 디자인 프로세스에 매우 중요하다. 마이크로커널은 커널이 제공하는 기능의 수를 줄여준다.\r\n\r\n## 파일의 구조\r\n\r\n- 순차 파일(Sequential File, 순서 파일)\r\n  - 순차 파일은 레코드를 논리적인 처리 순서에 따라 연속된 물리적 공간으로 기록하는 것\r\n- 직접 파일(Direct File)\r\n  - 파일을 구성하는 레코드를 임의의 물리적 저장공간에 기록하는 것\r\n- 색인 순차 파일(Indexed Sequential File)\r\n  - 순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 상태\r\n\r\n## 빅데이터 관련 용어\r\n\r\n- Big Data\r\n  - 대량의 정형 또는 비정형 데이터 집합 및 이러한 데이터로부터 가치를 추출하고 결과를 분석하는 기술\r\n- Hadoop (하둡)\r\n  - 오픈 소스 기반 분산 컴퓨팅 기술\r\n  - 현재 정형/비정형 빅 데이터 분석에 가장 선호되는 솔루션\r\n- NoSQL\r\n  - 전통적인 관계형 데이터베이스 RDBMS와 다르게 설계된 비관계형 데이터베이스\r\n  - 대규모의 유연한 데이터 처리를 위해서 적합\r\n- Data Mining(데이터 마이닝)\r\n  - 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 것\r\n- 데이터 웨어하우스\r\n  - 기간 시스템의 데이터베이스에 축적된 데이터를 공통의 형식으로 변환하여 관리하는 데이터베이스\r\n- 데이터 마트\r\n  - 데이터의 한 부분으로서 특정 사용자가 관심을 갖는 데이터들을 담은 비교적 작은 규모의 데이터 웨어하우스\r\n- OLAP\r\n  - 이용자가 직접 데이터베이스를 검색, 분석해서 문제점이나 해결책을 찾는 분석형 애플리케이션 개념\r\n- Mashup\r\n  - 웹에서 제공하는 정보 및 서비스를 이용하는 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술\r\n\r\n## 컴퓨터 환경\r\n\r\n1. 온-프레미스\r\n   - 온-프레미스 컴퓨팅은 기업이나 조직이 자체적으로 하드웨어, 소프트웨어 등의 모든 컴퓨팅 환경을 구축하는 것으로, 전통적인 서버나 데이터 센터를 의미하기도 한다.\r\n   - 초기에 큰 투자가 필요하지만, 서비스 제공자인 아마존, 구글 등의 외부 사업자에게 종속될 우려가 있는 클라우드 컴퓨팅과는 달리 시스템의 모든 설정을 사용자의 필요에 따라 제어핧 수 있다는 장점이 있다.\r\n2. 클라우드\r\n   - 클라우드 컴퓨팅은 사용자의 직접적인 활발한 관리 없이 특히, 데이터 스토리지(클라우드 스토리지)와 컴퓨팅 파워와 같은 컴퓨터 시스템 리소스를 필요로 할 때 바로 제공(on-demand availability)하는 것을 말한다.\r\n   - 일반적으로는 인터넷 기반 컴퓨팅의 일종으로 정보를 자신의 컴퓨터가 아닌 클라우드에 연결된 다른 컴퓨터로 처리하는 기술을 의미한다.\r\n   - 공유 컴퓨터 처리 자원과 데이터를 컴퓨터와 다른 장치들에 요청 시 제공해준다.\r\n   - 구성 가능한 컴퓨팅 자원(ex. 컴퓨터 네트워크, 데이터베이스, 서버, 스토리지, 애플리케이션, 서비스, 인텔리전스)에 대해 어디서나 접근할 수 있는, 주문형 접근을 가능케하는 모델이며, 최소한의 관리 비용으로 빠르게 릴리스를 가능하게 한다.\r\n3. 하이브리드\r\n   - 하이브리드 클라우드는 하나 이상의 프라이빗 클라우드와 하나 이상의 퍼블릭 클라우드의 조합을 사용하는 클라우드 컴퓨팅 모델이다.\r\n   - 이러한 클라우드 조합이 함께 작동하여 유연하게 혼합된 클라우드 컴퓨팅 서비스를 제공한다.\r\n   - 인프라와 운영을 일관되게 확장하여 두 환경 모두에서 애플리케이션 워크로드를 관리하는 단일 운영 모델을 제공하므로, 비즈니스 요구 사항에 따라 프라이빗 클라우드와 퍼블릭 클라우드 간에 워크로드의 원활한 마이그레이션이 가능하다.\r\n\r\n## RAID(Redundant Array of Inexpensive/Independent Disk - 복수 배열 저가/독립 디스크) 형태\r\n\r\n- RAID 1 (미러링)\r\n  - 두 개 이상의 디스크를 미러링을 통해 하나의 디스크처럼 사용\r\n- RAID 2 (해밍코드)\r\n  - 오류 정정을 위한 해밍코드를 사용하는 방식\r\n- RAID 3 (1:M)\r\n  - 하나의 디스크를 패리티(Parity) 정보를 위해 사용하고 나머지 디스크에 데이터를 균등하게 분산 저장\r\n- RAID 4 (RAID 3 upgrade)\r\n  - RAID 3과 같은 방식이나, 블록 단위로 분산 저장한다.\r\n- RAID 5 (3 이상)\r\n  - 3개 이상의 디스크를 붙여서 하나의 디스크처럼 사용하고 각각의 디스크에 패리티 정보를 가지고 있는 방식\r\n- RAID 6 ( 1 : 2(분산) )\r\n  - 하나의 패리티를 두 개의 디스크에 분산 저장하는 방식\r\n\r\n## OSI7 참조 모델\r\n\r\n![OSI7](https://github.com/CS-AL-SW/SW/raw/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84/%ED%82%A4%EC%9B%8C%EB%93%9C/%EC%A2%85%ED%95%A9%ED%82%A4%EC%9B%8C%EB%93%9C/image-6.png)\r\n\r\n## WAF(Web application firewall - 웹 애플리케이션 방화벽)\r\n\r\n- 웹 서버로 들어오는 웹 트래픽을 검사하여 악의적인 코드나 공격 유형이 포함된 웹 트래픽을 차단해 주는 방화벽으로, SQL Injection이나 XSS 등과 같은 웹 공격을 탐지하고 차단한다.\r\n- 일반 방화벽과는 달리 패킷의 페이로드를 직접 확인하기 때문에 외부의 공격뿐만 아니라 사전에 발견하지 못했던 내부의 위험 요소에 대한 방어가 가능하다.\r\n\r\n## VDW(Virtual Data Warehouse - 가상 데이터 웨어하우스)\r\n\r\n- 물리적으로 데이터 웨어하우스를 구축하지 않아도 실제 구축한 것과 같은 가상 시스템으로, 비교적 낮은 비용으로 빠른 시간 안에 데이터를 분석할 수 있고, 데이터의 추출 및 로딩 과정이 생략되어 실제 데이터 웨어하우스를 구축하는 것에 비해 노력과 시간이 절감된다.\r\n- 하지만 온라인 트랜잭션 처리(OLTP) 작업이 대량으로 수행되거나 일정 시간 대에 집중되는 경우에는 시스템의 성능이 저하되거나 신뢰성 및 안정성에 문제가 발생할 수 있다.\r\n\r\n## 프로토콜 주요 포트 번호\r\n\r\n[참조링크](https://ko.wikipedia.org/wiki/TCP/UDP%EC%9D%98_%ED%8F%AC%ED%8A%B8_%EB%AA%A9%EB%A1%9D)\r\n\r\n- FTP(20) : File Transfer Protocol(파일 전송 프로토콜) - 데이터 포트\r\n- FTP(21) : File Transfer Protocol(파일 전송 프로토콜) - 제어 포트\r\n- SSH(22) : Secure SHell 원격지 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜\r\n- Telnet(23) : 멀리 떨어져 있는 컴퓨터에 접속해 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스로, 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널(Virtual Terminal) 기능을 수행한다.\r\n- SMTP(25) : Simple Mail Transfer Protocol(이메일 전송 프로토콜)\r\n- HTTP(80) : Hyper Text Transfer Protocol(웹 페이지 전송 프로토콜)\r\n\r\n# C언어 및 기타\r\n\r\n## C 비트연산자(연산자 \u0026, |, ^, ~, \u003c\u003c, \u003e\u003e, and, or, xor, 비트 반전, 비트 이동)\r\n\r\n| 연산자 |                                                                          연산자의 기능                                                                           |\r\n| :----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------: |\r\n|   \u0026    |                                                      비트단위로 AND 연산을 한다. (논리합 - 둘 다 1이어야 1)                                                      |\r\n|   \\|   |                                                    비트단위로 OR 연산을 한다. (논리곱 - 둘 중 하나가 1이면 1)                                                    |\r\n|   ^    |                                              비트단위로 XOR 연산을 한다. (두 개의 비트가 서로 다른 경우에 1을 반환)                                              |\r\n|   ~    |                                       단항 연산자로서 피연자의 모든 비트를 반전시킨다 . (00001111 =\u003e 11110000) - NOT 연산                                        |\r\n|   \u003c\u003c   |                                피연산자의 비트 열을 왼쪽으로 이동시킨다. (00001100 \u003c\u003c 2 == 00110000, 00001100 \u003c\u003c 3 == 01100000 )                                 |\r\n|   \u003e\u003e   | 비연산자의 비트 열을 오른쪽으로 이동시킨다. (00011000 \u003e\u003e 2 == 00000110, 00011000 \u003e\u003e 3 == 00000011 ) 단 시프트 연산 대상이 음수인 경우 CPU에 따라 달라질 수 있다. |\r\n\r\n참조 :\r\n\r\n[Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/%EC%8B%A4%EA%B8%B0%EB%8C%80%EB%B9%84)\r\n\r\n[TTA 정보통신 용어사전](https://terms.tta.or.kr/)\r\n\r\n[위키백과](https://ko.wikipedia.org/)\r\n\r\n[유튜브 홍달쌤](https://www.youtube.com/@HeungSsaem)\r\n\r\n[런잇메이트 블로그](https://runit-mate.tistory.com/)\r\n"},{"title":"sw first test5","description":"정보처리기사 필기(5) - 정보처리시스템 구축 관리","category":"sw","keyword":"정보처리기사, 정처기, 필기, 정보처리시스템 구축 관리","date":"2023-12-28","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 소프트웨어 개발 방법론 활용\r\n\r\n### 소프트웨어 개발 생명주기 모형(SDLC - Software Development Life Cycle Model)\r\n\r\n- 소프트웨어 개발 조직이 담당하는 작업 종류와 순서, 그리고 각 단계에서 생성되는 결과물을 정리한 것이다.\r\n- 소프트웨어 프로세스 모형이라고도 한다.\r\n- 소프트웨어의 종류, 시스템의 규모, 난이도, 신뢰도, 조직의 규모 등에 따라 적합한 생명주기 모형이 다르다.\r\n- 소프트웨어 생명주기 모형에 따라 소프트웨어의 품질을 높이고, 개발 기간과 비용을 줄일 수 있다.\r\n- 소프트웨어 생명주기 모형에는 구축 및 수정 모형, 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 등이 있다.\r\n\r\n### 프로토타입 모형(Prototype Model)\r\n\r\n- 실제 개발될 소프트웨어에 대한 시제품(Prototype)을 만들어 최종 결과물을 예측하는 모형이다.\r\n- 요구 수집, 빠른 설계, 프로토타입 구축, 고객 평가, 프로토타입 조정, 구현의 단계를 통해 소프트웨어를 개발하는 모형이다.\r\n- 최종 결과물이 만들어지기 전에 의뢰자가 최종 결과물의 일부 또는 모형을 볼 수 있다.\r\n- 발주자(의뢰자)나 개발자 모두에게 공동의 참조 모델을 제공한다.\r\n- 구축하고자 하는 시스템의 요구사항이 불명확한 경우 가장 적절하게 적용될 수 있다.\r\n- 사용자 요구사항을 정확하게 파악하고 충실히 반영할 수 있다.\r\n- 개발 단계 안에서 유지보수가 이루어지는 것으로 볼 수 있다.\r\n\r\n### 폭포수 모형(Waterfall Model)\r\n\r\n- 보헴(Boehm)이 제안한 고전적 생명주기 모형으로, 선형 순차적 모형이라고도 한다.\r\n- 타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수의 단계를 통해 소프트웨어를 개발하는 모형이다.\r\n- 순차적인 접근 방법을 이용하며, 단계적 정의와 산출물이 명확하다.\r\n- 각 단계의 결과가 확인되어야지만 다음 단계로 넘어간다.\r\n- 개발 중 발생한 요구사항은 반영하기 어렵다.\r\n- 가장 오래된 모형으로 모형의 적용 경험과 성공 사례가 많다.\r\n\r\n### 나선형 모형(Spiral Model)\r\n\r\n- Boehm이 제시하였으며, 반복적인 작업을 수행하는 모형으로 점증적 모형, 집중적 모형이라고도 한다. 완성도 높은 소프트웨어를 만들 수 있다.\r\n- 여러 번의 개발 과정을 거쳐 완벽한 최종 소프트웨어를 개발하는 점진적 모형이다.\r\n- 가장 큰 장점인 위험 분석 단계에서 기술과 관리의 위험 요소들을 하나씩 제거해 나감으로써 위험성 평가에 크게 의준하기 때문에 이를 발견하지 않으면 문제가 발생할 수 있다.\r\n- 대규모 시스템의 소프트웨어 개발에 적합하다.\r\n\r\n#### 나선형 모형의 개발 단계\r\n\r\n1. 계획 수립(Planning) : 위험 요소와 타당성을 분석하여 프로젝트의 추진 여부를 결정한다.\r\n2. 위험 분석(Risk Analysis) : 개발 목적과 기능 선택, 제약 조건 등을 결정하고 분석한다.\r\n3. 개발 및 검증(Development) : 선택된 기능을 수행하는 프로토타입을 개발한다.\r\n4. 고객 평가(Evaluation) : 개발된 프로토타입을 사용자가 확인하고 추가 및 수정될 요구사항이 있으면 이를 반영한 개선 프로토타입을 만든다.\r\n\r\n# 소프트웨어 개발 방법론\r\n\r\n- 소프트웨어 개발 생명주기에 소프트웨어 공학 원리를 적용한 것으로 소프트웨어 개발 전 과정에 지속적으로 작용할 수 있는 방법, 절차, 기법 등을 의미하며, 시스템 개발 주기라고도 한다.\r\n- 소프트웨어 개발 과정을 정리하고 표준화하여 프로그래머 개인이 개발 과정에서의 일관성을 유지하고 프로그래머들 간의 효과적인 협업이 이루어질 수 있게 한다.\r\n\r\n### 구조적 방법론(Structured Development Methodolohy)\r\n\r\n- 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 체계적인 방법론이다.\r\n- 요구사항 분석, 구조적 분석, 구조적 설계, 구조적 프로그래밍 단계로 구성된다.\r\n- 쉽게 이해할 수 있고 검증할 수 있는 프로그램의 부호를 생성하는 것이 목적이다.\r\n- 1970년대까지 가장 많이 적용된 방법론이다.\r\n- 시스템 분석을 위해 데이터 흐름 다이어그램(Data Flow Diagram)이 주로 사용된다.\r\n- 시스템 설계를 위해 구조도(Structured Chart) 기획, 분석, 설계, 구축하는 데이터 중심의 방법론이다.\r\n- 구조적 방법론의 거시적 관점 부재에서 등장하였다.\r\n- 자료에 중점을 두어 자료와 프로세스를 별개의 작업으로 병행 진행한 후 서로 간의 오류를 상관 분석하여 검증한다.\r\n- 정보 전략 계획(ISP), 업무 영역 분석(BAA), 업무 시스템 설계(BSD), 시스템 구축(SC) 단계로 구성된다.\r\n\r\n### 객체지향 방법론(Object-oriented Engineering Methodolohy)\r\n\r\n- 분석, 설계, 개발 단계에 객체지향 기법을 활용하는 방법론이다.\r\n- 구조적 프로그래밍 기법의 한계와 소프트웨어 개발의 위기에서 등장하였다.\r\n- 요구분석, 설계, 수현, 테스트 및 검증 단계로 구성된다.\r\n- 객체지향의 기본 원칙은 캡슐화(Encapsulation), 정보 은닉(Information Hiding), 추상화(Abstraction), 상속(Inheritance), 다형성(Polymorphism)이다.\r\n- 시스템 분석을 위해 유스케이스 다이어그램(UseCase Diagram)이 주로 사용된다.\r\n- 시스템 설계를 위해 시퀀스 다이어그램(Sequence Diagram)이 주로 사용된다.\r\n\r\n### 컴포넌트 기반 개발 방법론(CBD : Component Based Development)\r\n\r\n- 재사용이 가능한 컴포넌트의 개발 또는 상용 컴포넌트들을 조합하여 애플리케이션 개발 생산성과 품질을 높이고, 시스템 유지보수 비용을 최소화할 수 있는 개발 방법 프로세스이다.\r\n- 컴포넌트 단위의 개발 및 조립을 통해 정보 시스템의 신속한 구축, 변경, 확장의 용이성과 타 시스템과의 호환성을 달성하고자 하는 소프트웨어 공학 프로세스, 방법론 및 기술의 총체적 개념이다.\r\n\r\n#### CBD 방법론의 특징\r\n\r\n- 개발 준비, 분석, 설계, 구현, 테스트, 전개, 인도 순으로 반복, 점진적 개발 프로세스를 제공하고, 시스템 설계를 위해 컴포넌트 설계서가 주로 사용된다.\r\n- 컴포넌트(Component)는 DB와 SW의 모듈 단위로, 재사용이 가능하다.\r\n- 시스템 분석을 위해 유스케이스 다이어그램(UseCase Diagram)이 주로 사용된다.\r\n- 개발 기간 단축으로 인한 생산성이 향상되며 새로운 기능 추가가 쉬워 확장성이 높다.\r\n\r\n### 소프트웨어 재사용(Software Reuse)\r\n\r\n- SW 개발의 품질과 생산성을 높이기 위한 방법으로, 이미 개발되어 안정화된 SW의 전체 혹은 일부분을 다른 SW 개발이나 유지에 사용하는 것이다.\r\n- 기존에 개발된 SW와 경험, 지식 등을 새로운 SW에 적용한다.\r\n- 클래스, 객체 등의 소프트웨어 요소는 소프트웨어 재사용성을 크게 향상했다.\r\n- 소프트웨어 부품(모듈)의 크기가 작고 일반적인 설계일수록 재사용률이 높다.\r\n  - 합성 중심(Composition-Based)\r\n    - 전자칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법으로, 블록 구성 방법이라고도 한다.\r\n  - 생성 중심(Generation-Based)\r\n    - 추상화 형태로 쓰여진 명세를 구체화하여 프로그램을 만드는 방법으로, 패턴 구성 방법이라고도 한다.\r\n\r\n# 비용 산정 모델\r\n\r\n- 전문가 감정 기법, 델파이(Delphi) 기법, LOC(Line Of Code) 기법, COCOMO(COnstructive CostMOdel) 모델, Putnam 모델, 기능 점수(FP: Functional Point) 등이 있다.\r\n\r\n### 전문가 감정 기법\r\n\r\n- 개발 조직 내에 경험이 많은 2인 이상의 전문가에게 비용 산정을 의뢰하는 기법이다.\r\n- 의뢰자의 신뢰도가 높고 편리하게 비용을 산정할 수 있다.\r\n- 과거 프로젝트와의 유사성이 낮을 수 있다.\r\n- 전문가에 따라 감정의 편차가 클 수 있다.\r\n\r\n### 델파이(Delph) 기법\r\n\r\n- 산정 요원과 조정자에 의해 산정하는 기법이다.\r\n- 전문가가 독자적으로 감정할 때 발생할 수 있는 편차를 줄이기 위해 단계별로 전문가들의 견해를 조정자가 조정하여 최종 견적을 결정한다.\r\n- 유사한 프로젝트 경험을 가진 전문가 집단을 구성하여 규모, 공수, 비용의 산정 의견을 구한다.\r\n- 의견 일치가 이뤄지지 않을 경우 의견의 근거를 익명으로 집단 내에 배포하고 자신들의 산정을 수정할 수 있도록 한다.\r\n\r\n### LOC(Line of Code) 기법 ★★★\r\n\r\n- 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법이다.\r\n\r\n```\r\n예측치 = a + (4 X C) + b / 6 (단 a는 낙관치, b는 비관치, c는 기대치임)\r\n```\r\n\r\n- ex. 규모 추정이 a: 60, b: 200, c:100인 경우 LOC는 다음과 같다.\r\n\r\n```\r\nLOC = 60 + (4 X 100) + 200 / 6 = 660 / 6 =  110\r\n```\r\n\r\n- 개발 기간 = 예측된 LOC / (개발자 수 X 1인달 월 평균 생산 LOC)\r\n\r\nLOC 기법에 의해 예측된 총 라인 수가 36,000라인, 개발에 참여할 프로그래머가 6명, 프로그래머들의 평균 생산성이 월간 300라인일 때 개발에 소요되는 기간은 아래와 같다.\r\n\r\n```\r\n개발 기간 = 36,000 / (6 X 300)\r\n         = 36,000 / 1,800\r\n        = 20[개월]\r\n```\r\n\r\n# 프레임워크\r\n\r\n### 소프트웨어 프레임워크(Framework)의 개념\r\n\r\n- 비슷한 유형의 응용 프로그램들을 위해 재사용이 가능한 아키텍처와 협력하는 소프트웨어 산출물의 통합된 집합이다.\r\n- 특정 클래스의 재사용뿐만 아니라 응용 프로그램을 위한 핵심 아키텍처를 제공하여 설계의 재사용을 지원한다.\r\n\r\n### 소프트웨어 개발 프레임워크의 개념\r\n\r\n- 소프트웨어 개발을 도와주는 재사용이 가능한 클래스와 패턴의 집합이다.\r\n- 소프트웨어 개발의 효율성을 높이고 소프트웨어 품질을 높이기 위한 반제품 성격의 소프트웨어이다.\r\n- 소프트웨어의 틀과 구조를 결정하고, 이를 바탕으로 개발된 개발자의 코드를 제어한다.\r\n\r\n#### 소프트웨어 개발 프레임워크 적용 시 이점\r\n\r\n- 개발 용이성\r\n  - 공통 기능은 프레임워크가 제공한다.\r\n  - 패턴 기반 개발과 비즈니스 로직에만 집중한 개발이 가능하다.\r\n- 시스템 복잡도 감소\r\n  - 시스템의 복잡한 기술은 프레임워크에 의해 숨겨진다.\r\n  - 미리 잘 정의된 기술 셋을 적용할 수 있다.\r\n- 이식성\r\n  - 플랫폼 연동을 프레임워크가 제공한다.\r\n  - 플랫폼의 독립적인 개발이 가능하다.\r\n- 품질 보증\r\n  - 검증된 개발 기술과 패턴에 따른 개발이 가능하다.\r\n  - 개발자의 경험과 능력 차이를 줄여준다.\r\n- 운영 용이성\r\n  - 소프트웨어 변경이 용이하다.\r\n  - 비즈니스 로직 및 아키텍처 파악이 용이하다.\r\n- 개발 코드 최소화\r\n  - 공통 컴포넌트와 서비스를 활용한다.\r\n  - 반복적인 코드 개발을 최소화한다.\r\n- 변경 용이성\r\n  - 잘 구조화된 아키텍처를 적용한다.\r\n  - 플랫폼에 독립적이다.\r\n- 설계 및 코드의 재사용성\r\n  - 프레임워크의 서비스와 패턴을 재사용한다.\r\n  - 이미 개발된 컴포넌트를 재사용한다.\r\n\r\n### 스프링 프레임워크(Spring Framework)\r\n\r\n- 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크이다.\r\n- 동적인 웹 사이트 개발을 위해 여러 가지 서비스를 제공하고 있다.\r\n- 전자정부 표준 프레임워크 기반 기술로 사용된다.\r\n- 스프링 프레임워크의 주요 모듈\r\n  - 제어 반전 컨테이너\r\n  - 관점 지향 프로그래밍 프레임워크\r\n  - 데이터 액세스 프레임워크\r\n  - 트랜잭션 관리 프레임워크\r\n  - 모델 - 뷰 - 컨트롤러(MVC) 패턴\r\n  - 배치 프레임워크\r\n\r\n### 전자정부 표준 프레임워크\r\n\r\n- 공공부문 정보화 사업 시 플랫폼별 표준화된 개발 프레임워크를 말한다.\r\n- 공공기관의 웹 서비스 개발 시 사용을 권장하고 있다.\r\n- 전자정보 표준 프레임워크 적용 시 기대효과\r\n  - 전자정부 서비스 품질 향상\r\n  - 정보화 투자 효율성 향상\r\n  - 국가 정보화 투자 효율성 재고\r\n  - 중소 SI 업체 경쟁력 확보\r\n  - 선진 국가정보화 추진 기반 환경 재고\r\n\r\n### 닷넷 프레임워크(.NET Framework)\r\n\r\n- Microsoft사에서 개발한 윈도우 프로그램 개발 및 실행 환경이다.\r\n- 네트워크 작업, 인터페이스 등의 많은 작업을 캡슐화하였고, 공통 언어 런타임(CLR : Common Language Runtime) 가상 머신 위에서 작동한다.\r\n- 오픈소스 버전으로 닷넷 코어가 있다.\r\n\r\n# 네트워크 구성\r\n\r\n### 성형(Star Topology)\r\n\r\n- 중앙에 호스트 컴퓨터(Host Computer)가 있고 이를 중심으로 터미널(Terminal)들이 연결되는 중앙 집중식의 네트워크 구성 형태이다.\r\n- 중앙 컴퓨터와 직접 연결되어 응답이 빠르고 통신 비용이 적게 소요되지만, 중앙 컴퓨터에 장애가 발생하면 전체 시스템이 마비되는 분산 시스템의 위상 구조이다.\r\n\r\n```\r\n            단말기\r\n    단말기 \\   |   / 단말기\r\n            중계기\r\n    단말기 /   |   \\ 단말기\r\n            단말기\r\n\r\n```\r\n\r\n### 링형(Ring Topology)\r\n\r\n- 서로 이웃한 컴퓨터와 노드끼리 연결한 네트워크 구성 형태이다.\r\n- 각 노드가 공평한 서비스를 받으며, 전송 매체와 노드의 고장 발견이 쉽다.\r\n- 데이터가 한 방향으로 전송되기 떄문에 충돌(Collision) 위험이 없다.\r\n\r\n```\r\n        단말기 ↘\r\n      ↗        단말기\r\n단말기          ↙\r\n      ↖단말기\r\n```\r\n\r\n### 버스형(Bus Topology)\r\n\r\n- 한 개의 통신 회선에 여러 개의 노드가 연결된 형태이다.\r\n- 한 사이트의 고장은 나머지 사이트 간의 통신에 아무런 영향을 주지 않는다.\r\n- 네트워크 트래픽이 많을 경우 네트워크 효율이 떨어진다.\r\n\r\n```\r\n단말기  단말기  단말기  단말기\r\n   |      |      |       |\r\nㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ\r\n```\r\n\r\n### 트리형(Tree Topology)\r\n\r\n- 하나의 노드에 여러 개의 노드를 연결한 네트워크 구성 형태로 네트워크 관리가 용이하다.\r\n- 각 노트가 계층적으로 구성되어 있어 계층형 또는 분산형이라고도 한다.\r\n\r\n```\r\n          단말기\r\n        /       \\\r\n   단말기         단말기\r\n  /      \\      /       \\\r\n단말기  단말기  단말기  단말기\r\n```\r\n\r\n### 망형(Mesh Topology)\r\n\r\n- 모든 컴퓨터와 노드들이 서로 연결된 네트워크 구성 형태로 그물형이라고도 한다.\r\n- 응답 시간이 빠르고 노드의 연결성이 우수하다.\r\n- 일반적으로 많은 단말기로부터 많은 양의 통신을 필요로 하는 경우에 유리하다.\r\n- n 개의 노드를 망형으로 구성 시 n(n-1)/2 개의 회선이 필요하다.\r\n\r\n```\r\n       단말기\r\n      /  |   \\\r\n단말기 ㅡ + ㅡ 단말기\r\n      \\  |  /\r\n       단말기\r\n```\r\n\r\n### 브릿지(Bridge)\r\n\r\n- 데이터 링크 계층(Data Link Layer)에서 동작하며 같은 MAC(Midea Access Control) 프로토콜을 사용하는 근거리 통신망 사이를 연결하는 통신 장치이다.\r\n\r\n### 스위치(Switch)\r\n\r\n- 브릿지와 같이 두 개 이상의 LAN을 연결하여 하나의 네트워크로 만드는 장치이다.\r\n- 보안 및 트래픽 관리 기능도 제공할 수 있다.\r\n- 스위치 분류\r\n  - L2 스위치\r\n    - OSI 2계층에 속하는 네트워크 장비\r\n    - 가장 기본적인 스위치로, 단순히 스위치라고도 한다.\r\n    - Adress Learning, Filtering, Forwarding 등의 기능을 수행한다.\r\n  - L3 스위치\r\n    - OSI 3계층에 속하는 네트워크 장비\r\n    - L2 스위치에 라우팅 기능이 추가되었다.\r\n    - 서로 다른 네트워크를 연결할 수 있다.\r\n  - L4 스위치\r\n    - OSI 4계층에 속하는 네트워크 장비\r\n    - L3 스위치에 로드밸런서(Load Balancer)가 추가되었다.\r\n  - L7 스위치\r\n    - OSI 7계층에 속하는 네트워크 장비이다.\r\n    - 세밀한 로드밸런싱이 가능하다.\r\n    - 보안 기능을 대폭 강화하였다.\r\n\r\n### 라우터(Router)\r\n\r\n- 네트워크 계층(Network Layer)에서 동작하며 동일 전송 프로토콜을 사용하는 분리된 2개 이상의 네트워크를 연결해주는 통신 장치이다.\r\n- 네트워크상에서 가장 최적의 IP 경로를 설정하여 전송하는 장비이다.\r\n\r\n### 게이트웨이(Gateway)\r\n\r\n- 서로 다른 통신 프로토콜을 사용하는 네트워크 사이를 연결하여 데이터를 교환할 수 있도록 하는 역할을 한다.\r\n- 두 개의 서로 다른 형태의 네트워크를 상호 연결시켜 주는 관문 역할을 하는 장치이다.\r\n- 필요한 경우 프로토콜 변환을 수행한다.\r\n\r\n### VLAN(Virtual Local Area Network)\r\n\r\n- 물리적 배치와 상관없이 논리적으로 LAN을 구성하여 Broadcast Domain을 구분할 수 있게 해주는 기술로 접속된 장비들의 성능 향상 및 보안성 증대 효과를 목표로 한다.\r\n\r\n# 네트워크 관련 신기술 ★★★\r\n\r\n### RIP(Routing Information Protocol)\r\n\r\n- 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜이다.\r\n- 최적의 경로를 산출하기 위한 정보로서 홉(거릿값)만을 고려하므로, RIP를 선택한 경로가 최적의 경로가 아닌 경우가 많이 발생할 수 있다.\r\n- 최대 홉 카운트를 15홉 이하로 한정한다.\r\n- 소규모 네트워크 환경에 적합하다.\r\n\r\n### OSPF(Open Shortest Path First)\r\n\r\n- 대표적인 링크 상태(Link State) 라우팅 프로토콜로, IP 패킷에서 89번 프로토콜을 사용하여 라우팅 정보를 전송하며 안정되고 다양한 기능으로 가장 많이 사용되는 것은 IGP(Interior Gateway Protocol)이다.\r\n\r\n### MATT(Message Queuing Telemetry Transport)\r\n\r\n- IBM이 주도하여 개발한 기술로 사물 인터넷과 같이 대역폭이 제한된 통신 환경에 최적화하여 개발된 푸시 기술 기반의 경량 메시지 전송 프로토콜이다.\r\n- TCP/IP 기반 네트워크에서 동작하는 발생-구독 기반의 메시징 프로토콜로 최근 IoT 환경에서 자주 사용되고 있는 프로토콜이다.\r\n\r\n### 사물 인터넷(IoT : Internet of Things)\r\n\r\n- 인터넷에 연결된 기기가 사람의 개입 업이 상호 간에 알아서 정보를 주고받아 처리한다.\r\n- 사물은 물론이고 현실과 가상세계의 모든 정보와 상호 작용하는 개념이다.\r\n\r\n### WSN(Wireless Sensor Network)\r\n\r\n- 센서를 네트워크로 구성한 것이다.\r\n- 사물에 부착된 센서를 통해 탐지된 사물의 인식 정보는 물론 주변의 온도, 습도와 같은 환경 정보를 실시간으로 네트워크와 연결하여 수집하고 관리하는 네트워크 시스템이다.\r\n\r\n### 클라우드 컴퓨팅(Cloud Computing)\r\n\r\n- 사용자가 인터넷 등을 통해 하드웨어, 소프트웨워 등의 컴퓨팅 자원을 원격으로 필요한 만큼 빌려서 사용하는 방식의 서비스 기술로서 서비스 모델은 IaaS, PaaS, SaaS로 구분한다.\r\n- 가상화 기술, 서비스 프로비저닝(Provisioning) 기술, 과금 체계 등을 필요로 한다.\r\n- PaaS-TA : 국내 IT 서비스 경쟁력 강화를 목표로 개발, 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼이다.\r\n\r\n### 그리드 컴퓨팅(Grid Computing)\r\n\r\n- 인터넷상에서 사용하지 않는 시간대의 연결된 수많은 컴퓨터를 하나의 고성능 컴퓨터처럼 활용할 수 있는 기술이다.\r\n\r\n### RFID(Radio Frequency IDentification)\r\n\r\n- 전자 태그가 부착된 IC 칩과 무선 통신 기술을 이용하여 다양한 개체들의 정보를 관리할 수 있는 센서 기술이다.\r\n\r\n### NFC(Near Field Communication)\r\n\r\n- RFID 기술 중 하나로, 10cm 정도로 가까운 거리에서 장치 간에 양방향 무선 통신을 가능하게 해주는 기술이다. 13.56MHz의 주파수 대역을 사용하는 비접촉식 통신 기술이다.\r\n- 데이터 읽기와 쓰기 기능을 모두 사용할 수 있다.\r\n\r\n### WPAN(Wireless Personal Area Network)\r\n\r\n- 사용자를 줒심으로 작은 지역에서 주로 블루투스 헤드셋, 스마트 워치 등과 같은 개인화 장치들을 연결시키는 무선 통신 규격이다.\r\n- IEEE 802.15 규격의 범주에 속한다.\r\n\r\n### PICONET(피코넷)\r\n\r\n- 여러 개의 독립된 통신 장치가 UWB(Ultra Widebacn) 기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술이다.\r\n\r\n### 스마트 그리드(Smart Grid)\r\n\r\n- 전기 및 정보통신 기술을 활용하여 전력망을 지능화, 고도화함으로써 고품질의 전력 서비스를 제공하고 에너지 이용 효율을 극대화하는 전력망 시스템이다.\r\n- 기존의 전력망에 정보 기술을 접목하여 전력 공급자와 소비자가 쌍방향으로 실시간 정보를 교환함으로써 에너지 효율을 최적화하고 새로운 부가가치를 창줄한다.\r\n\r\n### 비콘(Beacon)\r\n\r\n- 블루투스 4.0(BLE) 프로토콜 기반의 근거리 무선 통신 장치로 최대 70m 이내의 장치들과 교신할 수 있는 차세대 스마트폰 근거리 통신 기술이다.\r\n- 저전력으로 모방리 결제 등을 가능하게 해주는 스마트폰 근거리 통신 기술이다.\r\n- NFC보다 가용거리가 길고 5~10cm 단위 구별이 가능해 정확성이 높다.\r\n\r\n### 포스퀘어(Foursquare)\r\n\r\n- 스마트폰에 탑재된 GPS를 활용해 위치 정보를 수집한다.\r\n- 쇼핑 관광 등에 활용하는 위치 기반 소셜 네트워크 서비스이다.\r\n\r\n### ZigBee\r\n\r\n- IEEE 802.15.4 기반 PAN 기술이다.\r\n- 낮은 전력을 소모하면서 저가의 센서 네트워크 구현에 최적의 방안을 제공한다.\r\n- 빌딩 자동화나 홈 보안 시스템 등의 자동화에 적절한 통신 기술이다.\r\n\r\n### Mesh Network\r\n\r\n- 기존 무선 랜의 한계 극복을 위해 등장하였다.\r\n- 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신 홈네트워킹, 공공 안전 등의 특수 목적을 위한 새로운 방식의 네트워크 기술이다.\r\n\r\n### Wavelength Division Multiplexing(WDM, 파장 분할 다중화)\r\n\r\n- 레이저 빛이 다른 파장(다른 색)을 사용하여 여러 반송파 신호를 단일 광섬유에 적용하는 기술이다.\r\n- 파장이 서로 다른 복수의 광신호를 동시에 이용하는 것으로 광섬유를 다중화하는 방식이다.\r\n- 빛의 파장 축과 파장이 다른 광선은 서로 간섭을 일으키지 않는 성질을 이용한다.\r\n\r\n# 소프트웨어 관련 신기술\r\n\r\n### 소프트웨어 정의 데이터 센터(SDDC : Software Defined Data Center)\r\n\r\n- 가상 데이터 센터(Virtual Data Center : VDC)라고도 하며, 추상화, 풀링(Pooling), 자동화 등을 통해 인프라를 가상화하는 데이터 센터를 의미한다.\r\n- 컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의한다.\r\n- 인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리한다.\r\n- 데이터 센터 내 모든 자원을 가상화하여 서비스한다.\r\n\r\n### 텐서플로우(TensorFlow)\r\n\r\n- 구글에서 개발해서 공개한 인공지능 응용 프로그램 개발용 오픈소스 프레임워크이다.\r\n- 텐서플로우를 사용할 때 인공지능 소프트웨어가 이미지 및 음성을 인식하기 위해서는 신경망의 합성곱 신경망 모델을 주로 사용한다.\r\n\r\n### 머신 러닝(Machine Learning)\r\n\r\n- 컴퓨터 프로그램이 데이터와 처리 경험을 이용한 학습을 통해 정보 처리 능력을 향상시키는 기술로 컴퓨터에게 많은 데이터를 주고 거기에서 일반적인 패턴을 찾아내게 한다.\r\n- 자율 주행 자동차, 필기체 문자 인식 등과 같이 알고리즘 개발이 어려운 문제의 해결에 유용하다.\r\n\r\n### 딥 러닝(Deep Learning)\r\n\r\n- 일반적인 머신 러닝 모델보다 더 싶은 신경망 계층 구조를 이용하는 머신 러닝이다.\r\n- 주로 여러 개의 은닉층(Hidden Layer)으로 구성된 인공 신경망을 활용한다.\r\n\r\n### 디지털 트윈(Digital Twin)\r\n\r\n- 물리적인 사물과 컴퓨터에 동일하게 표현되는 가상 모델이다.\r\n- 실제 물리적인 자산 대신 소프트웨어로 가상화한 자산의 디지털 트윈을 만들어 시뮬레이션함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있다.\r\n\r\n### HMD(Head Mounted Display)\r\n\r\n- 머리에 착용하는 형태의 디스플레이로 HMD 장치를 머리에 쓰면 양쪽 눈에 근접한 위치에 소형 디스플레이가 있어 시차를 이용한 3D 영상이 투영된다.\r\n\r\n### 블록체인(Blockchain)\r\n\r\n- 공공 거래 장부로, 가상 화폐로 거래할 때 발생할 수 있는 해킹을 막는 기술이다.\r\n- 하나의 블록은 트랜잭션의 집합과 헤더(Header)로 이루어져 있고 한 블록에는 앞의 블록에 대한 정보가 포함되어 있어, 앞 블록의 내용을 변경하면 뒤에 이어지는 블록도 변경해야 한다.\r\n\r\n### BaaS(Backend as a Service)\r\n\r\n- 블록체인(Blockchain) 개발 환경을 클라우드로 서비스하는 개념으로 블록체인 네트워크에 노드의 추가 및 제거가 용이하다.\r\n- 블록체인의 기본 인프라를 추상화하여 블록체인 응용 프로그램을 만들 수 있는 클라우드 컴퓨팅 플랫폼이다.\r\n\r\n### 분산 원장 기술(Distributed Ledger Technology)\r\n\r\n- 분산 네트워크 참여자가 암호화 기술을 사용하여 거래 정보를 검증하고 합의한 원장(Ledger)을 공동으로 분산/관리하는 기술이다.\r\n- 수많은 사적 거래 정보를 개별적 데이터 블록으로 만들고, 이를 체인처럼 연결하는 블록체인 기술이다.\r\n\r\n### 증강현실(AR : Augmented Reality)\r\n\r\n- 현실을 기반으로 가상 정보를 실시간으로 결합하여 보여주는 기술이다.\r\n- 예를 들어 스마트폰 카메라로 주변을 비추면 인근에 있는 상첨의 위치, 전화번호 등의 정보가 입체 영상으로 표시된다.\r\n\r\n### 매시업(Meshup)\r\n\r\n- 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술이다.\r\n- 다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공한다.\r\n- 구글 지도에 부동산 매물 정보를 결합한 구글의 하우징 맵스(HousingMaps)가 대표적이다.\r\n\r\n### 양자 암호(Quantum Cryptography)\r\n\r\n- 양자 역학의 특성을 이용하여 안전하게 정보를 보호하기 위한 알고리즘 또는 정보 이론적/수학적 방법론이다.\r\n- 양자 컴퓨터가 등장하면서 기존의 대칭키 암호 기법과 비대칭키 암호 기법은 안전성을 보장할 수 없게 되었다.\r\n- 대표적인 양자 암호 기법으로 양자 암호키 분배(QKD : Quntum Key Distribution) 기법이다.\r\n\r\n# 하드웨어 관련 신기술\r\n\r\n### 양자 컴퓨터(Quantum Computer)\r\n\r\n- 양자 역학적 현상을 이용하여 연산을 수행하는 컴퓨터이다.\r\n- 양자 정보의 최소 단위인 큐비트(Qubit)의 상태를 제어하여 연산과 양자 알고리즘을 수행한다.\r\n\r\n### 4D 프린팅\r\n\r\n- 미리 설계된 시간이나 임의환경 조건이 충족되면 스스로 모양을 변경 또는 제조하여 새로운 형태로 바뀌는 제품을 3D 프린팅하는 기술이다.\r\n- 온도, 습도, 진동 등 에너지에서 자극을 받으면 모양이 변하는 스마트 소재가 사용된다.\r\n\r\n### N-Screen\r\n\r\n- 동일한 콘텐츠를 PC, 스마트TV, 스마트폰, 태블릿 PC 등 다양한 디지털 정보기기에서 자유롭게 이용할 수 있는 서비스이다.\r\n\r\n# 데이터베이스 관련 기술 용어\r\n\r\n### RAID(Redundant Array of Indexpensive Disks)\r\n\r\n- 데이터를 복수 또는 분할 저장하여 병렬로 데이터를 읽는 보조 기억 장치 또는 그 방법으로 디스크의 고장에 대비하여 데이터의 안정성을 높이는 기술이다.\r\n- 한 개의 데이터를 여러 디스크에 저장하여 데이터 안정성을 향상시키기 위해 사용한다.\r\n- 다수의 디스크에 데이터를 분할하여 전송함으로써 전체적인 데이터 전송 속도 향상을 위해 사용한다.\r\n- RAID 1 : 디스크 스트라이핑(Disk Striping) 방식으로 중복 저장과 오류 검출 및 교정이 없다.\r\n- RAID 2 : 비트 단위로 분산 저장하고 여러 개의 해밍코드 검사 디스크를 사용한다. 디스크 미러링(Disk Mirroring) 방식으로 높은 신뢰도를 갖는다.\r\n- RAID 3 : 데이터를 다수의 디스크에 스트라이핑하여 저장하며, 하나의 드라이브에 패리티를 저장한다. 패리티 드라이브를 사용한다.\r\n- RAID 4 : 각 디스크에 데이터를 블록 단위로 분산 저장하고 하나의 패리티 검사 디스크를 사용한다.(블록 인터리브된 패리티(Block-Interleaved Striping with Parity)).\r\n- RAID 5 : 별도의 패리티 디스크 대신 모든 디스크에 패리티 정보를 나누어 기록하는 방식으로 3개 이상의 디스크 어레이를 요구하며 쓰기 작업이 많지 않은 다중 시스템에 적합하다.\r\n\r\n### 웨어러블 컴퓨팅(Wearable Computing)\r\n\r\n- 컴퓨터를 옷이나 안경처럼 착용할 수 있게 해주는 기술이다.\r\n- 소형화, 경량화를 비롯해 음성과 동작 인식 등 다양한 기술이 적용되어 장소에 구애받지 않고 컴퓨터를 활용할 수 있다.\r\n\r\n### 멤리스터(Memristor)\r\n\r\n- 메모리와 레지스터의 합성어로, 전류의 방향과 크기 등 기준의 상태를 모두 기억하는 소자이다.\r\n- 레지스터, 커패시터, 인덕터에 이어 네 번째 전자회로 구성 요소로 차세대 기억 소자, 회로 등에 응용될 수 있다. 에너지 소모와 부팅 시간을 획기적으로 줄일 수 있다.\r\n\r\n### 직접 연결 저장 장치(DAS : Direct-Attached Storage)\r\n\r\n- 하드디스크와 같은 데이터 저장 장치를 호스트 버스 어댑터에 직접 연결하는 방식이다.\r\n- 저장 장치와 호스트 기기 사이에 네트워크 디바이스가 있지 말아야 한다.\r\n\r\n### SAN(Storage Area Network)\r\n\r\n- 네트워크상에 광 채널 스위치의 이점인 고속 전송과 장거리 연결 및 멀티 프로토콜 기능을 활용하여 각기 다른 운영체제를 가진 여러 기종이 네트워크상에서 동일 저장 장치의 데이터를 공유하게 함으로써, 여러 개의 저장 장치나 백업 작비를 단일화시킨 시스템이다.\r\n\r\n### NAS(Network Attached Storage)\r\n\r\n- 컴퓨터에 직접 연결하지 않고 네트워크를 통해 데이터를 주고받는 저장 장치이다.\r\n- 구조적으로는 스토리지 서버를 단순화, 소형화한 것이다.\r\n\r\n### Software Defined Storage\r\n\r\n- 가상화를 적용하여 필요한 공간만큼 나눠 사용할 수 있도록 하며, 서버 가상화와 유사하다.\r\n- 컴퓨팅 소프트웨어로 규정하는 데이터 스토리지 체계이며, 일정 조직 내 여러 스토리지를 하나처럼 관리하고 운용하는 컴퓨터 이용 환경으로 스토리지 자원을 효율적으로 나누어 쓰는 방법이다.\r\n\r\n### 데이터웨어하우스(Data Warehouse)\r\n\r\n- 기간 업무 시스템에서 추출되어 새로이 생성된 데이터베이스로서 의사결정지원시스템을 지원하는 주제적, 통합적, 시간적 데이터의 집합체이다.\r\n- 통합된 데이터에 대한 OLAP(On-Line Analytical Processing) 연산을 효율적으로 지원할 수 있다.\r\n\r\n### 데이터 마트(Data Mart)\r\n\r\n- 데이터웨어하우스와 사용자 사이의 중간층에 위치하며 데이터웨어하우스보다 규모나 비용 측면에서 축소된 개념이다.\r\n\r\n### 빅데이터(Big Data)\r\n\r\n- 많은 양의 정형 또는 비정형 데이터들로부터 가치를 추출하고 결과를 분석하는 기술이다.\r\n- 빅데이터의 특성은 Volume(규모), Velocity(속도), Variety(다양성)이다.\r\n- 구글 및 페이스북, 아마존의 경우 이용자의 성향과 검색 패턴, 구매패턴을 분석해 맞춤형 광고를 제공하는 등 빅데이터의 활용을 증대시키고 있다.\r\n\r\n### 데이터마이닝(Data Mining)\r\n\r\n- 대량의 데이터를 분석하여 데이터 속에 있는 변수 사이의 상호관계를 규명하여 일정한 패턴을 찾아내는 기법이다.\r\n- 데이터웨어하우징에서 수집되고 분석된 자료를 사용자에게 제공하기 위해 분류 및 가공되는 요소 기술이다.\r\n\r\n### 디지털 아카이빙(Digital Archiving)\r\n\r\n- 디지털 정보 자원을 장기적으로 보존하기 위한 작업이다.\r\n- 아날로그 콘텐츠는 디지털로 변환해 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화하는 작업이다.\r\n\r\n### 하둡(Hadoop)\r\n\r\n- 오픈소스를 기반으로 한 분산 컴퓨팅 플랫폼으로 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고, 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 빅데이터 분산 처리를 돕는 자바 소프트웨어 오픈소스 프레임워크이다.\r\n- 다양한 소스를 통해 생성된 빅데이터를 효율적으로 저장하고 처리한다.\r\n- 하둡의 필수 핵심 구성 요소는 맵리듀스와 하둡 분산 파일 시스템이다.\r\n- Sqoop : 하둡과 관계형 데이터베이스 간에 데이터를 전송할 수 있도록 설계된 도구이다.\r\n\r\n### 맵리듀스(MapReduce)\r\n\r\n- Hadoop의 핵심 구성 요소로서 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델이다.\r\n- Google에 의해 고안된 기술로써 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법을 제공한다.\r\n- 임의의 순서로 정렬된 데이터를 분산 처리하고 이를 다시 합치는 과정을 거친다.\r\n\r\n# 정보 보안의 3대 요소 ★★★\r\n\r\n- 기밀성(Confidentiality)\r\n  - 인가된 사용자만 정보 자산에 접근할 수 있다.\r\n  - 일반적인 보안의 의미와 가장 가깝다.\r\n  - 방화벽, 암호 패스워드 등이 대표적인 예이다.\r\n  - 신분 위장(Masquerading) 등과 같은 공격에 의해 위협받을 수 있다.\r\n- 무결성(Integrity)\r\n  - 시스템 내의 정보는 오직 인가된 사용자가 인가된 방법으로만 수정할 수 있다.\r\n  - 변경, 가장, 재전송 등과 같은 공격에 의해 위협받을 수 있다.\r\n- 가용성(Availability)\r\n  - 사용자가 필요할 때 데이터에 접근할 수 있는 능력을 말한다.\r\n  - 인가된 사용자가 조직의 정보 자산에 적시에 접근하여 업무를 수행할 수 있도록 유지하는 것을 목표로 한다.\r\n  - 가용성을 유지하기 위해 데이터 백업, 위협 요소 제거 등의 기술을 사용할 수 있다.\r\n  - 서비스 거부(Denial of Service) 등과 같은 공격에 의해 위협받을 수 있다.\r\n\r\n## 보안 약점의 종류\r\n\r\n- SQL Injection\r\n  - 검증되지 않은 외부 입력값이 SQL 쿼리문에 삽입되어 공격할 수 있는 보안 약점이다.\r\n  - DB에 컴파일된 SQL 쿼리문을 전달함으로써 방지할 수 있다.\r\n  - SQL Injection 취약점이 발생하는 곳을 주로 웹 애플리케이션과 데이터베이스가 연동되는 부분이다.\r\n  - 로그인과 같이 웹에서 사용자의 입력값을 받아 데이터베이스 SQL문으로 데이터를 요청하는 경우 SQL Injection을 수행할 수 있다.\r\n- 경로 조작 및 자원 삽입\r\n  - 검증되지 않은 외부 입력값이 시스템 자원 접근 경로를 조작하거나 시스템 자원에 삽입되어 공격할 수 있는 보안 약점이다.\r\n- 크로스 사이트 스크립트(XSS, Cross Site Scripting)\r\n  - 게시판의 글에 원본과 함께 악성 코드를 삽입하여 글을 읽으면 악성코드가 실행되도록 하여 클라이언트의 정보를 유출하는 공격 방법이다.\r\n  - 웹페이지에 악의적인 스크립트를 포함시켜 사용자 측에서 실행되게 유도함으로써, 정보 유출 등의 공격을 유발할 수 있는 취약점이다.\r\n  - 외부 입력값에 스크립트가 삽입되지 못하도록 문자열 치환 함수를 사용하거나 JSTL이나 크로스사이트 스크립트 방지 라이브러리를 사용함으로써 방지할 수 있다.\r\n- XQuery 삽입\r\n  - XQuery를 사용하여 XML 데이터에 대한 동적 쿼리 생성 시 검증되지 않은 외부 입력값이 쿼리문 구조 변경에 사용될 수 있는 보안 약점이다.\r\n  - XQuery에 사용되는 외부 입력값에 대하여 특수문자 및 쿼리 예약어 필터링을 통해 방지할 수 있다.\r\n- XPath 삽입\r\n  - 검증되지 않은 외부 입력값으로 XPath 쿼리문을 생성하여 쿼리문의 의미나 구조가 변경될 수 있는 보안 약점이다.\r\n- LDAP 삽입\r\n  - 외부 입력값이 올바르게 처리되지 못하여 LDAP(Lightweight Directory Access Protocol) 쿼리문의 구성 변경에 사용될 수 있는 보안 약점이다.\r\n  - DN(Distinguished Name)과 필터에 사용되는 외부 입력값에 특수문자를 제거함으로써 방지할 수 있다.\r\n\r\n# 암호화 알고리즘\r\n\r\n- 평문을 암호문으로 바꾸고, 암호문을 다시 평문으로 바꿀 때 사용되는 알고리즘을 의미한다.\r\n- 평문을 암호문으로 바꾸는 과정을 암호화(Encryption)라고 하고, 암호문을 다시 평문으로 바꾸는 과정을 복호화(Decryption)라고 한다.\r\n- 암호화 및 복호화 과정에 암호키(Cryptographic key)가 필요하다.\r\n\r\n### 암호 방식의 분류\r\n\r\n- 암호화 방식\r\n  - 단방향\r\n    - 해시\r\n  - 양방향\r\n    - 비밀키\r\n      - 스트림 방식\r\n      - 블록 방식\r\n    - 공개 키\r\n\r\n### 공개키(Public Key, 비대칭키) 암호화 기법\r\n\r\n- 암호키와 해독키가 서로 다른 기법으로 키 개수는 2N개가 필요하다.\r\n- 비대칭키 암호화 기법 또는 공중키 암호화 기법이라고도 한다.\r\n- 키 분배가 비밀키 암호화 기법보다 쉽고, 암호화/복호화 속도가 느리며 알고리즘이 복잡하다.\r\n- RSA, ElGama 기법 등이 있다.\r\n  - RSA(Rivest Shamir Adieman)\r\n    - 소인수 분해의 어려움에 기초를 둔 알고리즘\r\n    - 1978년 MIT에 의해 제안됨\r\n    - 전자문서에 대한 인증 및 부인 방지에 활용된다.\r\n  - ElGama\r\n    - 이산대수 문제의 어려움에 기초를 둔 알고리즘\r\n    - 동일한 메시지라도 암호화가 이루어질 때마다 암호문이 변경되고 암호문의 길이가 2개로 늘어나는 특징이 있다.\r\n\r\n### 비밀키(Private Key, 대칭키) 암호화 기법\r\n\r\n- 동일한 키로 암호화하고 복호화하는 기법으로 키 개수는 N(N-1)/2 개가 필요하다.\r\n- 대칭키 암호화 기법 또는 개인키 암호화 기법이라고도 한다.\r\n- 암호화/복호화 속도가 빠르고 알고리즘이 단순하다.\r\n- 키 분배가 공개키 암호화 기법보다 어렵다.\r\n- 스트림 방식과 블록 방식으로 분류된다.\r\n  - 스트림 방식\r\n    - 평문의 길이와 동일한 스트림(Stream)을 생성하여 비트 단위로 암호화하는 대칭키 암호화 방식이다. 암호화할때 XOR 연산을 수행한다.\r\n    - 종류 : RC4, A5/1, LSFR, SEAL, WEP, OFB\r\n  - 블록 방식\r\n    - 평문을 블록 단위로 암호화하는 대칭키 암호화 방식이다.\r\n    - 종류\r\n      - DES(Data Encryption Standard)\r\n        - 1970년대 초 IBM이 개발한 알고리즘이다.\r\n        - 16라운드 Feistel 구조를 가진다.\r\n        - 평문을 64비트로 블록화를 하고, 실제 키의 길이는 56비트를 이용한다.\r\n        - 전사 공격(Brute-Force Attack)에 취약하다.\r\n      - AES(Advanced Encryption standard)\r\n        - DES를 대신하여 새로운 표준이 되었다.\r\n        - 블록 크기는 128비트이고, 키 길이는 128/192/256 비트이다.\r\n        - SPN(Substitution-Permutation Network) 구조이다.\r\n      - ARIA\r\n        - 국내 기술로 개발된 암호 알고리즘이다.\r\n        - 경량 환경 및 하드웨어 구현에서의 효율성 향상을 위해 개발되었다.\r\n        - 우리나라 국가 표준으로 지정되었다.\r\n        - 블록 크기와 키 길이가 AES와 동일하다.\r\n      - SEED\r\n        - 국내 기술로 개발된 128비트 블록 암호 알고리즘이다.\r\n        - Feistel 구조이다.\r\n        - 2005년 국제 표준으로 제정되었다.\r\n      - IDEA\r\n        - DES를 대체하기 위해서 스위스에서 개발한 알고리즘이다.\r\n        - 상이한 대수 그룹으로부터의 세 가지 연산을 혼합하는 방식이다.\r\n\r\n### 해시(HASH) 암호화 방식\r\n\r\n- 임의의 길이의 메시지를 입력으로 하여 고정된 길이의 출력값을 변환하는 시법이다.\r\n- 주어진 원문에서 고정된 길이의 의사난수를 생성하며, 생성된 값을 해시값이라고 한다.\r\n- 해시 함수라고도 한다.\r\n- 디지털 서명에 이용되어 데이터 무결성을 제공한다.\r\n- 블록체인에서 체인 형태로 사용되어 데이터의 신뢰성을 보장한다.\r\n- SHA, SHA1, SHA256, MD5, RMD160, HAS-160, HAVAL 기법 등이 있다.\r\n\r\n### SHA(Secure Hash Algorithm)\r\n\r\n- 1993년에 미국 NIST에 의해 개발되었고 가장 많이 사용되고 있는 방식이다.\r\n- SHA-1은 DSA에서 사용하게 되어 있으며 많은 인터넷 응용에서 Default 해시 알고리즘으로 사용된다.\r\n- SHA-256, SHA-384, SHA-512는 AES의 키 길이인 128, 192, 256bit에 대응하도록 출력 길이를 늘린 해시 알고리즘이다.\r\n\r\n### SALT\r\n\r\n- 시스템에 저장되는 패스워드들은 Hash 또는 암호화 알고리즘의 결과값으로 저장된다. 이때 암호 공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값을 의미한다.\r\n\r\n# 서비스 공격 유형\r\n\r\n### Dos(Denial of Service, 서비스 거부)\r\n\r\n- 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격 방법이다.\r\n- 정보보호의 3대 목표 중 가용성(Availability)을 위협하는 행위로서 공격자가 임의로 자신의 IP 주소를 속여서 다량으로 서버에 보낸다.\r\n- 헤더가 조작된 일련의 IP 패킷 조각들을 전송한다.\r\n- 라우터, 웹, 전자 우편, DNS 서버 등 모든 네트워크 장비를 대상으로 이루어질 수 있다.\r\n\r\n### DDOS(Distributed Denial of Service, 분산 서비스 거부)\r\n\r\n- 여러 대의 공격자를 분산 배치하여 동시에 서비스 거부 공격함으로써 공격 대상이 되는 시스템이 정상적인 서비스를 할 수 없도록 방해하는 공격 방법이다.\r\n- 공격용 도구 : Trinoo, TFN(Tribe Flood Network), TFN2K, Stacheldraht 등이 있다.\r\n\r\n### ETC ...\r\n\r\n# 보안 솔루션\r\n\r\n### IDS(Intrusion Detection System, 침입 탐지 시스템)\r\n\r\n- 침입 공격에 대하여 탐지하는 것을 목표로 하는 보안 솔루션이다.\r\n- 외부 침입에 대한 정보를 수집하고 분석하여 침입 활동을 탐지해 이에 대응하도록 보안 담당자에게 통보하는 기능을 수행하는 네트워크 보안 시스템이다.\r\n- 예방적이고 사전에 조처를 하는 기술로서 HIDS와 NIDS로 구분한다.\r\n\r\n### 방화벽(Firewall)\r\n\r\n- 내부-외부 네트워크 사이에 위치하여, 보안 정책을 만족하는 트래픽만 통과할 수 있다.\r\n- 방화벽이 제공하는 기능에는 접근 제어, 인증, 감사 추적, 암호화 등이 있다.\r\n- 불법 사용자의 침입 차단을 위한 정책과 이를 지원하는 하드웨어 및 소프트웨어를 제공한다.\r\n- 방화벽 하드웨어 및 소프트웨어 자체의 결함에 의해 보안상 취약점을 가질 수 있다.\r\n- 내부 네트워크에서 외부 네트워크로 나가는 패킷을 그대로 통과시키므로 내부 사용자에 의한 보안 침해는 방어하지 못한다.\r\n\r\n## 정보보호 대책\r\n\r\n### IPS(Intrusion Prevention System, 침입 방지 시스템)\r\n\r\n- 사후에 조치를 취하는 기술로서 침입 공격에 대하여 방지하는 것을 목표로 하는 보안 솔루션이다.\r\n- IDS와 방화벽의 장점을 결합한 네트워크 보안 시스템이다.\r\n- 호스트의 IP 주소, 포트 번호, 사용자 인증에 기반을 두고 외부 침입을 차단한다.\r\n- 허용되지 않는 사용자나 서비스에 대해 사용을 거부하여 내부 자원을 보호한다.\r\n\r\n### DMZ(DeMilitarized Zone, 비무장지대)\r\n\r\n- DMZ는 보안 조치가 취해진 네트워크 영역이다.\r\n- 메모리, 네트워크 연결, 접근 포인트 등과 같은 자원에 대한 접근을 제한하기 위한 구축된다.\r\n- 내부 방화벽과 외부 방화벽 사이에 위치할 수 있다.\r\n- 웹 서버, DNS 서버, 메일 서버 등이 위치할 수 있다.\r\n\r\n### IPSec(IP security)\r\n\r\n- 통신 세션의 각 IP 패킷을 암호화하고 인증하는 안전한 인터넷 프로토콜(IP)이다.\r\n- ESP(Encapsulation Security Payload)는 발신지 인증, 데이터 무결성, 기밀성 모두를 보장한다.\r\n- 운영 보드는 Tunnel 모드와 Transport 모드로 분류된다.\r\n- AH(Authentication Header)는 발신지 호스트를 인증하고, IP 패킷의 무결성을 보장한다.\r\n\r\n### DLP(Data Loss Prevention)\r\n\r\n- 기업 데이터 유출을 방지하는 것을 목표로 하는 보안 솔루션이다.\r\n- 사용자의 PC에서 기업 내 기밀 데이터가 외부로 반출되는 것을 항시 감시하고 기록하며, 정책에 따라 유출을 차단시킨다.\r\n\r\n### ESM(Enterprise Security Management, 통합 보안 관리)\r\n\r\n- 방화벽, 침입 탐지 시스템, 가상 사설망 등의 보안 솔루션을 하나로 모은 통합 보안 관리 시스템으로 서로 다른 보안 장비에서 발생한 각종 로그를 통합적으로 관리하여 통합 보안 관제 서비스를 제공한다.\r\n- 전사적 차원의 보안 정책 통합 관리와 적용을 통해 정보 시스템 보안성을 향상시키고 안정성을 높인다.\r\n\r\n### VPN(Virtual Private Network, 가상 사설망)\r\n\r\n- 이용자가 인터넷과 같은 공중망에 사설망을 구축하여 마치 전용망을 사용하는 효과를 가지는 보안 솔루션이다.\r\n- 안전하지 않은 공용 네트워크를 이용하여 사설 네트워크를 구성하는 기술이다.\r\n- 전용선을 이용한 사설 네트워크에 비해 저렴한 비용으로 안전한 망을 구성할 수 있다.\r\n- 공용 네트워크로 전달되는 트래픽은 암호화 및 메시지 인증 코드 등을 사용하여 기밀성과 무결성을 제공한다.\r\n- 인터넷과 같은 공공 네트워크를 통해서 기업의 재택근무자나 이동 중인 직원이 안전하게 회사 시스템에 접근할 수 있도록 해준다.\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n"},{"title":"sw first test4","description":"정보처리기사 필기(4) - 프로그래밍 언어 활용","category":"sw","keyword":"정보처리기사, 정처기, 필기, 프로그래밍 언어 활용","date":"2023-12-27","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 모듈화와 결합도/응집도 ★★★\r\n\r\n### 모듈화\r\n\r\n- 모듈화는, 거대한 문제를 작은 조각의 문제로 나누어 다루기 쉽도록 하는 과정으로, 작게 나누어진 각 부분을 모듈이라고 한다.\r\n- 소프트웨어의 모듈은 프로그래밍 언어에서 Subroutine, Function 등으로 표현될 수 있다.\r\n- 모듈화는 시스템을 지능적으로 관리할 수 있도록 해주며, 복잡도 문제를 해결하는데 도움을 준다.\r\n- 모듈화는 시스템의 유지보수와 수정을 용이하게 한다.\r\n\r\n#### 모듈의 개념\r\n\r\n- 하나의 프로그램을 몇 개의 작은 부분으로 분할한 단위이다.\r\n- 모듈의 독립성은 결합도와 응집도에 의해 측정된다.\r\n- 각 모듈은 논리적 또는 기능적으로 분리되어 격리되고 독립적인 일을 수행한다.\r\n- 특성 : Unity(한 가지 일만 수행), Smallness(간단 명료), Simplicity(단순성), Independency(독십성) 등\r\n\r\n### 결합도(Coupling)\r\n\r\n- 한 모듈과 다른 모듈 간의 상호 의존도 또는 두 모듈 사이의 연관 관계를 의미한다.\r\n- 모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상된다.\r\n- 인터페이스가 정확히 설정되어 있지 않을 경우 불필요한 인터페이스가 나타나 모듈 사이의 의존도는 높아지고 결합도가 증가한다.\r\n- 다른 모듈과 데이터 교류가 필요한 경우 전역 변수(Global Variable)보다는 매개 변수(Parameter)를 사용하는 것이 결합도를 낮추는데 도움이 된다.\r\n- 결합도 정도 : 데이터 결합도 \u003c 스탬프 결합도 \u003c 제어 결합도 \u003c 외부 결합도 \u003c 공통 결합도 \u003c 내용 결합도\r\n\r\n- 데이터 결합도(Data Coupling)\r\n  - 한 모듈이 파라미터나 인수로 다른 모듈에 데이터를 넘겨주고 호출받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 경우의 결합도.\r\n- 스탬프 결합도(Stamp Coupling)\r\n  - 두 모듈이 동일한 자료 구조를 조회하는 경우의 결하볻\r\n- 제어 결합도(Control Coupling)\r\n  - 한 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우의 결합도\r\n- 외부 결합도(External Coupling)\r\n  - 한 모듈에서 외부로 선언한 변수를 다른 모듈에서 참조할 경우의 결합도\r\n- 공통 결합도(Common Coupling)\r\n  - 한 모듈이 다른 모듈에 제어 요소를 전달하고 여러 모듈이 공통 자료 영역을 사용하는 경우의 결합도\r\n- 내용 결합도(Content Coupling)\r\n  - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도\r\n\r\n### 응집도(Cohesion)\r\n\r\n- 한 모듈 내부의 처리 요소 간의 기능적 연관도를 의미한다.\r\n- 모듈 내부 요소는 명령어, 명령어의 모임, 호출문, 특정 작업 수행 코드 등이다.\r\n- 응집도 정도 : 기능적 응집도 \u003e 순차적 응집도 \u003e 교환적 응집도 \u003e 절차적 응집도 \u003e 시간적 응집도 \u003e 논리적 응집도 \u003e 우연적 응집도\r\n\r\n- 기능적 응집도(Functional Cohesion)\r\n  - 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로써 제공되는 경우의 응집도\r\n- 순차적 응집도(Sequential Cohesion)\r\n  - 모듈의 구성 요소가 하나의 활동으로부터 나온 출력 자료를 그다음 활동의 입력 자료로 사용하는 같은 모듈 내에서의 응집도\r\n- 교환적 응집도(Communicational Cohesion)\r\n  - 동일한 입력과 출력을 사용하는 소 작업들이 모인 모듈에서 볼 수 있는 응집도.\r\n- 절차적 응집도(Procedural Cohesion)\r\n  - 모듈이 다수의 관련 기능을 가질 때 모듈 내부의 기능 요소들이 그 기능을 순차적으로 수행할 경우의 응집도\r\n- 시간적 응집도(Temporal Cohesion)\r\n  - 특정 시간에 처리되는 여러 기능을 모아 한 개의 모듈로 작성할 경우의 응집도\r\n- 논리적 응집도(Logical Cohesion)\r\n  - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도\r\n- 우연적 응집도(Coincidental Cohesion)\r\n  - 서로 간에 어떠한 의미 있는 연관 관계도 지니지 않은 기능 요소로 구성되는 경우의 응집도\r\n\r\n### 효과적인 모듈화 설계 방법\r\n\r\n- 응집도는 강하게, 결합도는 약하게 설계한다.\r\n- 복잡도와 중복성을 줄이고 일관성을 유지할 수 있도록 설계한다.\r\n- 유지보수가 용이하도록 설계한다.\r\n- 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 설계한다.\r\n- 모듈 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.\r\n\r\n# C 언어\r\n\r\n### C언어의 기본 구조\r\n\r\n- main 함수를 반드시 포함해야 하며, main 함수에서 실행이 시작된다.\r\n- 영문 대/소문자를 엄격하게 구별한다.\r\n- 문장을 끝마칠 때는 세미콜론(;)을 사용한다.\r\n- 여러 개의 문장을 묶어 하나의 블록으로 구성할 때 중괄호({})를 사용한다.\r\n- 주석문은 /_ ~ _/로 표기한다.\r\n\r\n### 기본 자료형\r\n\r\n| 자료형 | 예약어 | 크기  |\r\n| :----: | :----: | :---: |\r\n| 정수형 |  int   | 2Byte |\r\n|        |  long  | 4Byte |\r\n| 실수형 | float  | 4Byte |\r\n|        | double | 8Byte |\r\n| 문자형 |  char  | 1Byte |\r\n\r\n### 입/출력 함수\r\n\r\n- 표준 입/출력 함수\r\n  - scanf() : 표준 입력 함수\r\n  - printf() : 표준 출력 함수\r\n  - getchar() : 문자 입력 함수\r\n  - putchar() : 문자 출력 함수\r\n  - gets() : 문자열 입력 함수\r\n  - puts() : 문자열 출력 함수\r\n- 변환 문자(출력 형식 지정 문자)\r\n  - %d : 10진 정수\r\n  - %o : 8진 정수\r\n  - %x : 16진 정수\r\n  - %f : 실수형\r\n  - %e : 지수형\r\n  - %c : 문자\r\n  - %s : 문자열\r\n\r\n### 탈출문(Escape Sequence)\r\n\r\n| 문자 |      의미       |               기능                |\r\n| :--: | :-------------: | :-------------------------------: |\r\n|  \\n  |    new line     | 커서를 다음 줄 처음으로 이동한다. |\r\n|  \\r  | carriage return | 커서를 현재 줄 처음으로 이동한다. |\r\n|  \\t  |       tab       |   커서를 일정 간격만큼 띄운다.    |\r\n|  \\b  |    backspace    |    커서를 뒤로 한 칸 이동한다.    |\r\n|  \\f  |    form feed    |        한 페이지를 넘긴다.        |\r\n|  \\0  | null character  |        널 문자를 출력한다.        |\r\n|  \\'  |  single quote   |      작은 따옴표를 출력한다.      |\r\n|  \\\"  |  double quote   |       큰따옴표를 출력한다.        |\r\n| \\ \\\\ |    backslash    |       역슬래시를 출력한다.        |\r\n|  \\a  |      alert      |        벨 소리를 발생한다.        |\r\n\r\n### C언어 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 숫자로 시작할 수 없고, 영문자나 \"\\_\"로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- auto, beak, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, int, long, register,return, short, signed, sizeof, static, struct, switch, typedef, union, unsigend, void, volatile, while 32개 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 포인터 변수\r\n\r\n- 다른 변수의 주소값을 저장할 수 있다.\r\n- 표인터 변수는 자료형에 상관없이 메모리 크기가 동일하다.\r\n- 가리키고 있는 변수값을 읽기 위해서는 포인터 연산자를 사용한다.\r\n- 포인터 변수에 일반 변수의 주소를 대입하기 위해서는 \u0026(주소) 연산자를 사용한다.\r\n- 포인터 변수를 가리키는 포인터 변수를 선언할 수 있다.\r\n\r\n### 표준 라이브러리 함수\r\n\r\n- stdio.h : C언어의 표준 입/출력 라이브러리(Standard Input and Output Library)이다.\r\n- stdlib.h : C 표준 유틸리티 함수를 모아놓은 헤더 파일이다. 문자형 변환, 수치를 문자형으로 변환, 동적 할당 관련 함수, 난수 생성 함수, 정수의 연산 함수, 검색 및 정렬 함수 등이다.\r\n- stdlib.h 함수 종류\r\n  - atoi() : 문자열을 정수형으로 변환\r\n  - atof() : 문자열을 실수형으로 변환\r\n  - atol() : 문자열을 log형 정수로 변환\r\n  - itoa() : 숫자를 문자열로 변환\r\n  - ceil() : 자리 올림\r\n  - floor() : 자리 버림\r\n  - rand() : 난수 발생\r\n  - div() : 정수 나눗셈\r\n\r\n### C언어 연산자의 특징\r\n\r\n#### 단항 연산자\r\n\r\n- ! : 부정(NOT)\r\n- ~ : 1의 보수(0-\u003e1, 1-\u003e0)를 구한다.\r\n- ++ : 1씩 증가를 의미한다.\r\n- \\-- : 1씩 감소를 의미한다.\r\n- \u0026 : 변수의 주소를 의미한다.\r\n- \\* : 변수의 내용을 의미한다.\r\n- sizeof : 변수, 변수형, 배열의 저장 장소의 크기를 Byte 단위로 구한다.\r\n\r\n#### 산술 연산자\r\n\r\n- 이항 연산자는 +, -는 \\*, /, % 보다 우선순위가 낮다.\r\n- % : 정수 나눗셈 연산 후 나머지를 구한다.\r\n\r\n#### 시프트(Shift) 연산자\r\n\r\n- \u003c\u003c는 비트를 왼쪽으로 이동시킨다.\r\n- \\\u003e\u003e는 비트를 오른쪽으로 이동시킨다.\r\n\r\n#### 관계 연산자\r\n\r\n- \u003c : ~보다 작다.\r\n- \\\u003e : ~보다 크다.\r\n- \u003c= : ~보다 작거나 같다.\r\n- \\\u003e\\ : ~보다 크거나 같다.\r\n- == : ~와 같다.\r\n- != : ~와 같지 않다.\r\n\r\n#### 비트 연산자\r\n\r\n- \u0026 : 논리곱(AND)\r\n- | : 논리합(OR)\r\n- ^ : 배타적 논리합(XOR)\r\n\r\n```C\r\n\r\n#include \u003cstdio.h\u003e\r\nint main(int argc, char *argv[]) {\r\n    int a = 4;\r\n    int b = 7;\r\n    int c = a|b;\r\n    printf(\"%d\", c);\r\n    return 0;\r\n}\r\n// 1. 변수 a와 b의 4, 7을 (2진수)비트 연산자 |(OR)로 연산한다.\r\n// 2. 비트 연산자는 2진수로 변환 후 계산한다.\r\n// 3. OR 연산자는 두 비트 중 1개라도 1이면 1이 출력된다.\r\n//     0100 (10진수: 4)\r\n// OR  0111 (10진수: 7)\r\n// =   0111(둘 중 1개라도 1이면 1이기 때문에 10진수: 7)\r\n// 4. 0111는 \"%d\" 출력 형식 지정 문자에 의해 10진수로 변환하면 7이 되어 출력된다.\r\n//\r\n// 2와 5를 가정할때\r\n//     0010\r\n// OR  0101\r\n// =   0111\r\n\r\n```\r\n\r\n#### 논리 연산자\r\n\r\n- ! : 논리 부정(NOT)\r\n- \u0026\u0026 : 논리곱(AND)\r\n- || : 논리합(OR)\r\n\r\n#### 조건 연산자\r\n\r\n- C언어에서 유일하게 3개의 피연산자를 갖는 삼항 연산자이다.\r\n- 조건식 ? 참일 경우 값 : 거짓일 경우 값\r\n- ex. big = a \u003e b ? a:b; -\u003e a와 b 중에서 큰 수가 big에 저장됨\r\n\r\n# Java 언어\r\n\r\n- 객체지향 언어이다.\r\n- 추상화, 상속화, 다형성과 같은 특징을 가진다.\r\n- 네트워크 환경에서 분산 작업이 가능하도록 설계되었다.\r\n- 특정 컴퓨터 구조와 무관한 가상 바이트 머신 코드를 사용하므로 플랫폼이 독립적이다.\r\n\r\n### Garbage Collector\r\n\r\n- S/W 개발 중 유효하지 않은 가비지 메모리가 발생한다. Java에서는 C언어와 달리 JVM 가비지 컬렉터가 불필요 메모리를 알아서 정리해준다.\r\n\r\n### Java 언어의 기본 자료형\r\n\r\n|  분류  | 예약어  | 바이트 수 |                          비고                           |\r\n| :----: | :-----: | :-------: | :-----------------------------------------------------: |\r\n| 정수형 |  byte   |   1byte   |                       -127 ~ +128                       |\r\n|        |  short  |   2byte   |                    -32,768 ~ +32,767                    |\r\n|        |   int   |   4byte   |             -2,147,483,648 ~ +2,147,483,648             |\r\n|        |  long   |   8byte   | -9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,808 |\r\n| 실수형 |  float  |   4byte   |           단정도 실수형 (유효 자리는 7정도임)           |\r\n|        | double  |   8byte   |           배정도 실수형 (유효 자리는 15정도)            |\r\n| 문자형 |  char   |   2byte   |                   유니코드 문자열 1자                   |\r\n| 논리형 | boolean |   1byte   |                       true,false                        |\r\n\r\n### 이스케이프 시퀀스(Escape Sequence)\r\n\r\n| 문자 |      의미       |               기능                |\r\n| :--: | :-------------: | :-------------------------------: |\r\n|  \\n  |    new line     | 커서를 다음 줄 처음으로 이동한다. |\r\n|  \\r  | carriage return | 커서를 현재 줄 처음으로 이동한다. |\r\n|  \\t  |       tab       |   커서를 일정 간격만큼 띄운다.    |\r\n|  \\b  |    backspace    |    커서를 뒤로 한 칸 이동한다.    |\r\n|  \\f  |    form feed    |         한 페이지 넘긴다.         |\r\n|  \\'  |  single quote   |      작은따옴표를 출력한다.       |\r\n|  \\\"  |  double quote   |       큰따옴표를 출력한다.        |\r\n| \\ \\  |    backslash    |       역슬래시를 출력한다.        |\r\n\r\n### Java 접근 제한자(접근 제어자)\r\n\r\n- public : 모든 접근을 허용한다.\r\n- private : 같은 패키지에 있는 객체와 상속 관계의 객체들만 허용한다.\r\n- default : 같은 패키지에 있는 객체들만 허용한다.\r\n- protected : 현재 객체 내에서만 허용한다.\r\n\r\n### Java의 출력 함수\r\n\r\n- System.out.print() : 괄호 안을 출력하고 줄 바꿈을 안 한다.\r\n- System.out.printIn() : 괄호 안을 출력하고 줄 바꿈을 한다.\r\n- System.out.printf() : 변환 문자를 사용하여 출력한다.\r\n- 변환 문자(출력 형식 지정 문자)\r\n- %d : 10진 정수\r\n- %o : 8진 정수\r\n- %x : 16진 정수\r\n- %f : 실수형\r\n- %e : 지수형\r\n- %c : 문자\r\n- %s : 문자열\r\n\r\n### Java 언어 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_', '$'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 영문자나 '\\_', '$'로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 오버로딩(Overloading)과 오버라이딩(Overiding)\r\n\r\n#### 오버로딩(Overloading - 과적, 과부하)\r\n\r\n- 한 클래스 내에서 같은 메서드를 사용하는 것이다.\r\n- 같은 이름의 메서드를 여러 개 정의하면서 매개 변수의 유형과 개수가 달라지도록 하는 기술이다.\r\n\r\n#### 오버라이딩(Overriding - 다른 것보다 우선인)\r\n\r\n- 상속 관계의 두 클래스의 상위 클래스에서 정의한 메서드를 하위 클래스에서 변경(재정의)하는 것이다.\r\n- Java 언어에서는 static 메ㅓㅅ드의 오버라이딩을 허용하지 않는다.\r\n- 오버라이딩의 경우 하위 객체의 매개 변수 개수와 타입은 상위 객체와 같아야 한다.\r\n\r\n# 스크립트 언어\r\n\r\n- 소스 코드를 컴파일 과정을 거치지 않고 실행할 수 있는 프로그래밍 언어이다.\r\n- 스크립트 언어에 내장된 번역기에 의해 번역되어 실행된다.\r\n- 실행 단계에서 구분을 분석한다.\r\n\r\n### 스크립트 언어의 종류\r\n\r\n1. 서버 측 스크립트 언어\r\n   - ASP(Active Server Page)\r\n     - 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 Windows 계열의 운영체제에서 실행 가능하다.\r\n   - JSP(Java Server Page)\r\n     - Java를 기반으로 하고 서버 측에서 동적으로 수행하는 페이지를 만드는 언어이다.\r\n   - PHP(Professional Hypertext Preprocessor)\r\n     - 소스 코드가 HTML 파일에 포함되는 언어이다.\r\n     - 데이터베이스와의 연동이 매우 용이하다.\r\n     - Linux, UNIX, Window 등의 다양한 운영 체제에서 사용 가능하다.\r\n       - PHP 연산자\r\n         - 산술 연산자 : +, -, \\*, /, %, \\*\\*\r\n         - 할당 연산자 : =, +=, -=, \\*=, /=, %=\r\n         - 증감 연산자 : ++, --\r\n         - 관계 연산자 : ==, ===, !=, \u003c\u003e, !==, \u003e, \u003c, \u003e=, \u003c=\r\n         - 논리 연산자 : and, or, xor, \u0026\u0026, ||, !\r\n   - 파이썬(Python)\r\n     - 인터프리터 방식의 객체지향 언어이다.\r\n     - 실행 시점에 데이터 타입을 결정하는 동적 타이핑 기능을 갖는다.\r\n2. 클라이언트 측 스크립트 언어\r\n   - JavaScript\r\n     - HTML 문서에서 HTML이나 CSS로 표현하기 어렵거나 불가능한 작업을 수행하기 위해 개발되었다.\r\n     - 소스 코드가 HTML 문서에 포함되어 있다.\r\n     - 클래스가 존재하지 않으며 변수 선언도 필요 없다.(?)\r\n     - 사용자의 웹 브라우저에서 직접 번역되고 시랳ㅇ된다.\r\n   - VBScript\r\n     - 마이크로소프트가 개발한 액티브 스크립트 언어이다.\r\n     - VBScript의 구분은 비주얼 베이직(Visual Basic) 프로그래밍 언어를 일부 반영한다.\r\n\r\n# 파이썬(Python)\r\n\r\n### 파이썬 변수명 작성 규칙\r\n\r\n- 영문 대소문자(A~Z, a~z), 숫자(0~9), '\\_'를 혼용하여 사용할 수 있다.\r\n- 첫 글자는 영문자나 '\\_'로 시작해야 한다.\r\n- 영문자는 대소문자를 구분한다.\r\n- 공백을 포함할 수 없다.\r\n- 예약어(Reserved Word)를 사용할 수 없다.\r\n\r\n### 문자열 추출\r\n\r\n- 하나의 문자를 추출하려면 추출하려는 문자의 인덱스(0부터 시작)을 지정한다.\r\n\r\n```python\r\n\r\nstring = 'hello python'\r\n\r\ns1 = string[0]\r\nprint(s1) # 'h'\r\n\r\ns2 = string[4]\r\nprint(s2) # 'o'\r\n\r\n# 역순으로 맨 오른쪽의 인덱스는 -1이다.\r\n\r\ns3 = string[-1]\r\nprint(s3) # 'n'\r\n\r\ns4 = string[-6]\r\nprint(s4) # 'p'\r\n\r\n# [:]는 처음부터 끝까지 추출한다.\r\n\r\ns5 = string[:]\r\nprint(s5) # 'hello python'\r\n\r\n# [x:] 인덱스 x부터 끝까지 추출한다.\r\n\r\ns6 = string[6:]\r\nprint(s6) # 'python'\r\n\r\ns7 = string[-6:]\r\nprint(s7) # 'python'\r\n\r\n# [:y] 처음부터 인덱스 y-1 까지 추출한다.\r\n\r\ns8 = string[:5]\r\nprint(s8) # 'hello'\r\n\r\n# [x:y] 인덱스 x부터 y-1까지 추출한다.\r\ns9 = string[4:7]\r\nprint(s9) # 'o p'\r\n\r\n# [x:y:z] 인덱스 x부터 y-1까지 z만큼 건너뛰면서 추출한다.\r\ns10 = string[:10:2]\r\nprint(s10) # 'hlopt'\r\n\r\ns11 = string[1:10:2]\r\nprint(s11) # 'el yh'\r\n\r\n```\r\n\r\n# 운영체제(OS : Operating System)\r\n\r\n- 운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어이다.\r\n- 운영체제는 컴퓨터를 편리하게 사용하고 컴퓨터 하드웨어를 효율적으로 사용할 수 있도록 한다.\r\n- 운영체제는 스스로 어떤 유용한 기능도 수행하지 않고 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 마련해준다.\r\n- 운영체제의 종류로는 MS-DOS, Windows 10, Linux, UNIX, OS/2, 안드로이드, IOS 등이 있다.\r\n\r\n### 운영체제의 기능\r\n\r\n- 사용자와 시스템 간의 편리한 인터페이스를 제공한다.\r\n- 컴퓨터의 시스템의 성능을 최적화시킨다.\r\n- 자원의 효과적인 경영을 위해 스케줄링 기능을 제공한다.\r\n- 자원 보호 기능을 제공한다.\r\n- 시스템에서 발생하는 오류로부터 시스템을 보호한다.\r\n- 사용자들 간에 데이터를 공유할 수 있도록 한다.\r\n\r\n### 운영체제의 목적\r\n\r\n1. 처리 능력(Throughput) 향상\r\n   - 처리 능력은 일정 시간 내에 시스템이 처리하는 일의 양이다.\r\n   - 처리 능력이 높을수록 처리하는 일의 양이 많아진다.\r\n2. 반환 시간(Turnaround Time)감소\r\n   - 반환 시간은 컴퓨터 센터에 작업을 지시하고 나서부터 결과를 받을 때까지의 경과 시간이다.\r\n   - 반환 시간이 감소될수록 처리 속도가 빨라진다.\r\n3. 신뢰도(Reliability) 향상\r\n   - 신뢰도는 시스템이 주어진 문제를 정확하게 해결하는 정도이다.\r\n   - 신뢰도가 높을수록 일을 정확하게 처리한다.\r\n4. 사용 가능도(Availability) 향상\r\n   - 사용 가능도는 한정된 자원을 여러 사용자가 요구할 때, 어느 정도 신속하고 충분히 지원해 줄 수 있는지의 정도이다.\r\n   - 사용 가능도가 높을수록 반환 시간이 감소한다.\r\n\r\n### 운영체제의 운영 방식\r\n\r\n1. 일괄 처리 시스템(Batch Processing System)\r\n   - 일정량 또는 일정 기간 동안 데이터를 한꺼번에 모아서 처리하는 방식이다.\r\n   - 운영체제 운용 방식 중 시대적으로 가장 먼저 생겨났다.\r\n   - ex. 수도요금 계산 업무, 월급 계산 업무 등\r\n2. 다중 프로그래밍 시스템(Multi programming System)\r\n   - 컴퓨터 시스템 자원 활용률을 극대화하기 위해 2개 이상의 프로그램을 주기억 장치에 기억시키고 CPU를 번갈아 사용하면서 처리하는 방식이다.\r\n3. 시분할 시스템(Time Sharing System)\r\n   - CPU의 전체 사용 시간을 작은 작업 시간량(Time Slice)으로 나누어서 그 시간량 동안만 번갈아 가면서 CPU를 할당하여 각 작업을 처리하는 방식이다.\r\n   - 실제로 많은 사용자가 하나의 컴퓨터를 공유하고 있지만 마치 자신만이 컴퓨터 시스템을 독점하여 사용하고 있는 것처럼 느끼게 된다.\r\n4. 다중 처리 시스템(Multi-Processing System)\r\n   - 동시에 프로그램을 수행할 수 있는 CPU를 두 개 이상 두고 각각 그 업무를 분담하여 처리할 수 있는 방식이다.\r\n5. 실시간 처리 시스템(Real Time Processing System)\r\n   - 데이터 발생 즉시, 또는 데이터 처리 요구가 있는 즉시 처리하여 결과를 산출하는 방식이다.\r\n   - 정해진 시간에 반드시 수행되어야 하는 작업들을 처리할 때 가장 정합하다.\r\n   - ex. 항공기 예약 업무, 은행 창구 업무, 조회 및 질의 업무 등\r\n6. 다중 모드 시스템(Multi-mode System)\r\n   - 일괄 처리 + 시분할 + 다중 처리 + 실시간 처리\r\n7. 분산 처리 시스템(Distributed Processing System)\r\n   - 여러 대의 컴퓨터로 작업을 나누어 처리하여 그 내용이나 결과를 통신망을 이용하여 상호 교환되도록 연결하는 방식이다.\r\n\r\n# 프로세스(Process)\r\n\r\n### 프로세스의 정의\r\n\r\n- 실행 중인 프로그램이다.\r\n- 실행 가능한 PCB를 가진 프로그램이다.\r\n- 프로세서가 할당되는 실체이다.\r\n- 프로시저가 활동 중인 것이다.\r\n- 비동기적 행위를 일으키는 주체이다.\r\n\r\n### 프로세스 제어 블록(PCB: Process Control Block)\r\n\r\n- 운영체제가 프로세스를 관리하기 위해 프로세스에 대한 중요한 정보를 저장해 놓은 곳이다.\r\n- 프로세스가 생성될 때마다 고유의 PCB가 생성되며, 프로세스가 소멸되면 PCB도 소멸된다.\r\n- PCB에 저장되어 있는 정보 : 프로세스의 현재 상태, 프로세스의 우선순위, 프로세스에 할당된 자원에 대한 정보, CPU 레지스터 정보\r\n\r\n### 프로세스 상태 전이\r\n\r\n```\r\n생성(New) -\u003e 준비(Ready) -(디스패치-Dispatch)-\u003e 실행(Run) -\u003e 종료(Exit)\r\n                ↑        \u003c-(Timer Runout)-    ↙\r\n             Wake Up            Block ←-------\r\n                |           ↙\r\n           대기(Blocked) ←--\r\n```\r\n\r\n- 준비 상태(Ready State)\r\n  - 프로세스가 CPU를 할당받기 위해 준비하고 있는 상태이다.\r\n- 실행 상태(Running State)\r\n  - 준비 상태의 프로세스가 CPU를 할당받아 실행 중인 상태이다.\r\n  - 디스패치(Dispatch) : 우선순위가 가장 높은 프로세스가 준비 상태에서 실행 상태로 전환되는 것이다.\r\n  - 할당 시간 종료(Time Runout) : 실행 상태의 프로세스가 할당 시간(타이머)이 종료되어 준비 상태로 전환되는 것이다.\r\n- 대기 상태(Blocked State)\r\n  - 실행 상태의 프로세스가 종료되기 전에 입/출력 등의 다른 작업이 필요할 경우 CPU를 반납하고 작업의 완료를 기다리는 상태이다.\r\n  - 블록(Block) : 실행 상태에서 대기 상태로 전환되는 것이다.\r\n  - 웨이크 업(Wake Up) : 대기 상태의 프로세스가 웨이크업(조건 만족)되면 준비 상태로 전환된다.\r\n\r\n### 스레드(Thread)\r\n\r\n- 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위를 의미한다.\r\n- 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.\r\n- 한 개의 프로세스는 여러 개의 스레드를 가질 수 있다.\r\n\r\n## 프로세스 스케줄링(Process Scheduling)\r\n\r\n- 프로세스의 생성 및 실행에 필요한 시스템의 자원을 해당 프로세스에 할당하는 작업이다.\r\n- 다중 프로그래밍 운영체제에서 자원의 성능을 향상시키고 효율적인 프로세서의 관리를 위해 작업 순서를 결정하는 것이다.\r\n\r\n### 프로세스 스케줄링 기법\r\n\r\n#### 비선점(Non-Preemptive) 스케줄링\r\n\r\n1. FIFO(First in Fist Out)\r\n   - 준비 상태 큐에 도착한 순서대로 CPU를 할당하는 기법이다.\r\n   - FCFS(Fist Come First Service)라고도 한다.\r\n2. SJF(Shortest Job First)\r\n   - 준비 상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 스케줄링 기법이다.\r\n   - 평균 대기 시간을 최소화한다.\r\n3. HRN(Highest Responseratio Next)\r\n   - 어떤 작업이 서비스받을 시간과 그 작업이 서비스를 기다린 시간으로 결정되는 우선순위에 따라 CPU를 할당하는 기법이다.\r\n   - 우선순위 계산식 = (대기 시간 + 서비스를 받을 시간) / 서비스를 받을 시간\r\n4. 우선순위(Priority)\r\n   - 준비 상태 큐에서 대기하는 프로세스에게 부여된 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법이다.\r\n   - 우선순위가 낮은 프로세스는 무한 정지(Indefinite Blocking)가 발생할 수 있으며, 에이징(Aging) 기법으로 이를 해결할 수 있다.\r\n\r\n#### 선점(Preemptive) 스케줄링\r\n\r\n- 한 프로세스가 CPU를 할당받아 실행 중이라도 우선순위가 높은 다른 프로세스가 CPU를 강제적으로 뺴앗을 수 있는 방식이다.\r\n- 긴급하고 높은 우선순위의 프로세스들이 빠르게 처리될 수 있다.\r\n- 선점을 위한 시간 배당에 대한 인터럽트용 타이머 클럭(Clock)이 필요하다.\r\n- 온라인 응용에 적합한 스케줄링이다.\r\n- 종류\r\n  - RR(Round Robin)\r\n    - 주어진 시간 할당량(Time Slice) 안에 작업을 마치지 않으면 준비 상태 큐의 가장 뒤로 배치된다.\r\n    - 시분할 시스템(Time-sharing System)을 위해 고안된 방식이다.\r\n    - 시간 할당량이 커지면 FCFS 스케줄링과 같은 효과를 얻을 수 있다.\r\n    - 시간 할당이 작아지면 프로세스 문맥 교환이 자주 일어난다.\r\n  - SRT(Shortest Remainig Time)\r\n    - 작업이 끝나기까지의 실행시간 추정치가 가장 작은 작업을 먼저 실행시키는 기법이다.\r\n    - FIFO 기법보다 평균 대기 시간이 감소된다.\r\n    - 작업 시간이 큰 경우 오랫동안 대기하여야 한다.\r\n  - 다단계 큐(Multi-Level Queue)\r\n    - 프로세스들을 우선순위에 따라 상위, 중위, 하위 단계의 단계별 준비 상태 큐를 배치하는 기법이다.\r\n  - 다단계 피드백 큐(Multi-Level Feedback Queue)\r\n    - 각 준비 상태 큐마다 부여된 시간 할당량 안에 완료하지 못한 프로세스는 다음 단계의 준비 상태 큐로 이동하는 기법이다.\r\n\r\n# OST(Open Systems Interconnection) 7계층 ★★★\r\n\r\n1. 물리 계층(Physical Layer)\r\n   - 물리적인 장치와 인터페이스가 전송을 위해 필요한 기계적, 전기적, 기능적, 절차적 기능을 정의하는 계층이다.\r\n   - 장치와 전송 매체 간의 인터페이스 특성 규정, 전송 매체의 유형 규정, 전송로의 연결, 유지 및 해제를 담당한다.\r\n   - 프로토콜 종류 : RS-232C, V.24, X.21\r\n2. 데이터 링크 계층(Data Link Layer)\r\n   - 인접한 두 개의 통신 시스템 간에 신뢰성 있는 효율적인 데이터를 전송하는 계층이다.\r\n   - 링크의 설정과 유지 및 종료를 담당한다.\r\n   - 전송 데이터의 흐름 제어, 프레임 동기, 오류 제어 등을 수행한다.\r\n   - 링크의 효율성을 향상시킨다.\r\n   - 프로토콜 종류 : HDLC, PPP, LLC, LAPB, LAPD, ADCCP\r\n3. 네트워크 계층(Network Layer)\r\n   - 통신망을 통해 패킷을 목적지까지 전달하는 계층.\r\n   - 경로 설정 및 네트워크 연결 관리를 수행.\r\n   - 과도한 패킷 유입에 대한 폭주 제어 기능을 한다.\r\n   - 프로토콜 종류 : X.25, IP, ICMP, IGMP\r\n4. 전송 계층(Transport Layer)\r\n   - 통신 종단 간(End-to-End) 신뢰성 있고 효율적인 데이터를 전송하는 계층이다.\r\n   - 투명한 데이터 전송을 제공한다.\r\n   - 에러 제어 및 흐름 제어를 담당한다.\r\n   - 프로토콜 종류 : TCP, UDP\r\n5. 세션 계층(Session Layer)\r\n   - 프로세스 간에 대한 연결을 확립, 관리, 단절시키는 수단을 제공한다.\r\n   - 논리적 동기 제어, 긴급 데이터 전송, 통신 시스템 간의 회화 기능 등을 제공한다.\r\n6. 표현 계층(Presentation Layer)\r\n   - 응용 간의 대화 제어(Dialogue Control)을 담당한다.\r\n   - 응용 계층과 세션 계층 사이에서 데이터 변환을 담당한다.\r\n   - 정보의 형식 설정, 암호화, 데이터 압축, 코드 변환, 문맥 관리 등의 기능을 수행한다.\r\n   - 긴 파일 전송 중에 통신 상태가 불량하여 트랜스포트 연결이 끊어지는 경우 처음부터 다시 전송하지 않고 어디까지 전송이 진행되었는지를 나타내는 동기점을 이용하여 오류를 복구한다.\r\n7. 응용 계층(Application Layer)\r\n   - 사용자에게 서비스를 제공한다.\r\n   - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.\r\n   - 프로토콜 종류 : HTTP, FTP, SMTP, Telnet, DNS\r\n\r\n# TCP/IP 프로토콜(Transmission Control Protocol/Internet Protocol)\r\n\r\n- 인터넷에 연결된 서로 다른 기종의 컴퓨터 간에 데이터 송/수신이 가능하도록 도와주는 표준 프로토콜이다.\r\n- TCP 프로토콜과 IP 프로토콜의 결합적 의미로서 TCP가 IP보다 상위층에 존재한다.\r\n- 접속형 서비스, 전이중 전송 서비스, 신뢰성 서비스를 제공한다.\r\n- 네트워크 환경에 따라 여러 개의 프로토콜을 허용한다.\r\n- TCP 프로토콜의 기본 헤더 크기는 20byte이고 60byte까지 확장 가능하다.\r\n- OSI 표준 프로토콜과 가까운 네트워크 구조를 가진다.\r\n  - OSI 7계층 : 물리, 데이터, 네트워크, 전송, 세션, 표현, 응용 계층\r\n  - TCP/IP 4계층 : 링크, 인터넷, 전송, 응용 계층\r\n\r\n### TCP(Transmission Control Protocol)\r\n\r\n- OSI 7계층의 전송 계층의 역할을 수행한다.\r\n- 서비스 처리를 위해 Multiplexing과 DeMultiplexing을 이용한다.\r\n- 전이중 서비스와 스트림 데이터 서비스를 제공한다.\r\n\r\n### IP(Internet Protocol)\r\n\r\n- OSI 7계층의 네트워크 계층에 해당하며 비신뢰성 서비스를 제공한다.\r\n\r\n## TCP/IP의 구조\r\n\r\n### 링크 계층(Link Layer)\r\n\r\n- 프레임을 송/수신한다.\r\n- 프로토콜의 종류 : Ethernet, IEEE 802, HDLC, X.25, RS-232C 등\r\n\r\n### 인터넷 계층(Internet Layer)\r\n\r\n- 주소 지정, 경로 설정을 제공한다.\r\n- 네트워크 계층이라고도 한다.\r\n- 프로토콜 종류 : IP, ICMP, IGMP, ARP, RARP 등\r\n  - IP(Internet Protocol)\r\n    - 비연결형 및 비신뢰성 전송 서비스를 제공한다.\r\n    - 라우팅과 단편화 기능을 수행한다.\r\n    - 데이터그램(Datagram)이라는 데이터 전송 형식을 가진다.\r\n    - 각 데이터그램이 독립적으로 처리되고 목적지까지 다른 경로를 통해 전송될 수 있어 데이터그램은 전송 순서와 도착 순서가 다를 수 있다.\r\n    - 비연결성이기 때문에 송신지가 여러 개인 데이터 그램을 보내면서 순서가 뒤바뀌어 도달할 수 있으며 IP 프로토콜의 헤더 길이는 최소 20~60byte이다.\r\n  - ICMP(Internet Control Message Protocol)\r\n    - IP 프로토콜에서는 오류 보고와 수정을 위한 메커니즘이 없기 때문에 이를 보완하기 위해 설계된 프로토콜이다.\r\n    - 메시지는 크게 오류 보고(Error-Reporting) 메시지와 질의(Query) 메시지로 나눌 수 있다.\r\n    - 메시지 형식은 8바이트의 헤더와 가변 길이의 데이터 영역으로 분리된다.\r\n    - 에코 메시지는 호스트가 정상적으로 동작하는지를 결정하는데 사용할 수 있다.\r\n    - 수신지 도달 불가 메시지는 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는데 사용한다.\r\n  - IGMP(Internet Group Management Protocol)\r\n    - 시작지 호스트에서 여러 목적지 호스트로 데이터를 전송할 때 사용되는 프로토콜이다.\r\n    - 멀티캐스트 그룹에 가입한 네트워크 내의 호스트를 관리한다.\r\n  - ARP 20.9(Address Resolution Protocol)\r\n    - 논리 주소(IP 주소)를 물리 주소(MAC 주소)로 변환하는 프로토콜이다.\r\n    - 네트워크에서 두 호스트가 성공적으로 통신하기 위해 각 하드웨워의 물리적인 주소 문제를 해결해 줄 수 있다.\r\n  - RARP(Reverse Address Resolution Protocol)\r\n    - 호스트의 물리 주소(MAC 주소)로부터 논리 주소(IP 주소)를 구하는 프로토콜이다.\r\n    - IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP 주소를 모르는 경우, 서버에게 IP 주소를 요청하기 위해 사용한다.\r\n\r\n### 전송 계층(Transport Layer)\r\n\r\n- 호스트 간 신뢰성 있는 통신을 제공한다.\r\n- 프로토콜 종류 : TCP, UDP\r\n  - TCP 20.8(Transmission Control Protocol)\r\n    - 신뢰성 있는 연결 지향형 전달 서비스를 제공한다.\r\n    - 순서 제어, 에러 제어, 흐름 제어 기능을 제공한다.\r\n    - 전이중 서비스와 스트림 데이터 서비스를 제공한다.\r\n    - 메시지를 캡슐화(Encapsulation)와 역캡슐화(Decapsulation)한다.\r\n    - 서비스 처리를 위해 다중화(Multiplexing)와 역다중화(Demultiplexing)를 이용한다.\r\n  - UDP 20.9(User Datagram Protocol)\r\n    - 비연결형 및 비신뢰성 전송 서비스를 제공한다.\r\n    - 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.\r\n    - 수신된 데이터의 순서 재조정 기능을 지원하지 않는다.\r\n    - 복구 기능을 제공하지 않는다.\r\n\r\n# IP 주소 ★★★\r\n\r\n### IPv4(Internet Protocol version 4)\r\n\r\n- 32비트 길이의 IP주소이다.\r\n- 주소의 각 부분을 8비트씩 4개로 나눠서 10진수로 표현한다.\r\n- IP 주소 = 네트워크 주소(Netid) + 호스트 주소\r\n\r\n#### IPv4의 주소 체계\r\n\r\n- 클래스 A\r\n  - 0.0.0.0 ~ 127.255.255.255\r\n  - 기본 서브넷 마스크 : 255.0.0.0\r\n  - 국가나 대형 통신망에서 사용한다.\r\n- 클래스 B\r\n  - 128.0.0.0 ~ 191.255.255.255\r\n  - 기본 서브넷 마스크 : 255.255.0.0\r\n  - 중대형 통신망에서 사용한다.\r\n- 클래스 C\r\n  - 192.0.0.0 ~ 223.255.255.255\r\n  - 기본 서브넷 마스크 : 255.255.255.0\r\n  - 소규모 통신망에서 사용한다.\r\n- 클래스 D\r\n  - 224.0.0.0 ~ 239.255.255.255\r\n  - 멀티캐스트용으로 사용한다.\r\n- 클래스 E\r\n  - 240.0.0.0 ~ 255.255.255.255\r\n  - 실험용으로 사용한다.\r\n\r\n### IPv6(Internet Protocol version 6)\r\n\r\n- IPv4의 주소 부족 문제를 해결하기 위해 개발되었다.\r\n- 128비트 길이의 IP 주소이다.\r\n- 16비트씩 8개의 필드로 분리 표기된다.\r\n\r\n#### IPv6의 장점\r\n\r\n- 인증 보안 기능을 포함하고 있어 IPv4보다 보안성이 강화되었다.\r\n- IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다.\r\n- 임의의 크기의 패킷을 주고받을 수 있도록 패킷 크기 제한이 없다.\r\n- 멀티미디어의 실시간 처리가 가능하다.\r\n- 자동으로 네트워크 환경 구성이 가능하다.\r\n- 주소체계는 유니캐스트(Unicast), 애니캐스트(Anycast), 멀티캐스트(Multicast) 등 세 가지로 나뉜다.\r\n\r\n#### IPv6의 통신 방식 20.6\r\n\r\n- 유니캐스트(Unicast)\r\n  - 하나의 호스트에서 다른 하나의 호스트에게 전달하는 1:1 통신 방식이다.\r\n- 애니캐스트(Anycast)\r\n  - 하나의 호스트에서 그룹 내의 가장 가까운 곳에 있는 수신자에게 전달하는 '1: 가장 가까운 1' 통신 방식이다.\r\n- 멀티캐스트(Multicast)\r\n  - 하나의 호스트에서 네트워크상의 특정 그룹 호스트들에게 전달하는 1:N 통신 방식이다.\r\n\r\n### 서브넷 마스크(Subnet Mask)\r\n\r\n- 네트워크를 작은 내부 네트워크로 분리하여 효율적으로 네트워크를 관리하기 위한 수단이다.\r\n- 서브넷 마스크는 32비트의 값으로 IP 주소를 네트워크와 호스트 IP 주소를 구분하는 역할을 한다.\r\n- 네트워크 ID에 해당하는 모든 비트를 1로 설정하며, 호스트 ID에 해당하는 모든 비트를 0으로 설정한다.\r\n- CIDR 표기 형식 : 10진수의 IP/네트워크 ID의 1비트의 개수\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n"},{"title":"sw first test3","description":"정보처리기사 필기(3) - DB 구축","category":"sw","keyword":"정보처리기사, 정처기, 필기, DB 구축","date":"2023-12-26","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 자료 구조\r\n\r\n### 자료 구조의 분류\r\n\r\n1. 선형 구조\r\n   - 리스트\r\n     - 선형 리스트\r\n     - 연결 리스트\r\n2. 비선형 구조\r\n   - 트리\r\n   - 그래프\r\n\r\n### 자료 구조의 활용\r\n\r\n- 정렬\r\n  - 집합된 데이터 레코드를 일정 기준으로 재배열하는 것.\r\n  - 오름차순, 내림차순\r\n- 검색\r\n  - 저장된 데이터 레코드 중 원하는 값을 빠르게 찾는 것\r\n- 인덱스(Index)\r\n  - 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로, 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며, 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 별도로 구성한 순서 데이터를 말한다. (ex. 책의 맨 뒤에 빠르게 찾기 등)\r\n  - B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있다.\r\n  - BETWEEN 등 범위(Range) 검색에 활용될 수 있다.\r\n- 파일 편성\r\n  - 파일에서 레코드의 물리적인 배열 방법이다.\r\n\r\n## 선형 자료 구조\r\n\r\n### 리스트(List)\r\n\r\n- 선형 리스트(Linear List)\r\n  - 배열(Array)과 같이 연속되는 기억 장소에 저장되는 리스트이다.\r\n  - 가장 간단한 데이터 구조 중 하나로 데이터 항목을 추가 삭제하는 것이 불편하다.\r\n- 연결 리스트(Linked List)\r\n  - 노드의 포인터 부분을 서로 연결시킨 리스트로, 연속적인 기억 공간이 없어도 저장이 가능하다.\r\n  - 노트의 삽입/삭제가 용이하며 포인터를 위한 추가 공간이 필요하므로 기억 공간이 많이 소요된다.\r\n\r\n### 스택(Stack)\r\n\r\n- 리스트의 한쪽 끝에서만 자료의 삽입과 삭제가 이루어 지는 자료 구조이다.\r\n- 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO, Last In First Out) 방식이다.(PUSH and POP)\r\n- 마지막 삽입된 자료의 위치를 Top이라 하고, 가장 먼저 삽입된 자료의 위치를 Bottom이라고 한다.\r\n- 스택 가능 : 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술이다.\r\n- 스택 응용 분야\r\n  - 인터럽트 처리, 수식의 계산, 0-주소 지정 방식\r\n  - 재귀호출, 후위 표현(Post-fix expression)의 연산, 깊이 우선 탐색\r\n\r\n**스택의 삽입 알고리즘**\r\n\r\n```\r\n\r\nif TOP \u003e= n then call Stack-Full;\r\nelse TOP = TOP + 1;\r\nStack(TOP) = Data;\r\nend Insert\r\n\r\n```\r\n\r\n**스택의 삭제 알고리즘**\r\n\r\n```\r\nif TOP = 0\r\nthen Underflow\r\nElse\r\nRemove S(TOP)\r\nTOP = TOP - 1\r\n```\r\n\r\n**스택의 오버플로 알고리즘**\r\n\r\n```\r\nTOP \u003c- TOP + 1\r\nif TOP \u003e n then goto AA\r\nelse Stack(TOP) \u003c- item\r\n```\r\n\r\n### 큐(Queue)\r\n\r\n- 자료의 삽입 작업은 선형 리스트의 한쪽 끝에서, 제거 작업은 다른 쪽 끝에서 수행되는 자료 구조이다.\r\n- 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO: First In First Out) 방식이다.\r\n- 큐의 응용 분야 : 운영체제의 작업 스케줄링 등에서 응용된다.\r\n\r\n### 덱(Deque)\r\n\r\n- 자료의 삽입과 삭제가 리스트의 양쪽 끝에서 이루어지므로 두 개의 포인터를 사용하는 자료 구조이다.\r\n- 스택과 큐를 복합한 형태이다.\r\n- 입력 제한 덱을 Scroll, 출력 제한 덱을 Shelf라고 한다.\r\n\r\n## 비선형 구조\r\n\r\n### 트리(Tree)\r\n\r\n- 그래프(Graph)의 특수한 형태로써 노드(Node)와 브랜치(Branch)를 이용하여 사이클을 이루지 않도록 구성한 자료 구조이다.\r\n\r\n### 이진 트리(Binary Tree)\r\n\r\n- 차수(Degree)가 이 이하인 노트들로만 구성된 트리\r\n- 이 트리의 레벨 n에서 최대 노드의 수 : 2ⁿ-1\r\n- 깊이(레벨)가 4인 트리의 최대 노드 수는 2⁴-1로, 15이다.\r\n- 구조\r\n  - 정이진 트리 : 첫 번째 레벨부터 마지막 레벨까지 모두 2개씩 채워진 트리를 말한다.\r\n  - 전이진 트리 : 전이진 트리에서 한쪽 방향 노드가 아예 존재하지 않는 트리를 말한다.\r\n  - 사향 이진 트리 : 근노드로부터 한쪽 방향으로만 기울어진 트리를 말한다.\r\n\r\n### 그래프\r\n\r\n- 정점(Vertex)과 간선(Edge)의 집합으로 이루어지는 자료 구조.\r\n- 표현 방법 : 인접 행렬(Adjacency Matrix)\r\n- 신장 트리(Spanning Tree) : 간선들이 사이클을 이루지 않도록 정점들을 연결시킨 그래프이다.\r\n- 종류 : 방향 그래프, 무방향 그래프, 완전 그래프, 부 그래프\r\n- n개의 노드로 구성된 무방향 그래프의 최대 간선 수는 n(n-1)/2개다.\r\n- 제어 흐름 스래프에서 순환 복잡도 : V(G) - E(화살표 수) - N(노드 수) + 2\r\n\r\n### 인접 행렬(Adjacency Matrix)\r\n\r\n- 방향 그래프에서 ViVj 관계를 나타내는 행렬의 원소를 Aij라고 할 때, 방향 간선이 있으면 행렬의 Aij = 1, 방향 간선이 없으면 행렬의 Aij = 0 으로 나타낸다.\r\n- 무방향 그래프에서 Vi와 Vj가 서로 인접하면 Aij = 1, 서로 인접하지 않으면 Aij = 0으로 나타낸다.\r\n- 여기서 i, j는 첨자 (A₃의 3과 같음)\r\n\r\n# 정렬(Sort)\r\n\r\n- 정렬 알고리즘 선택 시 고려사항 : 데이터의 양, 초기 데이터의 배열 상태, 키 값들의 분포 상태, 사용 컴퓨터 시스템의 특성\r\n- 종류 : 내부 정렬(장치에서 정렬이 이루어짐), 외부 정렬(보조 기억 장치에서 정렬이 이루어짐)\r\n\r\n### 삽입 정렬(Insertion Sort)\r\n\r\n- 정렬된 파일에 새로운 하나의 레코드를 순서에 따라 삽입시켜 정렬하는 방법\r\n\r\n### 선택 정렬(Selection Sort)\r\n\r\n- n개의 레코드 중에서 최소값(또는 최대값)을 찾아 1st 레코드 위치에 놓고, 나머지 (n-1) 개의 레코드 중에서 최소값(또는 최대값)을 찾아 2nd 레코드 위치에 놓는 방법을 반복하여 정렬하는 방법이다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n²)\r\n\r\n### 병합 정렬(2-Way Merge Sort)\r\n\r\n- 두 개의 키들을 한 쌍으로 하여 각 쌍에 대해 순서를 정한다.\r\n- 순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브 리스트로 만든다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n log₂ n)\r\n\r\n### 퀵 정렬(Quick Sort)\r\n\r\n- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어가면서 정렬하는 방법으로, 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽에 모이도록 서로 교환시키는 부분 교환 정렬법이다.\r\n- 최대, 최소, 평균 시간 복잡도 : O(n log₂ n), 약=O(n²)\r\n\r\n### 힙 정렬(Heap Sort)\r\n\r\n- 전이진 트리를 이용하여 정렬하는 방법이다.\r\n- 정렬한 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다.\r\n- 평균 수행 시간 복잡도는 O(n log₂ n)이고, 최악의 수행 시간 복잡도는 O(log₂ n)이다.\r\n- 입력 자료의 레코드를 완전 이진 트리(Complete Binary Tree)로 구성한다.\r\n\r\n# 검색(Search)과 해싱(Hashing)\r\n\r\n### 검색\r\n\r\n- 기억 공간 내 기억된 자료 중에서 주어진 조건을 만족하는 자료를 찾는 것\r\n\r\n- 이분 검색(Binary Search, 이진 검색)\r\n  - 이분 검색을 실행하기 위한 전제 조건은 자료가 순차적으로 정렬되어 있어야 한다.\r\n  - 탐색 효율이 좋고 탐색 시간이 적게 소요된다.\r\n  - 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.\r\n- 선형 검색(Linear Search)\r\n  - 순차 검색(Sequential Search)이라고도 한다.\r\n  - 주어진 자료에서 원소를 첫 번째 레코드부터 순차적으로 비교하면서 해당키 값을 가진 레코드를 찾아내는 가장 간단한 검색 방법이다.\r\n  - 데이터를 특별히 조직화할 필요가 없고 다양한 상황에서도 사용될 수 있는 장점이 있지만 N개의 입력 자료에 대해서 평균적으로 (n+1)/2번의 비교를 해야 하므로 비효율적이다.\r\n- 피보나치 검색(Fibonacci Search)\r\n  - 이진 검색과 비슷한 원리로, 비교 대상 기준을 피보나치 수열로 결정한다.\r\n  - 피보나치 수열 : 1,2,3,5,8,11~로 앞의 두 수의 합이 다음 번 값이 된다.\r\n- 블록 검색\r\n  - 전체 레코드를 일정한 블록으로 분리한 뒤 각 블록 내의 키값을 순서대로 비교하여 원하는 값을 찾는 기법이다.\r\n- 이진 트리 검색\r\n  - 레코드를 2진 트리로 구성하여 검색하는 방식으로 데이터를 입력하는 순서대로 첫 번째 값을 근노드로 지정하고 근노드보다 작으면 왼쪽, 크면 오른쪽에 연결하여 구성한다.\r\n\r\n### 해싱\r\n\r\n- 해싱 함수(Hashing Function)를 이용하여 레코드키에 대한 해시 테이블(Hash Table) 내의 홈 주소(Home Address)를 계산하여 주어진 레코드에 접근하는 방식이다.\r\n- 직접 접근(Direct Access Method) 파일을 구성할 때 사용된다.\r\n- 속도는 가장 빠르지만 충돌 현상 시 오버플로우 해결의 부담이 가중되며, 많은 기억 공간을 요구한다.\r\n\r\n- 제산 방법(Division Method)\r\n  - 해싱 함수 기법에서 키값을 양의 정수인 소수로 나누어 나머지를 홈주소로 취하는 방법이다.\r\n- 중간 제곱 방법(Mid-Square Method)\r\n  - 레코드 키값을 제곱하고 나서 그 중간 부분의 값을 주소로 계산하는 방법이다.\r\n  - 해시 테이블의 크기에 따라서 중간 부분의 적당한 자릿수를 선택할 수 있다.\r\n  - 비트 단위로 n 자릿수를 중간 위치 자릿수로 가정하면 해시 테이블의 크기는 2n이다.\r\n- 중첩 방법(Folding Method)\r\n  - 해싱 함수 중 주어진 키를 여러 부분으로 나누고, 각 부분의 값을 더하거나 배타적 논리합(XOR: Exclusive OR) 연산을 통하여 나온 결과로 주소를 취하는 방법이다.\r\n- 기수 변환 방법(Radix Conversion Method)\r\n  - 해싱 함수 기법 중 어떤 진법으로 표현된 주어진 레코드 키값을 다른 진법으로 간주하고 키값을 변환하여 홈주소로 취하는 방식이다.\r\n- 계수 분석 방법(Digit Analysis Method)\r\n  - 주어진 모든 키값들에서 그 키를 구성하는 자릿수들의 분포를 조사하여 비교적 고른 분포를 보이는 자릿수들을 필요한 만큼 택하는 방법을 취하는 해싱 함수 기법이다.\r\n\r\n# 데이터베이스(Database) ★★★\r\n\r\n### 데이터베이스의 정의\r\n\r\n- 통합된 데이터(Integrated Data) : 각 사용자의 데이터를 한 곳에 모아 통합한 데이터이다.\r\n- 저장된 데이터(Stored Data) : 데이터베이스는 컴퓨터 하드웨어 저장 장치에 저장되어 있는 데이터이다.\r\n- 운영 데이터(Operational Data) : 데이터베이스는 어떤 조직의 고유 기능을 수행하기 위해 반드시 필요한 데이터이다.\r\n- 공용 데이터(Shared Data) : 데이터베이스를 여러 사용자가 공동 소유/관리/활용하는 데이터이다.\r\n\r\n### 데이터베이스의 특성\r\n\r\n- 실시간 접근성(Real Time Accessibility) : 수시적이고 비정형적인 질의에 대하여 실시간 처리로 응답할 수 있어야 한다.\r\n- 내용에 의한 참조(Content Reference) : 데이터베이스의 데이터는 그 주소나 위치에 의해 참조되는 것이 아니라 내용을 참조한다.\r\n- 동시 공유(Concurrent Sharing) : 같은 내용의 데이터를 여러 사람이 동시에 공용할 수 있다.\r\n- 계속적 변화(Continuous Evolution) : 데이터베이스는 데이터의 삽입, 삭제, 갱신으로 내용이 계속적으로 변한다.\r\n- 구성 : DBMS, 스키마, 데이터베이스 언어, 데이터베이스 사용자로 구성되어있다.\r\n\r\n## DBMS(DataBase Management System, 데이터베이스 관리 시스템)\r\n\r\n- 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다.\r\n- 응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리한다.\r\n- 데이터베이스의 구성, 접근 방법, 관리 유지에 대한 모든 책임을 진다.\r\n\r\n### DBMS의 필수 기능\r\n\r\n- 정의 기능(Definition Facility)\r\n  - 데이터베이스 구조를 정의한다.\r\n  - 데이터의 논리적 구조와 물리적 구조 사이에 변환이 가능하도록 두 구조 사이의 사상(Mapping)을 명시한다.\r\n- 조작 기능(Manipulation Facility)\r\n  - 데이터베이스에 접근하여 데이터의 검색/삽입/삭제/갱신 등의 연산 적업을 하기 위한 사용자와 데이터베이스 사이의 인터페이스 수단을 제공한다.\r\n- 제어 기능(Control Facility)\r\n  - 데이터베이스에 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 무결성이 유지되도록 제어해야 한다.\r\n  - 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안(Security)을 유지하고, 권한(Authority)을 검사할 수 있어야 한다.\r\n  - 여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때 처리 결과가 항상 정확성을 유지하도록 병행 제어를 할 수 있도록 한다.\r\n\r\n### DBMS의 장/단점\r\n\r\n- 장점\r\n  - 데이터의 중복 및 종속성 최소화\r\n  - 데이터 공유\r\n  - 데이터 무결성 및 일관성 유지\r\n  - 데이터 보안 보장 용이\r\n- 단점\r\n  - 예비와 회복 기법이 어려움\r\n  - 데이터베이스 전문가 부족\r\n  - 시스템이 복잡하고, 전산화 비용 증가\r\n\r\n### 데이터베이스 용어(일부)\r\n\r\n- 빅데이터 : 데이터의 생성 양, 주기, 형식 등이 기존 데이터에 비해 매우 크기 때문에, 종래의 방법으로는 수집/저장/검색/분석이 어려운 방대한 데이터이다.\r\n- 데이터 마이닝 : 데이터웨어하우징에서 수집되고 분석된 자료를 사용자에게 제공하기 위해 분류 및 가공되는 요소 기술이다.\r\n- Hadoop : 일반 컴퓨터로 가상화된 대형 스토리지를 구현한다. 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 빅데이터 분산 처리를 돕는 자바 소프트웨어 오픈소스 프레임워크이다.\r\n\r\n## 데이터베이스의 구성\r\n\r\n### 스키마\r\n\r\n- 데이터베이스의 구조(개체, 속성, 관계)에 대한 정의이다.\r\n\r\n#### 스키마의 3계층\r\n\r\n- 외부 스키마(External Schema)\r\n  - 사용자나 응용 프로그래머가 접근할 수 있는 정의르 기술한다.\r\n- 개념 스키마(Conceptual Schema)\r\n  - 데이터베이스 전체를 정의한 것으로 데이터 개체, 관계, 제약조건, 접근 권한, 무결성 규칙 등을 명세한 것이다.\r\n  - 범기관적 입장에서 데이터베이스를 정의한다.\r\n- 내부 스키마(Internal Schema)\r\n  - 데이터의 실제 저장 방법을 기술한다.\r\n  - 물리적 저장 장치의 입장에서 본 데이터베이스 구조로써 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.\r\n\r\n### 데이터베이스 언어(Database Language)\r\n\r\n- 데이터 정의어(DDL : Data Definition Language)\r\n  - 데이터베이스의 객체들, 즉 테이블, 뷰, 인덱스 등에 대한 구조인 스키마를 정의하고 변경하며 삭제할 수 있는 기능이 있다.\r\n  - 논리적 데이터 구조와 물리적 데이터 구조 간의 사상 정의이다.\r\n  - 번역한 결과가 데이터 사전에 저장된다.\r\n- 데이터 조작어(DML : Data Manipulation Language)\r\n  - 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.\r\n  - 데이터의 검색/삽입/삭제/변경을 구행한다.\r\n- 데이터 제어어(DCL : Data Control Language)\r\n  - 불법적인 사용자로부터 데이터를 보호한다.\r\n  - 무결성을 유지한다.\r\n  - 데이터 회복 및 병행 제어를 수행한다.\r\n\r\n## 데이터베이스 모델\r\n\r\n- 데이터 모델 : 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구이다.\r\n\r\n### 데이터 모델의 구성 요소\r\n\r\n- 데이터 구조(Structure) : 데이터 구조 및 정적 성질을 표현한다.\r\n- 연산(Operations) : 데이터의 인스턴스에 적용 가능한 연산 명세와 조작 기법을 표현한다.\r\n- 제약조건(Constraints) : 데이터의 논리적 제한 명시 및 조작의 규칙이다.\r\n\r\n### 데이터 모델의 구분\r\n\r\n- 데이터베이스 모델\r\n  - 개념적 모델\r\n    - ERD(Entity Relationship Diagram)\r\n  - 논리적 모델\r\n    - 계층형\r\n    - 네트워크(망)형\r\n    - 관계형\r\n    - 객체지향형\r\n\r\n#### 개념적 데이터 모델\r\n\r\n- 속성들로 기술된 개체 타입과 이 개체 타입 간의 관계를 이용하여 현실 세계를 표현하는 방법이다.\r\n- E-R 모델(Entity-Relationship 모델 , 개체-관계 모델)\r\n  - 대표적인 개념적 데이터 모델이다.\r\n  - 개체 타입과 이들 간의 관계 타입을 이용하여 현실 세계를 개념적으로 표현한 방법이다.\r\n  - E-R 다이어그램 : E-R 모델을 그래프 방식으로 표현하였다.\r\n\r\n#### 논리적 데이터 모델\r\n\r\n- 필드로 기술된 데이터 타입과 이 데이터 타입 간의 관계 현실 세계를 표현하는 방법이다.\r\n- 종류\r\n  - 관계형 데이터 모델 : 데이터베이스를 테이블(Table)의 집합으로 표현한다.\r\n  - 계층형 데이터 모델 : 데이터베이스를 트리(Tree) 구조로 표현한다.\r\n  - 네트워크형 데이터 모델 : 데이터베이스를 그래프(Graph) 구조로 표현(owner-member 관계)하며, CODASYL DBTG 모델이라고도 한다.\r\n\r\n## 관계형 데이터베이스 모델\r\n\r\n- 관계형 데이터베이스를 구성하는 개체나 관계를 릴레이션(Relation)으로 표현한다.\r\n\r\n### 관계형 데이터베이스 모델 구조\r\n\r\n| 속성(Attribute) |  학번   | 이름 |     학과     | 학년 |\r\n| :-------------: | :-----: | :--: | :----------: | :--: |\r\n|   튜플(Tuple)   | 2024010 |  A   |   심리학과   |  1   |\r\n|      튜플       | 2025015 |  B   |  전자공학과  |  2   |\r\n|      튜플       | 2026016 |  C   | 컴퓨터공학과 |  3   |\r\n\r\n- 튜플(Tuple)\r\n  - 테이블의 행(Row)에 해당하며 파일 구조의 레코드(Record)와 같은 의미이다.\r\n  - 카디널리티(Cardinality) : 튜플의 수(기수)\r\n  - 한 릴레이션의 튜플들의 값은 모두 상이하며, 튜플 간 순서가 없다.\r\n- 속성(Attribue)\r\n  - 테이블의 열(Column)에 해당하며 파일 구조의 항목(Item), 필드(Field)와 같은 의미이다.\r\n  - 차수(Degress) : 속성의 수\r\n  - 한 릴레이션의 속성은 원자값이며, 속성 간 순서가 없다.\r\n- 도메인(Domain) : 하나의 속성이 가질 수 있는 원자값들의 집합이다.\r\n\r\n### 릴레이션의 특징\r\n\r\n- 튜플의 유일성 : 모든 튜플은 서로 다른 값을 갖는다.\r\n- 튜플의 무순서성 : 하나의 릴레이션에서 튜플의 순서는 없다.\r\n- 속성의 원자성 : 속성은 원자값을 갖는다.\r\n- 속성의 무순서성 : 각 속성은 릴레이션 내에서 유일한 이름을 가지며, 속성의 순서는 큰 의미가 없다.\r\n\r\n## 키(Key)의 종류와 무결성\r\n\r\n### 키의 분류\r\n\r\n| 학번 | 주민번호 | 이름 | 나이 | \u003c-학생---수강-\u003e | 학번 |      과목      |\r\n| :--: | :------: | :--: | :--: | :-------------: | :--: | :------------: |\r\n|  1   | 123123-1 |  A   |  10  |       ---       |  1   |    운영체제    |\r\n|  2   | 123123-1 |  B   |  20  |       ---       |  2   | 소프트웨어공학 |\r\n|  3   | 123123-1 |  C   |  30  |       ---       |  3   |     C언어      |\r\n\r\n- 슈퍼키(Super Key)\r\n  - 두 개 이상의 속성으로 구성된 키 또는 혼합키를 의미한다.\r\n  - 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 않는다.\r\n- 외래키(Foreign Key)\r\n  - 다른 테이블의 기본키로 사용되는 속성이다.\r\n  - \u003c수강\u003e 테이블에서 \u003c학생\u003e 테이블을 참조할 때 \u003c학생\u003e 테이블의 학번은 참조키, \u003c수강\u003e 테이블의 학번이 외래 키가 된다.\r\n- 무결성(Integrity)\r\n  - 릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이션을 조작하는 과정에서의 의미전 관계 (Semantic Relationship)를 명세한 것으로 정의 대항으로 도메인, 키, 종속성 등이 있다.\r\n  - 개체 무결성 : 기본키의 값은 Null 값이나 중복 값을 가질 수 없다는 제약조건이다.\r\n  - 참조 무결성 : 릴레이션 R1에 속성 조합인 외래키를 변경하려면 이를 참조하고 있는 릴레이션 R2의 기본키도 변경해야 한다. 이때 참조할 수 없는 외래키 값을 가질 수 없다는 제약조건이다.\r\n  - 도메인 무결성 : 릴레이션 중 하나의 속성은 반드시 원자 값이어야 한다는 것을 보장하는 제약조건이다.\r\n\r\n# 데이터베이스 설계와 구조화\r\n\r\n### 데이터베이스 설계 단계\r\n\r\n1. 요구조건 분석\r\n   - 데이터베이스 사용자로부터 요구조건 수집과 요구조건 명세서를 작성한다.\r\n2. 개념적 설계\r\n   - 목표 DBMS에 독립적인 개념 스키마를 설계한다.\r\n   - 개념 스키마 모델링(ERD)과 트랜잭션 모델링을 병행 수행한다.\r\n3. 논리적 설계\r\n   - 목표 DBMS에 종속적인 논리적 스키마를 설계한다.\r\n   - 스키마의 평가 및 정제를 한다.\r\n   - 논리적 데이터 모델로 변환 및 트랜잭션 인터페이스를 설계한다.\r\n4. 물리적 설계\r\n   - 목표 DBMS에 종속적인 물리적 구조를 설계한다.\r\n   - 저장 레코드 양식 설계와 레코드 집중의 분석/설계, 엑세스 경로 인덱싱, 클러스터링, 해싱 등의 설계가 포함된다.\r\n   - 접근 경로 설계 및 트랜잭션 세부 설계를 한다.\r\n5. 데이터베이스 구현\r\n   - 목표 DBMS의 DDL(데이터 정의어)로 스키마를 작성한다.\r\n   - 데이터베이스에 등록 후 트랜잭션을 작성한다.\r\n\r\n### 데이터베이스 정규화\r\n\r\n- 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정이다.\r\n- 좋은 데이터베이스 스키마를 생성하고 불필요한 데이터의 중복을 방지하여 정보 검색을 용이하게 할 수 있도록 허용한다.\r\n\r\n#### 정규화의 목적\r\n\r\n- 데이터 구조의 안정성 최대화\r\n- 중복 데이터의 최소화\r\n- 수정 및 삭제 시 이상 현상 최소화\r\n- 테이블 불일치 위험 간소화\r\n\r\n### 이상 현상(Anomaly)\r\n\r\n- 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미한다.\r\n- 종류\r\n  - 삽입 이상(Insertion Anomaly) : 데이터를 삽입할 떄 불필요한 데이터가 함께 삽입되는 현상\r\n  - 삭제 이상(Deletion Anomaly) : 릴레이션의 한 튜플을 삭제함으로써 연쇄 삭제로 인해 정보의 손실을 발생시키는 현상\r\n  - 갱신 이상(Update Anomaly) : 튜플 중에서 일부 속성을 갱신함으로써 정보의 모순성이 발생하는 현상\r\n\r\n# 정규화\r\n\r\n### 정규화 과정\r\n\r\n1. 비정규 릴레이션\r\n2. 1NF(도메인이 원자값)\r\n3. 2NF(부분적 함수 종속 제거)\r\n4. 3NF(이행적 함수 종속 제거)\r\n5. BCNF(결정자이면서 후보키가 아닌 함수 종속 제거)\r\n6. 4NF(다치 종속 제거)\r\n7. 6NF(조인 종속성 제거)\r\n\r\n### 반정규화(비정규화)\r\n\r\n- 정규화를 통하여 정합성과 데이터 무결성이 보장되지만, 테이블의 개수가 증가함에 따라 테이블 간의 조인이 증가하여 조회 성능이 떨어질 수 있는데, 이렇게 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능 향상과 개발(Development) 및 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다.\r\n- 반정규화 기법 : 테이블 반정규화, 컬럼 반정규화, 관계 반정규화\r\n- 테이블 반정규화 기법 : 테이블 병합, 테이블 분할, 테이블 추가\r\n- 테이블 추가 반정규화 유형 : 중복 테이블 추가, 집계 테이블 추가, 진행 테이블 추가, 부분 테이블 추가\r\n\r\n# SQL ★★★\r\n\r\n### SQL(Structured Query Language)\r\n\r\n- 관계형 데이터베이스의 표준 질의어\r\n- 종류\r\n  - DDL(데이터 정의어), DML(데이터 조작어), DCL(데이터 제어어)\r\n\r\n### DDL(Data Definition Language, 데이터 정의어)\r\n\r\n- 데이터베이스의 정의/변경/삭제에 사용되는 언어이다.\r\n- 논리적 데이터 구조와 물리적 데이터 구조로 정의할 수 있다.\r\n- 논리적 데이터 구조와 물리적 데이터 구조 간의 사상을 정의한다.\r\n- 번역한 결과가 데이터 사전에 저장된다.\r\n- 종류\r\n  - CREATE : 스키마, 도메인, 테이블, 뷰 정의\r\n  - ALTER : 테이블 정의 변경(필드 추가, 삭제, 갱신)\r\n  - DROP : 스키마, 도메인, 테이블, 뷰 삭제\r\n\r\n#### CREATE문 문법 구조\r\n\r\n- CREATE TABLE : 테이블을 생성하는 명령문\r\n\r\n```SQL\r\n\r\nCREATE TABLE 기본테이블\r\n    (\r\n        {열이름 데이터_타입 [NOT NULL] [DEFALUT 값]}\r\n        {[PRIMARY KEY(열이름_리스트)]},\r\n        {[UNIQUE(열이름_리스트,...)]},\r\n        {[FOREIGN KEY(열이름_리스트)]\r\n        REFERENCES 기본테이블[(기본키_열이름)]\r\n        [ON DELETE 옵션]\r\n        [ON UPDATE 옵션]}\r\n        [CHECK(조건식)]\r\n    );\r\n\r\n```\r\n\r\n- {}는 중복 가능한 부분\r\n- NOT NULL은 특정 열에 대해 NULL 값을 허용하지 않을 때 기술\r\n- PRIMARY KEY는 기본키를 구성하는 속성을 지정할 때 사용된다.\r\n- FOREIGN KEY는 외래키로 어떤 릴레이션의 기본키를 참조하는지를 기술한다.\r\n\r\n#### ALTER문 문법 구조\r\n\r\n- ALTER TABLE : 테이블 구조(필드 추가, 삭제, 변경) 변경문이다.\r\n\r\n```SQL\r\nALTER TABLE 테이블_이름 ADD 열_이름 데이터_타입 DEFAULT 값;\r\nALTER TABLE 테이블_이름 ALTER 열_이름 SET DEFAULT 값;\r\nALTER TABLE 테이블_이름 DROP 열_이름 CASCADE;\r\n```\r\n\r\n- ADD : 새로운 열(속성)을 추가할 때 사용한다.\r\n- ALTER : 특정 열(속성)의 디폴트 값을 변경할 때 사용한다.\r\n- DROP : 특정 열(속성)을 제거할 때 사용한다.\r\n\r\n#### DROP문 문법 구조\r\n\r\n- DROP : 테이블 삭제문\r\n\r\n```SQL\r\nDROP SCHEMA 스키마_이름 [CASCADE | RESTRICT];\r\nDROP DOMAIN 도메인_이름 [CASCADE | RESTRICT];\r\nDROP TABLE 테이블_이름 [CASCADE | RESTRICT];\r\nDROP INDEX 인덱스_이름;\r\n```\r\n\r\n- CASCADE : 옵션을 사용하면 삭제할 요소가 다른 개체에서 참조 중이라도 삭제가 수행된다.\r\n- RESTRICT : 옵션을 사용하면 삭제할 요소가 다른 개체에서 참조 중이라면 삭제가 수행되지 않는다.\r\n\r\n### DCL(Data Control Language, 데이터 제어어)\r\n\r\n- 데이터 제어 정의 및 기술에 사용되는 언어이다.\r\n- 불법적인 사용자로부터 데이터를 보호한다.\r\n- 무결성을 유지하고 데이터 복구 및 병행 제어를 한다.\r\n- 종류\r\n  - COMMIT : 명령어로 수행된 결과를 실제 물리적 디스크로 저장하고, 명령어로 수행을 성공적으로 완료하였음을 선언한다.\r\n  - ROLLBACK : 명령어로 수행에 실패하였음을 알리고, 수행된 결과를 원상 복귀시킨다.\r\n  - GRANT : 데이터베이스 사용자에게 사용 권한을 부여한다.\r\n  - REVOKE : 데이터베이스 사용자로부터 사용 권한을 취소한다.\r\n\r\n### DML(Data Maniqulation Language, 데이터 조작어)\r\n\r\n- 데이터의 검색/삽입/삭제/변경에 사용되는 언어이다.\r\n- 사용자와 DBMS 간의 인터페이스를 제공한다.\r\n- 종류\r\n  - SELECT\r\n    - 튜플 검색 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        SELECT 속성명[ALL | DISTINCT]\r\n        FROM 릴레이션명\r\n        WHERE 조건\r\n        [GROUP BY 속성명1, 속성명2, ... ]\r\n        [HAVING 조건]\r\n        [ORDER BY 속성명 [ASC | DESC]]\r\n    ```\r\n    - ALL : 모든 튜플을 검색(생략 가능)\r\n    - DISTINCT : 중복된 튜플 생략\r\n  - INSERT\r\n    - 튜플 삽입 명령어\r\n    - 기본 구조\r\n    ```SQL\r\n        INSERT INTO 테이블명(속성명1, 속성명2,...)\r\n        VALUES(데이터1, 데이터2 ...);\r\n    ```\r\n  - DELTETE\r\n    - 튜플 삭제 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        DELETE\r\n        FROM 테이블명\r\n        WHERE 조건;\r\n    ```\r\n  - UPDATE\r\n    - 튜플의 내용 변경 명령어이다.\r\n    - 기본 구조\r\n    ```SQL\r\n        UPDATE 테이블명\r\n        SET 속성명 = 데이터\r\n        WHERE 조건;\r\n    ```\r\n\r\n### NoSQL\r\n\r\n- \"Not only SQL\"로, SQL만을 사용하지 않는 데이터베이스 관리 시스템(DBMS)을 지칭하며, 다양한 유형의 데이터베이스를 사용하는 것을 의미한다.\r\n- 데이터를 저장하는데 SQL 외에도 다른 방법도 있다는 개념하에 비정형 데이터의 저장을 위해 유연한 데이터 모델을 지원한다.\r\n- 전통적인 관계형 데이터베이스 관리 시스템과는 다른 비관계형(Non-Relational) DBMS이다.\r\n\r\n### 집계 함수\r\n\r\n- COUNT : 테이블의 행 수를 계산할 때 / 표현식: COUNT(\\*)\r\n- SUM : 하나 또는 여러 개의 열 합계를 구할 때 / 표현식 : SUM(열 이름)\r\n- AVG : 하나 또는 여러 개의 열 평균을 구할 때 / 표현식 : AVG(열 이름)\r\n- MAX : 해당 열의 최댓값을 구할 때 / 표현식 : MAX(열 이름)\r\n\r\n### HAVING 절을 사용한 조회 검색\r\n\r\n- GROUP BY절에 의해 선택된 그룹의 탐색 조건을 지정할 수 있으며 SUM, AVG, COUNT, MAX, MIN 등의 그룹 함수와 함께 사용할 수 있다.\r\n\r\n### ORDER BY 절을 이용한 정렬 검색\r\n\r\n- 특정 항목을 기준으로 검색 테이블의 행들을 오름차순(ASC) 또는 내림차순(DESC)으로 정렬할 때 사용한다. 생략하면 ASC가 디폴트 값이 되어 오름차순으로 정렬된다.\r\n\r\n# 트랜잭션 ★★★\r\n\r\n- 하나의 논리적 기능을 수행하기 위한 작업 단위이다.\r\n- 데이터베이스에서 일어나는 연산의 집합이다.\r\n\r\n### 트랜잭션의 특성\r\n\r\n- 원자성(Atomicity)\r\n  - 완전하게 수행이 완료되지 않으면 전혀 수행되지 않아야 한다.\r\n  - 연산은 Commit, Rollback을 이용하여 적용 또는 취소로 한꺼번에 완료되어야 한다.\r\n  - 중간에 하나의 오류가 발생되더라도 취소가 되어야 한다.\r\n- 일관성(Consistency)\r\n  - 시스템의 고정 요소는 트랜잭션 수행 전후가 같아야 한다.\r\n  - 트랜잭션 결과는 일관성을 유지해야 한다.\r\n- 격리성(Isolation, 고립성)\r\n  - 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 한다.\r\n- 영속성(Durability, 지속성)\r\n  - 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억된다.\r\n  - 은행계좌에서 100원 중 10원을 인출했을 때 계좌에는 90원이 남아 있어야 한다.\r\n\r\n# 보안과 권한 부여\r\n\r\n- 보안(Security)의 개념 : 권한이 없는 사용자로부터 데이터베이스를 보호하는 것\r\n\r\n### 권한 부여/회수\r\n\r\n#### GRANT\r\n\r\n- 데이터베이스 사용자에게 사용 권한을 부여한다.\r\n- 기본 구조\r\n  ```SQL\r\n      GRANT 권한 ON 데이터 객체 TO 사용자 [WITH GRANT OPTION];\r\n  ```\r\n- WITH GRANT OPTION : 사용자가 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여한다.\r\n- 부여 가능한 권한 : Update, Delete, Insert, Select\r\n\r\n#### REVOKE\r\n\r\n- 데이터베이스 사용자로부터 사용 권한을 취소한다.\r\n- 기본 구조\r\n  ```SQL\r\n      REVOKE [GRANT OPTION FOR] 권한 ON 데이터 객체 FROM 사용자 [CASCADE];\r\n  ```\r\n- GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소한다.\r\n- CASCADE : 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄 취소한다.\r\n- 부여 가능한 권한 : Update, Delete, Insert, Select\r\n\r\n# 암호화\r\n\r\n- 네트워크를 통하거나 컴퓨터 내부에 자료를 저장할때 권한을 가진 사람 외에는 데이터를 보지 못하도록 하는 것\r\n- 일반 평문을 다양한 방식의 암호화 기법으로 가공하여 저장하거나 전송 권한이 있는 사용자에 의해 복호화되어 사용한다.\r\n\r\n암호화 과정 : 평문 =\u003e 암호화(암호키) =\u003e 암호문 =\u003e 복호화(복호키) =\u003e 평문\r\n\r\n### 암호화 기법\r\n\r\n- 비밀키(Private Key, 대칭키) 암호화 기법\r\n  - 비밀키 암호화 기법을 동일한 키로 데이터를 암호화하고 복호화한다.\r\n  - 암호화, 복호화 키가 같아서 키를 공개하면 타인이 알게 된다.\r\n  - 암호화와 복호화 속도가 빠르다.\r\n- 공개키(Public Key, 비대칭키) 암호화 기법\r\n  - 공개키 암호화 기법은 각기 다른 키로 데이터를 암호화하고 복호화한다.\r\n  - 암호화, 복호화 키가 다르므로 키는 공개되어도 된다.\r\n  - 암호화 및 복호화 속도가 느리다.\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n"},{"title":"sw first test2","description":"정보처리기사 필기(2) - 소프트웨어 개발","category":"sw","keyword":"정보처리기사, 정처기, 필기, 소프트웨어 개발","date":"2023-12-25","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 단위 모듈\r\n\r\n- 소프트웨어 구현에 필요한 다양한 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것을 의미한다.\r\n- 사용자 또는 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램이다.\r\n- 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입될 수 있다.\r\n- 두 개의 단위 모듈이 합쳐지면 두 개의 기능들을 같은 모듈로 구현할 수 있다.\r\n- 종류 : 화면, DB접근, 인터페이스, 비즈니스 트랜잭션, 데이터 암호화 등\r\n\r\n### 모듈화의 원리\r\n\r\n- 소프트웨어 개발에 있어 기능을 나누고 추상화하여 소프트웨어의 성능을 향상시키고 유지보수를 효과적으로 구현하기 위한 기법을 의미한다.\r\n- 종류\r\n  - 분할과 지배(Dibide Conquer) : 복잡한 문제를 분해, 모듈 단위로 문제를 해결한다.\r\n  - 정보 은폐(Information Hiding) : 어렵거나 변경 가능성이 있는 모듈을 타 모듈로부터 은폐시킨다.\r\n  - 자료 추상화(Data Abstraction) : 함수 내에 자료 구조의 표현 명세를 은폐, 자료와 자료에 적용 가능한 오퍼레이션을 함께 정의한다.\r\n  - 모듈의 독립성(Module Independence) : 낮은 결합도, 높은 응집도를 갖도록 한다.\r\n\r\n### 단위 모듈 테스트\r\n\r\n- 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것이다.\r\n- 화이트박스 테스트와 블랙박스 테스트 기법이 있다.\r\n\r\n### 구현 단계의 작업 절차\r\n\r\n코딩 계획 =\u003e 코딩 =\u003e 컴파일 =\u003e 테스트\r\n\r\n# 통합 개발 환경\r\n\r\n### IDE(Integrated Development Environment)\r\n\r\n- C++, JAVA 등의 언어를 이용한 소프트웨어 개발 단계에서 패키지 인크루딩, 소스 코드 편집, 컴파일, 디버깅, 바이너리 배포 등 모든 작업을 통합 지원한다.\r\n- 편집기, 컴파일러, 디버거 등의 다양한 도구를 하나의 인터페이스로 통합하여 제공한다.\r\n- 오류 체크를 시각화하여 확인 및 수정을 쉽도록 지원한다.\r\n- 컴파일에 필요한 외부 추가 기능을 연계하여 개발의 편의성을 높였다.\r\n- 종류 : 이클립스, 비주얼 스튜디오, XCode, 안드로이드 스튜디오, IDEA, VSC 등\r\n\r\n### 빌드 자동화 도구\r\n\r\n- 소스 코드 컴파일 후 다수의 연관된 모듈을 묶어 실행 파일로 만든다.\r\n- 소프트웨어 개발자가 반복 작업해야 하는 코딩을 잘 짜여진 프로세스를 통해 자동으로 실행하여, 신뢰성 있는 결과물을 생산해 낼 수 있는 작업 방식 및 방법이다.\r\n- 소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 자동 생성하는 프로그램이며, 지속해서 증가하는 라이브러리의 자동 추가 및 관리(전처리, Preprocessing)를 지원한다.\r\n- 최근에는 오픈소스인 Gradle이 등장했으며, 구글이 안드로이드의 기본 빌드 시스템으로 Gradle을 선택하면서 사용자가 급증하였다.\r\n- 기능 : 코드 컴파일, 컴포넌트 패키징, 파일 조작, 개발 테스트 실행, 버전 관리 도구 통합, 문서 생성, 배포 기능, 코드 품질 분석\r\n- 프로세스 : 컴파일 =\u003e 패키징 =\u003e 단위 테스트 =\u003e 정적 분석 =\u003e 리포팅 =\u003e 배포 =\u003e 최종 빌드\r\n- 종류 : Gradle, Jenkins, Makefile, Ant, Maven 등\r\n\r\n# 제품 소프트웨어 패키징\r\n\r\n### 애플리케이션 패키징(배포)\r\n\r\n- 개발이 완료된 소프트웨어를 고객에게 인도하기 위해 패키징하고, 설치 메뉴얼, 사용 메뉴얼 등을 작성하는 일련의 배포용 설치 파일을 만드는 작업을 의미한다.\r\n- 패키징 시 사용자 시스템의 환경, 직관적 UI, 관리 서비스 형태 제공, 패키징 변경 및 개선 관리를 통한 안정적 배포를 고려해야 한다.\r\n\r\n### 패키징 프로세스\r\n\r\n- 기능 식별\r\n  - 입/출력 데이터를 식별하고 전체적인 기능 정의 및 데이터 흐름을 식별한다.\r\n  - 기능 단위 및 출력에 대하여 상세 정의한다.\r\n- 모듈화\r\n  - 모듈화를 위하여 모듈 간 결합도와 응집도를 분석한다.\r\n  - 분류할 수 있는 기능 단위 및 서비스 단위를 모듈 별로 분류한다.\r\n  - 공유 가능한 기능과 재활용 기능을 분류한다.\r\n- 빌드 진행\r\n  - 신규 개발 소스 및 컴파일 결과물을 준비한다.\r\n  - 정상적으로 빌드되는 기능 단위 및 서비스를 분류한다.\r\n  - 빌드 도구를 선별하여 선택하고, 해당 빌드 도구를 이용하여 빌드를 수행한다.\r\n  - 컴파일 회의 에디터 등의 관련 도구 기능을 확인한다.\r\n- 사용자 환경 분석\r\n  - 고객의 편의를 위하여 최소 사용자 환경 사전을 정의한다.\r\n  - 다양한 사용자 환경 테스트를 수행한다.\r\n- 패키지 적용 시험\r\n  - 실 사용자 환경에서의 패키징 적용을 테스트한다.\r\n  - 사용자 관점에서 UI 및 시스템상의 편의성을 점검한다.\r\n- 패키징 변경 개선\r\n  - 사용자 관점에서 패키징 적용 시 개선점을 도출하여 서비스 가능한 수준의 개선 후 개선 버전을 다시 패키징한다.\r\n\r\n### 패키징 도구의 구성요소\r\n\r\n|              구성              | 특징                                                                                                                                                          |\r\n| :----------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n|      암호화 (Encryptoin)       | 콘텐츠 및 라이센스를 암호화하고, 전자 서명을 할 수 있는 기술이다. (ex. PKI, Symmetric/Asymmetric Encryption, Digital) Signature                               |\r\n|    키 관리 (Key Management)    | 콘텐츠를 암호화한 키에 대한 저장 및 배포 기술이다. (관리 방식 : 분산형, 중앙)집중형                                                                           |\r\n|  암호화 파일 생성 (Packager)   | 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술이다. (ex. Pre-packaging, On-the-fly) Packaging                                                                  |\r\n|   식별 기술 (Identificatoin)   | 콘텐츠에 대해 식별하고 체계화하는 기술이다. (ex. DOI, URI)                                                                                                    |\r\n| 저작권 표현 (Right Expression) | 저작권의 라이센스 내용을 표현하는 기술이다. (ex. XrML/MPGE-21 REL, ODRL)                                                                                      |\r\n| 정책 관리 (Policy Management)  | 라이센스 발급 및 사용에 대한 정책 표현 및 관리 기술이다. (ex. XML, Contents Management) System                                                                |\r\n| 크랙 방지 (Tamper Resistance)  | 크랙에 의한 콘텐츠 사용 방지 기술이다.(Code Obfuscation, Kernel Debugger Detection, Module Certification) (ex. Secure DB, Secure Time Management, Encryption) |\r\n|     인증 (Authentication)      | 라이센스 발급 및 사용의 기준이 되는 사용자 인증 기술이다. (ex. User/Device Authentication, SSO, Digital Certificate)                                          |\r\n\r\n# 릴리즈 노트\r\n\r\n- 애플리케이션 최종 사용자인 고객에게 제공하는 잘 정리된 배포 정보 문서이다.\r\n- 애플리케이션 릴리즈 노트에는 상세 서비스를 포함하여 수정/변경된 정보를 담고 있는 문서이다.\r\n- 사용자에게 최종 배포된 릴리즈 노트를 보면 테스트가 어떻게 진행됐는지, 개발팀의 제공 사양을 얼마나 준수했는지를 확인해 볼 수 있다.\r\n- 전체적인 버전 관리 및 릴리즈 정보를 체계적으로 관리할 수 있다.\r\n- 릴리즈 노트는 현재 시제로 개발팀에서 직접 작성하여야 하며, 명확하고 정확하며 완전한 정보를 제공해야 한다.\r\n- 개발자와 테스터가 함께 협업해야 하고 최초 및 변경, 개선 항목까지 연결되어 다음 항목에 대한 정보들이 릴리즈 노트를 통해 작성되어야 한다.\r\n\r\n### 릴리즈 노트 작성 항목\r\n\r\n- 헤더(Header) : 문서명, 제품명, 배포 버전 번호, 릴리즈 날짜, 참고 날짜, 문서(릴리즈 노트) 버전 등\r\n- 개요 : 제품 및 변경에 대한 정보를 간략하게 작성한다.\r\n- 목적 : 제품의 버그 픽스(오류 수정)와 새로운 기능을 포함한 릴리즈의 새로운 사항의 나열과 더불어 릴리즈 노트의 목적에 대한 간략한 개요를 작성한다.\r\n- 이슈 요약 : 문제가 되는 버그의 간단한 설명과 개선사항 항목을 요약하여 작성한다.\r\n- 재현 항목 : 버그 발생을 재현하기 위한 절차이다.\r\n- 수정 및 개선 내용 : 수정 및 개선 내용을 간략하게 서술한다.\r\n- 최종 사용자 영향도 : 최종 사용자에게 필요한 조치로, 이 변경사항으로 인해 다른 기능이 영향을 받는지 간략히 서술한다.\r\n- 노트 : 소프트웨어 및 하드웨어 설치 항목, 제품, 문서를 포함한 업그레이드 항목을 서술한다.\r\n- 면책 조항 : 회사와 표준 제품과 관련된 메시지를 작성한다.(프리웨어, 불법 복제 금지 등)\r\n- 연락 정보 : 사용자 지원 및 문의 관련한 연락처 정보를 작성한다.\r\n\r\n### 릴리즈 노트 작성 순서\r\n\r\n1. 모듈 식별\r\n   - 모듈 및 빌드 수행 후 릴리즈 노트 기준의 항목을 순서대로 정리한다.\r\n   - 소스를 통하여 처리되는 입/출력 데이터의 형, 기능 정의, 데이터 흐름을 정리한다.\r\n   - 메인 함수 이외의 호출 함수를 정의하고 이에 대한 출력 값을 식별한다.(ex. I/O 데이터, Function Data Flow)\r\n2. 추가 개선 항목 식별\r\n   - 추가 개선에 따른 추가 항목을 식별하여 릴리즈 노트를 작성한다.\r\n   - 추가 개선에 대한 베타 버전을 이용 테스트 수행한다.\r\n   - 테스트 중 발생한 긴급 버그를 수정한다.\r\n   - 사용자 요청에 따른 추가 개선을 계획하고 수정한다.(ex. 베타 버전, 긴급 버그, 사용자 요청)\r\n\r\n# 형상관리 ★★★\r\n\r\n- 개발 단계에서 생성되는 모든 문서, 코드 등 소프트웨어의 변경사항을 체계적으로 관리하기 위하여 추적하고 통제하는 것이다.\r\n- 작업 산출물을 형상 항목(Configuration Item)이라는 형태로 선정하고, 형상 항목 간의 변경사항 추적과 통제 정책을 수립하고 관리한다.\r\n- 요구사항 변경 또는 오류로 지속해서 변화하는 자료이며, 이러한 변화를 이력화하여 유지보수성을 향상할 수 있다.\r\n- 소프트웨어는 눈으로 확인할 수 있는 가시성이 없으므로 개발 과정의 진행 정도를 확인하는 도구로 사용된다.\r\n- 단순 버전 관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 근간을 의미한다.\r\n\r\n### 형상 관리 항목(Configuration Item)\r\n\r\n- 개발 프로세스에서 생산되거나 사용되는 작업 산출물, 작업 산출물들의 집합체를 의미한다.\r\n- 대표적인 소프트웨어 형상 항목 : 프로젝트 요구 분석서, 운영 및 설치 지침서, 요구사항 명세서, 설계/인터페이스 명세서, 테스트 설계서, 소프트웨어 품질보증, 형상 관리, V \u0026 V 계획서(확인 및 검증)와 같은 계획서, 코드 모듈(소스와 오브젝트 모두)\r\n\r\n### 형상 관리 종류\r\n\r\n- 형상 관리는 버전관리, 리비전 관리, 변경 관리, 빌드 관리, 이슈 관리 등을 모두 포함한다.\r\n\r\n- 버전 관리\r\n  - 다양한 형상항목이 과거부터 현재에 이르기까지 요구사항 등의 변화에 따라 버전을 부여함으로써 이력을 관리하는 것이다.\r\n  - 버전을 통해 시간적인 변경사항과 해당 작업 담당자를 추적할 수 있다.\r\n- 변경 관리\r\n  - 변경된 요구사항에 대하여, 비용 및 기간 등을 고려하고 타당성을 평가한다.\r\n  - 요구사항이 타당한 경우 제품 또는 산출물을 변경하고, 그렇지 않을 경우 변경을 거부하는 활동이다.\r\n\r\n### 형상 관리의 필요성과 효과\r\n\r\n1. 형상관리의 필요성\r\n   - 이미 수정된 오류가 갑자기 다시 나타나거나, 사용하던 문서나 코드가 갑자기 사라지거나 찾을 수 없는 경우가 발생할 수 있다.\r\n   - 원시 코드와 실행 코드의 버전이 일치하지 않는다.\r\n   - 요구사항이 자주 변경되고, 변경이 어떤 결과를 가져올지 예측할 수 없다.\r\n   - 무엇을 변경해야 할지 막연하고, 따라서 변경에 대한 노력을 예측할 수 없다.\r\n   - 분산된 지역에서 소프트웨어를 병렬적으로 개발하기 어렵다.\r\n   - 제품 납기일을 맞추기가 어렵고, 프로젝트가 계획대로 잘 진행되고 있는지 모르겠다.\r\n2. 형상 관리의 효과\r\n   - 관리적 효과\r\n     - 표준 확입으로 전사적 IT 자원 관리가 쉬워, 기간별/팀별/업무별 산출물 현황 및 변경 이력 통계를 파악할 수 있다.\r\n     - 제품 개발 관련 산출물이 자동 생성되고 관리된다.\r\n     - 개발/유지보수 활동을 통합 관리할 수 있다.\r\n     - 변경 프로세스의 체계를 확립하고, 외주 개발 통제 및 현황 파악을 도와준다.\r\n   - 품질 향상 효과\r\n     - 산출물 버전 관리를 자동으로 생성 관리할 수 있어 결함 및 오류가 감소한다.\r\n     - 변경 프로그램의 이력 관리를 통하여 문제 파악 및 버그 수정이 쉬워지고, 변경 내용의 영향 분석이 쉬워진다.\r\n\r\n### 형상 관리 절차\r\n\r\n- 형상 관리는 최초 계획을 수립하고 형상 식별, 통제, 감사, 기록 및 보고와 같은 활동들을 통해 일련의 과정들을 거치게 된다.\r\n\r\n1. 형상 식별(Configuration Identification)\r\n   - 형상 관리의 가장 기본이 되는 활동으로 형상 관리 계획을 근거로 형상 관리의 대상이 무엇인지 식별하는 과정이다.\r\n   - 변경 추적성 부여와 대상 식별을 위해 ID와 관리 번호를 할당한다.\r\n   - 형상 항목 대상 : 품질 관리 계획서, 품질 관리 메뉴얼, 요구사항 명세서, 설계/인터페이스 명세서, 테스트 설계서, 소스 코드\r\n2. 형상 통제\r\n   - 형상통제위원회 운영을 통하여 변경 통제가 이루어져야 한다.\r\n   - 요구사항 변경 요구를 관리하고, 변경 제어, 형상 관리 등의 통제를 지원하고 기준선에 대한 관리 및 형상 통제를 수행할 수 있다.\r\n3. 형상 보고 및 감사\r\n   - 기준선의 무결성 평가 단계로서 개발자, 유지보수 담당자가 아닌 제3자의 객관적인 확인 및 검증 과정을 통해 새로운 형상의 무결성을 확보하는 활동이다. -형상 감사 시 고려사항 - 명시된 변경이 정확하게 수정되었는가? - 기술 검토를 수행하였는가? - 개발 프로세스를 준수하였는가? - 변경 발생 시, 형상 관리 절차를 준수하였는가? - 변경에 대한 정보(변경일, 변경인, 변경사항)를 기록하였는가?\r\n4. 형상 기록/보고\r\n   - 소프트웨어 개발 상태에 대한 보고서를 제공하는 단계로 기준선에 대한 변경과 처리 과정에서의 변경을 상태 보고에 모두 기록한다.\r\n   - 기록/보고 항목 : 승인된 형상 리스트, 계획된 변경 상태, 승인된 변경의 구현 상태\r\n\r\n### 형상 관리, 버전 관리, 변경 관리\r\n\r\n|                                               형상 관리 (Configuration Management)                                                |                                                        버전 관리 (Version Management)                                                         |                          변경 관리(Version Management)                          |\r\n| :-------------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------: |\r\n| 버전, 변경 관리 개념을 포함하고, 프로젝트 진행 상황, 빌드와 릴리즈 퍼블리싱까지 모두 관리할 수 있는 통합 시스템이라고 할 수 있다. | 변경 이력을 추적 관리하는 가장 좋은 방법이 버전으로 구분하는 것이다. 사소한 체크인, 체크아웃부터 릴리즈, 퍼블리싱의 과정을 버전으로 관리한다. | 소스 코드의 변경 상황을 관리한다. 문서의 변경 이력과 복원 등의 기능이 제공된다. |\r\n\r\n### 주요 버전 관리 도구\r\n\r\n- CVS(Concurrent Versions System)\r\n  - 동시 버전 시스템이다.\r\n  - 소프트웨어 프로젝트를 진행할 때, 파일로 이뤄진 모든 작업과 모든 변화를 추적하고, 여러 개발자가 협력하여 작업할 수 있게 한다.\r\n  - 오픈소스 프로젝트에서 널리 사용되었다.\r\n  - 최근에는 CVS가 한계를 맞아 이를 대체하는 Subversion이 개발되었다.\r\n- RCS(Revision Control System)\r\n  - CVS와의 차이점은 소스 파일의 수정을 한 사람만으로 제한한다.\r\n  - 다수의 사용자가 동시에 파일 수정을 할 수 없도록 파일 잠금 방식으로 버전을 관리하는 도구이다.\r\n- SubVersion(SVN)\r\n  - CVS보다 속도 개선, 저장 공간, 변경 관리 단위가 작업 모음 단위로 개선되었다. 2000년부터 콜랩넷에서 개발되었다.\r\n  - CVS와 사용 방법이 유사해 CVS 사용자가 쉽게 도입해 사용할 수 있다.\r\n  - 아파치 최상위 프로젝트로서 전 세계 개발자 커뮤니티와 함께 개발되고 있다.\r\n  - 디렉토리, 파일을 자유롭게 이동해도 버전 관리가 가능하다.\r\n  - repository(저장소) : 프로젝트의 파일 및 변경 정보가 저장되는 장소이다.\r\n  - trunk : 메인 개발 소스. 개발 소스를 커밋했을 때 개발 소스가 모이는 곳이다.\r\n  - branch : trunk에서 분기된 개발 소스로 실험적인 기능을 추가하거나, 출시를 위한 안정화 버전 작업을 할 때 사용한다.\r\n  - tag : 특정 시점에서 프로젝트의 스냅샷을 찍어 두는 것을 의미한다.\r\n- Bitkeeper\r\n  - SVN과 비슷한 중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도를 내도록 개발된 버전 관리 도구이다.\r\n- Git\r\n  - 프로그램 등의 소스 코드 관리를 위한 분산 저장소 방식 시스템이다.\r\n  - 리누스 토르발스가 리눅스 커널 개발에 이용하려고 개발하였으며, 현재는 다른 곳에도 널리 사용되고 있다.\r\n  - 지역 저장소와 원격 저장소 2개의 저장소가 존재한다.\r\n  - 지역 저장소에서 버전 관리가 진행되어 버전 관리가 빠르다.\r\n  - 깃의 작업 폴더는 모두 전체 기록과 각 기록을 추적할 수 있는 정보를 포함하고 있으며, 완전한 형태의 저장소이다.\r\n  - 네트워크에 접근하거나 중앙 서버에 의존하지 않는다.\r\n- Clear Case\r\n  - 복수 서버, 복수 클라이언트 구조이다.\r\n  - 서버 확장 요구가 있을 때 필요한 서버를 하나씩 추가할 수 있다.\r\n\r\n# 애플리케이션 테스트 관리 ★★★\r\n\r\n### 소프트웨어 테스트\r\n\r\n- 소프트웨어 개발 단계에서 사용자 요구사항에 서술된 동작과 성능, 사용성, 안정성 등을 만족하는지 확인하기 위하여 소프트웨어의 결함을 찾아내는 활동으로 품질 향상, 오류 발견, 오류 예방 관점에서 수행하는 행동이다.\r\n- 품질 향상 관점 : 반복적인 테스트를 거쳐 제품의 신뢰도를 향상하는 품질 보증 활동이다.\r\n- 오류 발견 관점 : 잠재된 오류를 발견하고 이를 수정하여 올바를 프로그램을 개발하는 활동이다.\r\n- 오류 예방 관점 : 코드 리뷰, 동료 검토, 인스펙션 등을 통해 오류를 사전에 발견하는 활동이다.\r\n\r\n### 소프트웨어 테스트의 원리\r\n\r\n- 테스팅은 결함이 존재함을 밝히는 활동이다.\r\n  - 소프트웨어의 잠재적인 결함을 줄일 수 있지만, 결함이 발견되지 않아도 결함이 없다고 증명할 수 없음을 나타낸다.\r\n- 완벽한 테스팅은 불가능하다.\r\n  - 무한 경로, 무한 입력값, 무한 시간이 소요되어 완벽하게 테스트할 수 없으므로 리스크 분석과 우선순위를 토대로 테스트에 집중하는 것을 의미한다.\r\n- 테스팅은 개발 초기에 시작해야 한다.\r\n  - 애플리케이션의 개발 단계에 테스트를 계획하고 SDLC(Software Development Life Cycle)의 각 단계에 맞춰 전략적으로 접근하는 것을 고려하라는 뜻이다.\r\n- 결함 집중(Defect Clustering)\r\n  - 애플리케이션 결함의 대부분은 소수의 특정한 모듈에 집중되어 존재한다. 파레토 법칙이 좌우한다.\r\n- 살충제 역설(Pesticide Paradox)\r\n  - 동일한 테스트 케이스로 반복 테스트 시 결함을 발견할 수 없으므로 주기적으로 테스트 케이스를 리뷰하고 개선해야 한다.\r\n- 테스팅은 정황(Context)에 의존한다.\r\n  - 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행하여야 한다.\r\n- 오류 부재의 궤변(Absence of Errors Fallacy)\r\n  - 사용자의 요구사항을 만족하지 못하는 오류를 발견하고 그 오류를 제거하였다 해도, 해당 애플리케이션의 품질이 높다고 말할 수 없다.\r\n\r\n### 파레토의 법칙(Law of Pareto)\r\n\r\n- 80 대 20 법칙 또는 2:8 법칙이라고도 한다. 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상을 가리킨다. 예를 들어 20%의 VIP 고객이 백화점 전체 매출의 80%에 해당하는 만큼 쇼핑하는 현상을 의미한다.\r\n\r\n### 테스트 케이스(Test Case)\r\n\r\n- 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미한다.\r\n- 명세 기반 테스트의 설계 산출물이다. (명세 기반 테스트 : 테스트 수행의 증거로도 활용되며, 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 구현하고 있는지 확인)\r\n- 테스트 케이스를 설계 단계에 작성하면 테스트 시 오류를 방지하고, 테스트 수행에 있어 낭비를 줄일 수 있다.\r\n- 표준 테스트 케이스 형식\r\n\r\n1. 테스트 계획 검토 및 자료 확보\r\n2. 위험 평가 및 우선 순위 결정\r\n3. 테스트 요구사항 정의\r\n4. 테스트 구조\r\n5. 설계 및 테스트 방법 결정\r\n6. 테스트 케이스 정의\r\n7. 테스트 케이스 타당성 확인 및 유지보수\r\n\r\n#### 테스트 케이스의 구성 요소(ISO/IEC/IEEE 29119-3)\r\n\r\n- 식별자(Identifier)\r\n- 테스트 항목(Test Item)\r\n- 입력 명세(Input Specification)\r\n- 출력 명세(Output Specification)\r\n- 환경 설정(Environmental Needs)\r\n- 특수 절차 요구(Special Procedure Requirement)\r\n- 의존성 기술(Inter-case Dependencies)\r\n\r\n#### 테스트 프로세스(Test Process)\r\n\r\n계획 및 제어 =\u003e 분석 및 설계 =\u003e 구현 및 실행 =\u003e 평가 =\u003e 완료\r\n\r\n### 테스트 커버리지(Test Coverage)\r\n\r\n- 테스트 수행 정도로서 구문 커버리지, 결정 커버리지, 조건 커버리지, 조건/결정 커버리지, 변경 조건/결정 커버리지, 다중 조건 커버리지로 구분한다.\r\n\r\n### 테스트 오라클(Test Oracle)\r\n\r\n- 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참(True) 값을 입력하여 비교하는 기법 및 활동을 말한다.\r\n- True 오라클\r\n  - 모든 입력값에 대하여 적합한 결과를 생성하여, 발생한 오류를 모두 검출 할 수 있는 오라클이다.\r\n- 일관성 검사(Consistent) 오라클\r\n  - 애플리케이션 변경이 있을 때, 수행 전과 후의 결과값이 동일한지 확인하는 오라클이다.\r\n- 샘플링(Sampling) 오라클\r\n  - 임의로 선정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공한다.\r\n- 휴리스틱(Heuristic) 오라클\r\n  - 샘플링 오라클을 개선한 오라클로, 임의 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리한다.\r\n\r\n## 테스트\r\n\r\n### 테스트 레벨\r\n\r\n- 애플리케이션 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트, 설치 테스트로 분류한다.\r\n- 애플리케이션을 테스트하기 위한 총체적으로 관리하기 위한 테스트 활동의 묶음이다.\r\n- 각각의 테스트 레벨은 서로 독립적, 각각 다른 테스트 계획과 전략이 필요하다.\r\n\r\n#### 테스트 레벨의 종류\r\n\r\n- 단위 테스트\r\n  - 개발자가 원시 코드를 대상으로 각각의 단위를 다른 부분과 연계되는 부분은 고려하지 않고 단위 자체에만 집중하여 테스트한다.\r\n  - 객체지향에서 클래스 테스팅이 여기에 해당한다.\r\n- 통합 테스트\r\n  - 단위 테스트를 통과한 개발 소프트웨어/하드웨어 컴포넌트 간 인터페이스 및 연동 기능 등을 구조적으로 접근하여 테스트한다.\r\n- 시스템 테스트\r\n  - 단위/통합 테스트가 가능한 완벽히 완료되어 기능상 문제가 없는 상태에서 실제 환경과 가능한 유사한 환경에서 진행된다.\r\n  - 시스템 성능과 관련된 요구사항이 완벽하게 수행되는지를 테스트하기 때문에 사전 요구사항이 명확해야 한다.\r\n  - 개발 조직과는 독립된 테스트 조직에서 수행한다.\r\n- 인수 테스트\r\n  - 일반적인 테스트 레벨의 가장 마지막 상위 레벨로, SW 제품에 대한 요구사항이 제대로 이행되었는지 확인하는 단계이다.\r\n  - 테스팅 환경을 실 사용자 환경에서 진행하며 수행하는 주체가 사용자이다.\r\n  - 알파, 베타 테스트와 가장 밀접한 연관이 있다.\r\n\r\n#### 알파/베타 테스트\r\n\r\n- 알파 테스트\r\n  - 개발자 관점에서 수행되며, 사용상의 문제를 반영되도록 하는 테스트이다.\r\n  - 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 검사하는 기법이다.\r\n  - 개발자는 사용상의 문제를 기록하여 반영되도록 하는 테스트이다.\r\n- 베타 테스트\r\n  - 선정된 다수의 사용자가 자신들의 시용 환경에서 일정 기간 사용하면서 테스트한다.\r\n  - 문제점이나 개선 사항 등을 기록하고 개발 조직에 통보하여 반영되도록 하는 테스트이다.\r\n\r\n### 정적 테스트\r\n\r\n- 애플리케이션을 직접 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트 방식이다.\r\n- 소프트웨어 개발 초기에 결함 발견이 가능하여, 개발 비용을 낮출 수 있다.\r\n- 종류 : Inspection, walk-through, Code Test, Orthogonal Array Testing, Prior Defect History Testing, Risk-Based Testing, Run Chart, Statistical Profile Testing\r\n\r\n### 동적 테스트\r\n\r\n- 애플리케이션을 직접 실행하여 오류를 찾는 테스트 방식이다.\r\n- 소프트웨어 개발의 모든 단계에서 테스트를 수행한다.\r\n- 종류 : 블랙박스 테스트(명세 기반), 화이트박스 테스트(구조 기반)\r\n\r\n### 테스트 기반(Test Bases)에 따른 테스트\r\n\r\n- 구조 기반 테스트\r\n  - 소프트웨어 내부의 구조(논리 흐름)에 따라 테스트 케이스를 작성하고 확인하는 테스트 방식이다.\r\n  - 종류 : 구문 기반, 조건 기반, 데이터 흐름\r\n- 명세 기반 테스트\r\n  - 사용자의 요구사항에 대한 명세를 기반으로 테스트 케이스를 작성하고 확인하는 테스트 방식이다.\r\n  - 종류 : 동등 분할, 경계값 분석, 분류 트리, 상태 전이, 결정 테이블, 원인-결과, 조합 테스트, 시나리오, 오류 추정\r\n- 경험 기반 테스트\r\n  - 테스터의 경험을 기반으로 수행하는 테스트 방식이다.\r\n  - 요구사항에 대한 명세가 미흡하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적이다.\r\n  - 종류 : 에러 추정, 체크 리스트, 탐색적 테스팅\r\n\r\n### 목적에 따른 테스트\r\n\r\n- 성능(Performance) : 소프트웨어의 응답 시간, 처리량 등을 테스트한다.\r\n- 회복(Recovery) : 소프트웨어에 고의로 부하를 가하여 실패하도록 유도하고 올바르게 복구되는지 테스트한다.\r\n- 구조(Structured) : 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가한다.\r\n- 회귀(Regression) : 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인한다.\r\n- 안전(Security) : 소프트웨어가 불법적인 침입으로부터 시스템을 보호할 수 있는지 확인한다.\r\n- 강도(Stress) : 소프트웨어에 과도하게 부하를 가하여도 소프트웨어가 정상적으로 실행되는지 확인한다.\r\n- 병행(Parallel) : 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 두 결과를 비교/확인한다.\r\n\r\n## 테스트 기법\r\n\r\n### 화이트박스 테스트(White Box Test)\r\n\r\n- 모듈의 원시 코드를 오픈시킨 상태에서 코드의 논리적 모든 경로를 테스트하는 방법이다.\r\n- Source Code의 모든 문장을 한 번 이상 수행하여 모듈 안의 작동을 직접 관찰할 수 ㅅ있다.\r\n- 산출물의 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.\r\n\r\n### 화이트박스 테스트 종류\r\n\r\n1. 기초 경로 검사(Base Path Testing)\r\n2. 제어 구조 검사\r\n\r\n### 화이트박스 테스트 검증 기준\r\n\r\n- 문장 검증 기준 : 소스 코드의 모든 구분이 한 번 이상 수행된다.\r\n- 분기 검증 기준 : 소스 코드의 모든 조건문이 한 번 이상 수행된다.\r\n- 조건 검증 기준 : 소스 코드의 모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행된다.\r\n- 분기/조건 기준 : 소스 코드의 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우 한 번 이상 수행된다.\r\n\r\n### 블랙박스 테스트(Black Box Test)\r\n\r\n- 블랙박스 테스트는 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트로 기능 테스트라고도 한다.\r\n- 요구사항 명세를 보면서 테스트하며, 주로 구현된 기능을 테스트한다.\r\n- 소프트웨어 인터페이스에서 실시되는 테스트이다.\r\n\r\n### 블랙박스 테스트 종류\r\n\r\n1. 동치 분할 검사(Equivalence Partitioning)\r\n   - 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법이다.\r\n   - 입력 조건에 타당한 입력 자료와 그렇지 않은 자료의 개수를 균등하게 분할해 테스트 케이스를 설정한다.\r\n2. 원인-효과 그래프 검사(Cause and Effect Graphing)\r\n   - 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한다.\r\n   - 효용성이 높은 테스트 케이스를 선정해 검사한다.\r\n3. 오류 예측 검사(Error Forecast)\r\n   - 과거의 경험이나 감각으로 테스트하는 기법이다.\r\n   - 다른 테스트 기법으로는 찾기 어려운 오류를 찾아내는 보충적 검사 기법이다.\r\n4. 비교 검사(Comparision Testing)\r\n   - 동일한 테스트 자료를 여러 버전의 프로그램에 입력하고 동일한 결과가 출력되는지 테스트하는 기법이다.\r\n5. 경계값 분석(Boundary Value Analysis)\r\n   - 입력 자료에만 치중한 동치 분할 기법을 보완한 기법이다.\r\n   - 입력 조건 경계값에서 오류 발생 확률이 크다는 것을 활용하여 경계값을 테스트 케이스로 선정해 검사한다.\r\n   - 대표적인 명세 기반 기법(Specification based Technique)이다.\r\n\r\n## 단위/통합 테스트\r\n\r\n### 단위 테스트\r\n\r\n- 소프트웨어 최소 기능 단위인 모듈, 컴포넌트를 테스트하는 것으로 사용자의 요구사항을 기반으로 한 기능 테스트를 제일 먼저 수행한다.\r\n- 인터페이스, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 결제 조건 등을 테스트한다.\r\n- 구조 기반 테스트와 명세 기반 테스트로 분류할 수 있으나 주로 구조 기반 테스트를 시행한다.\r\n\r\n### 통합 테스트(Integration Test)\r\n\r\n- 각 모듈 간을 결합하여 시스템을 완성시키는 과정에서 모듈 간 인터페이스 혹은 통합된 컴포넌트 간 상호작용 오류 및 결함을 찾아 해결하기 위한 테스트 기법이다.\r\n- 통합 방식\r\n  - 비점진적 통합 방식(빅뱅 통합)\r\n    - 모든 모듈이 결합된 프로그램 전체를 대상으로 테스트한다.\r\n    - 규모가 작은 소프트웨어에 적합하다.\r\n    - 오류 발견/장애 위치 파악 또는 수정이 어렵다.\r\n  - 점진적 통합 방식(상향식/하향식)\r\n    - 단계적으로 통합하며 테스트한다.\r\n    - 오류 수정이 쉽다.\r\n    - 인터페이스 관련 오류를 테스트할 수 있다.\r\n\r\n### 하향식 통합\r\n\r\n- 상위 컴포넌트를 테스트하고 점증적으로 하위 컴포넌트를 검사한다.\r\n- 주요 제어 모듈 기준으로 아래로 통합하며 진행한다.\r\n- 하위 컴포넌트 개발이 완료되지 않은 경우 스텁(Stub)을 사용하기도 한다.\r\n- 우선 통합법, 깊이 우선 통합법, 넓이 우선 통합법 등이 있다.\r\n- 하위 레벨 모듈들은 특정한 소프트웨어 부가 기능을 수행하는 클러스터들에 결합된다.\r\n\r\n### 상향식 통합\r\n\r\n- 프로그램 구조에서 최하위 레벨인 모듈을 구성하고 상위 모듈 방향으로 통합하며 검사한다.\r\n- 가장 하위 단계의 모듈부터 수행되므로 스터브가 필요 없으나 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터가 필요하다.(Driver 사용)\r\n\r\n### 빅뱅 통합\r\n\r\n- 시스템을 구성하는 모듈을 각각 따로 구현하고 전체 시스템을 한 번에 테스트를 진행한다.\r\n- 테스트를 위한 Driver와 Stub 없이 실제 모듈들로 테스트를 진행한다.\r\n- 단시간 테스트를 수행하나 결함의 격리가 어려운 방식이다.\r\n\r\n### 샌드위치 통합\r\n\r\n- 상향식과 하향식의 장점을 이용하는 방식(하향식 + 상향식)이다.\r\n- 하위 프로젝트가 있는 대규모 프로젝트에 사용하는 방식이다.\r\n- 병렬 테스트가 가능하고 시간 절약이 가능하다.\r\n- 스텁(Stub)과 드라이버(Driver)의 필요성이 매우 높은 방식이며, 비용이 많이 들어간다.\r\n\r\n# 애플리케이션 성능 개선\r\n\r\n### 성능 측정 지표\r\n\r\n- 처리량(Throughput) : 주어진 시간에 처리할 수 있는 프로세스 처리 수\r\n- 응답 시간(Response Time) : 데이터 입력 완료 시부터 응답 출력이 개시될 때까지의 시간\r\n- 경과 시간(Turnaround Time) : 입력한 시점부터 그 결과의 출력이 완료할 때까지 걸리는 시간\r\n- 자원 사용률(Resource Usage) : 프로세스 처리 중 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량\r\n\r\n### 유형별 성능 분석 도구\r\n\r\n- 성능/부하/스트레스(Performance/Load/Stress) 정검 도구 : 측정 지표인 처리량, 응답 시간, 경과 시간 등을 점검하기 위해 가상의 시스템 부하나 스트레스를 통해 성능을 분석하는 도구이다.\r\n- 모니터링(Monitoring) 도구 : 성능 모니터링, 성능 저하 원인 분석, 시스템 부하량 분석, 장애 진단, 사용자 분석, 용량 산정 등의 기능을 통하여 애플리케이션 실행 시 자원 사용량을 확인하고 분석 가능한 도구이다.\r\n\r\n## 애플리케이션 성능 저하 원인\r\n\r\n### DB 연결 및 쿼리 실행 시 발생되는 성능 저하 원인\r\n\r\n1. DB Lock\r\n   - 과도한 데이터 조회/업데이트/인덱스 생성 시 발생한다.\r\n   - Lock의 해제 시까지 대기하거나 처리되지 못하고 종료된다.\r\n2. 불필요한 DB Fetch\r\n   - 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 발생한다.\r\n   - 결과 세트에서 마지막 위치로 커서를 옮기는 작업이 빈번한 경우 응답 시간 저하 현상이 발생한다.\r\n3. 연결 누수(Connection Leak)\r\n   - DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생한다.\r\n4. 부적절한 Connection Pool Size\r\n   - 커넥션 풀 크기가 너무 작거나 크게 설정한 경우 발생한다.\r\n5. 기타\r\n   - 트랜잭션이 Commit되지 않고 커넥션 풀에 반환되거나, 잘못 작성된 코드로 인해 불필요한 commit이 자주 발생하는 경우 발생한다.\r\n\r\n### 내부 로직으로 인한 성능 저하 원인\r\n\r\n- 웹 애플리케이션의 인터넷 접속 불량이나 대량의 파일로 인해 부하가 발생하는 경우이다.\r\n- 정상적으로 처리되지 않은 오류 처리로 인한 부하나 트랜잭션이 수행되는 동안 외부 트랜잭션(외부 호출)이 장시간 수행되거나, 타임아웃이 일어나는 경우이다.\r\n\r\n### 잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인\r\n\r\n- 환경 설정으로 인한 성능 저하 : Thread pool, Heap Memoty의 크기를 너무 작게 설정하면 Heap Memory Full 현상이 발생한다.\r\n- 네트워크 장비로 인한 성능 저하 : 라우터, L4 스위치 등 네트워크 관련 장비 간 데이터 전송 실패 또는 전송 지연에 따른 데이터 손실이 발생한다.\r\n\r\n# 알고리즘\r\n\r\n- 주어진 과제를 해결하기 위한 방법과 절차를 의미한다.\r\n- 알고리즘은 자연어, 의사코드(Pseudocode), 순서도, 프로그래밍 언어를 이용하여 표현 가능하다.\r\n\r\n1. 분할 정복법(Divide \u0026 Conquer)\r\n   - 제시된 문제를 분할이 불가할 때까지 나누고, 각 과제를 풀면서 다시 병합해 문제의 답을 얻는 Top-down 방식이다.\r\n   1. 분할(Divide) : 정복이 필요한 과제를 분할이 가능한 부분까지 분할하고,\r\n   2. 정복(Conquer) : 1에서 분할된 하위 과제들을 모두 해결(정복)한다.\r\n   3. 결합(Combine) : 그리고 2에서 정복된 해답을 모두 취합(결합)한다.\r\n   - ex. Quick sort, Merge sort 알고리즘\r\n2. 동적 계획법(Dynamic Programming)\r\n   - 주어진 문제를 해결하기 위해 부분 문제에 대한 답을 계속적으로 활용해 나가는 Bottom-up 방식이다.\r\n     1. 부분 문제로 분리\r\n     2. 가장 낮은 단계의 부분 문제 해답 계산\r\n     3. 이 부분 문제의 해답을 이용해 상위 부분 문제를 해결\r\n   - 이전 단계의 해답을 활용하기 위해 반드시 기억할 수 있는 저장소가 필요하기 때문에 속도는 빠르지만, 공간 복잡도가 커지는 단점이 있다.\r\n   - ex. 플로이드 알고리즘, 피보나치 수열 알고리즘(재귀 호출(동적 계획법) 뿐만 아니라 분할 정복법을 통해서도 구현 가능)\r\n3. 탐욕법(Greedy Method)\r\n   - 국소적인 관점에서 최적의 해결 방법을 구하는 기법으로 최적의 해결 방법을 구하지는 못하나 동적 계획법보다 효율적이라고 할 수 있다.\r\n   - ex. 크루스칼 알로리즘, 다익스트라 알고리즘\r\n4. 백트래킹(Back tracking)\r\n   - 어떤 문제의 최적해를 구하기 위해 모든 가능성을 찾아가는 방법이다.\r\n   - N-Queen 문제 해결 시에 응용된다. -동적 계획법과 같이 기억할 저장소를 필요로 한다.\r\n5. 분기 한정법(Branch \u0026 Bound)\r\n   - 정해진 범위(Bound)를 벗어나는 값들은 가지치기(Branch)해가며 결과값을 추적해 나가는 방식이다.\r\n   - ex. 최적 우선 탐색(Best First Search) 알고리즘, A\\* 알고리즘\r\n6. 근사 해법(Approximation Algorithm)\r\n   - 복잡도가 매우 높은 문제게 대해 가장 근사치의 값을 구하는 기법이다.- NP-Hard 문제를 해결하기 위해, 주어진 시간에 최적해를 가장 가까운 답을 찾는 결정성 알고리즘을 구현하는 기법이다.\r\n   - 시간 복잡도, 공간 복잡도, 정밀도를 척도로 평가된다.\r\n   - ex. 근사 알고리즘\r\n\r\n### 시간 복잡도에 따른 알고리즘\r\n\r\n- 시간 복잡도는 알고리즘이 문제를 해결하기 위한 시간(연산)의 횟수를 말한다.\r\n- 시간 복잡도를 고려하는 것을 최적화를 위해 필요하다.\r\n- 알고리즘의 소요 시간에 대한 정확한 평가는 어려워 자료의 수 n이 증가할 때 시간이 증가하는(Time Complexity) 대략적인 패턴을 의미한다.\r\n- 시간 복잡도 Big-O 표기법\r\n  - O(1) : 상수 시간의 복잡도를 의미하며 입력값 n이 주어졌을 때, 문제를 해결하는데 오직 한 단계만 거친다.(해시 함수).\r\n  - O(log₂n) : 로그 시간의 복잡도를 의미하며 입력값 n이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.(이진 탐색)\r\n  - O(nlog₂n) : 선형 로그 시간의 복잡도를 의미하며, 문제 해결을 위한 단계 수는 n log2 n 번의 수행 시간을 갖는다.(퀵 정렬, 병합 정렬)\r\n  - O(n) : 선형 시간의 복잡도를 의미하며 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계이다.(순차 탐색)\r\n  - O(n²) : 제곱 시간의 복잡도를 의미하며 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱근이다.(버블 정렬, 삽입 정렬, 선택 정렬)\r\n  - O(Cⁿ) : 지수 시간의 복잡도를 의미하며 문제를 해결하기 위한 단계의 수는 주어진 상수값 C의 n 제곱이다.\r\n\r\n# 소스 코드 최적화\r\n\r\n- 읽기 쉽고 변경 및 추가가 쉬운 클린 코드를 작성하는 것을 의미한다.\r\n- 소스 코드 품질을 위해 기본적으로 지킬 원칙과 기준을 정의하고 있다.\r\n- 나쁜 코드\r\n  - 다른 개발자가 로직을 이해하기 어렵게 작성된 코드\r\n  - 변수/메서드에 대한 명칭을 알 수 없는 코드이다. -동일한 처리 로직이 중복되게 작성된 코드이다.\r\n  - 스파게티 코드\r\n  - 유형 : 오염, 문서 부족, 의미 없는 이름, 높은 결합도, 아키텍처 침식\r\n- 클린 코드\r\n  - 깔끔하게 잘 정리된 코드\r\n  - 중복 코드 제거로 애플리케이션의 설계가 개선된다.\r\n  - 가독성이 높아 애플리케이션의 기능에 대해 쉽게 이해할 수 있다.\r\n  - 버그를 찾기 쉬워지며, 프로그래밍 속도가 빨라진다.\r\n  - 클린 코드 최적화 원칙 : 가독성, 단순성, 의존성 배제, 중복성 취소화, 추상화\r\n  - 유형 : 보기 좋은 배치, 작은 함수, 분석 가능한 제어 흐름, 오류 처리, 간결한 주석, 의미 있는 이름\r\n\r\n### 코드 간결성 유지 지침\r\n\r\n- 공백을 이용하여 실행문 그룹과 주석을 명확히 구분하고, 복잡한 논리식과 산술식은 괄호와 들여쓰기(Indentation)를 통해 명확히 표현한다.\r\n- 빈 줄을 사용하여 선언부와 구현부를 구별하고 한 줄에 되도록 적은 문장을 코딩한다.\r\n\r\n### 클린 코드의 작성 원칙\r\n\r\n- 가독성 : 이해하기 쉬운 용어를 사용하고 들여쓰기 등을 활용하여 코드를 쉽게 읽을 수 있도록 작성한다.\r\n- 단순성 : 클래스/메서드/함수는 최소 단위로 분리해 한 번에 한 가지 기능만 처리한다.\r\n- 의존성 배체 : 다른 모듈에 미치는 영향을 최소화하여 코드 변경 시 다른 부분에 영향이 없도록 작성한다.\r\n- 중복성 최소화 : 중복된 코드는 삭제하여 공통된 코드로 사용한다.\r\n- 추상화 : 상위 클래스/메서드/함수에서 간략하게 애플리케이션 특성을 나타내고, 상세 내용은 하위 클래스/메서드/함수에서 구현한다.\r\n\r\n### 소스 코드 최적화 유형\r\n\r\n1. 클래스 분할 배치\r\n   - 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이도록 한다.\r\n   - 모듈 크기를 작게 작성한다.\r\n2. 좋은 이름 사용\r\n   - 변수나 함수 이름은 Namming Rule을 정의하여 기억하기 좋고, 발음이 쉽게 사용한다.\r\n3. 코딩 형식 준수\r\n   - 개념적 유사성 높은 종속 함수를 사용하여 논리적으로 코드를 라인별로 구분하여 가독성을 높이다.\r\n   - 호출하는 함수 앞쪽에, 호출되는 함수를 배치하고, 지역 변수는 각 함수 맨 처음에 선언한다.\r\n4. 느슨한 결합(Loosely Coupled)\r\n   - 클래스 간 의존성이 느슨하게 하기 위해 인터페이스 클래스를 이용하여 추상화된 자료 구조와 메서드를 구현한다.\r\n5. 적절한 주석\r\n   - 코드의 간단한 기능 안내 및 중요 코드를 표시할 때 적절히 사용한다.\r\n\r\n# 인터페이스 구현\r\n\r\n- 송/수신 시스템 간의 데이터 교환 및 처리를 실현해주는 작업이다.\r\n- 사전에 정의된 기능 구현을 분석하고 인터페이스를 구현한다.\r\n- 인터페이스 기능 구현을 기반으로 인터페이스 구현 방법을 분석하고 분석된 인터페이스 구현 정의를 바탕으로 인터페이스를 구현한다.\r\n\r\n### AJAX(Asynchronous Javascript And Xml)\r\n\r\n- javascript를 사용한 비동기 통신 기술로 클라이언트와 서버 간에 XML 데이터를 주고받는 기술이다.\r\n- 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법이다.\r\n\r\n### JSON(Javascript Object Notation)\r\n\r\n- 데이터 통신을 이용한 인터페이스 구현 방법이다.\r\n- 웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성/값의 쌍 형태로 표현하는 형식으로 JS를 토대로 개발된 형식이다.\r\n- 속성/값의 쌍(Attribute-Value Pairs)인 데이터 객체 전달을 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷으로 비동기 처리에 쓰이는 AJAX에서 XML을 대체하는 주요 데이터 포맷이다.\r\n\r\n# 인터페이스 보안\r\n\r\n- 모듈 컴포넌트 간 데이터 교환 시 데이터 변조/탈취 및 인터페이스 모듈 자체의 보안 취약점이 존재할 수 있다.\r\n\r\n1. 데이터 통신 시 데이터 탈취 위협\r\n   - 스니핑(Sniffing) : 네트워크 주변을 지나다니는 패킷을 엿보면서 계정(ID)과 비밀번호를 알아내는 보안 위협이다.\r\n   - 스푸핑(Spoofing) : 일반 사용자가 인터넷상에서 통신하는 정보를 크래커의 사이트를 통하도록 하여 비밀번호를 알아내는 보안 위협이다.\r\n2. 데이터베이스 암호화\r\n   - 데이터베이스의 기밀성을 유지하기 위해 중요 민감 데이터는 암호화한다.\r\n   - 대칭 키, 해시, 비대칭키 알고리즘이 사용된다.\r\n3. 시큐어 코딩\r\n   - OWASP(Open Web Application Security Project) Top 10을 참고하여 KISA(한국 인터넷 진흥원)에서 SW 보안 약점 가이드를 발표하였다.\r\n   - SW 보안 취약점, 약점 및 대응 방안이 구체적으로 서술되어 있으며 이를 바탕으로 시큐어 코딩을 하도록 한다.\r\n\r\n# 데이터베이스 보안\r\n\r\n- 데이터베이스의 기밀성 유지를 위하여 중요하고 민감한 데이터는 암호화 기법을 활용하여 암호화하도록 한다.\r\n- 데이터베이스의 접근 권한 및 SQL, 프로시져, 트리거 등 데이터베이스 동작 객체의 보안 취약점을 보완하도록 한다.\r\n- 민감하고 중요한 데이터는 암호화와 익명화 등을 통하여 데이터 자체 보안 방법도 고려해야 한다.\r\n- 영역 : 비인가자 접근 관리, 악의적 코드 삽입 금지, 민감 데이터 관리, 악의적 시도 시 에러 처리\r\n\r\n### 데이터베이스 암호화 알고리즘\r\n\r\n- 대칭키 알고리즘 : ARIA 128/129/256, SEED\r\n- 해시 알고리즘 : SHA-256/384/512, HAS-160\r\n- 비대칭키 알고리즘 : RSA, ECDSA, ECC\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n"},{"title":"sw first test1","description":"정보처리기사 필기(1) - 소프트웨어 설계","category":"sw","keyword":"정보처리기사, 정처기, 필기, 소프트웨어 설계","date":"2023-12-24","content":"\r\n## 필기 시험 공략\r\n\r\n개인적으로 필기 시험의 경우 기출문제를 많이 풀어보는 것으로 충분하다고 생각한다.\r\n\r\n구글 앱 스토어에서 \"**정보처리기출문제**\"라는 키워드로 검색해서 앱에 등록된 문제들을 많이 풀어보면 좋을 것 같다.\r\n\r\n나의 경우 아래의 순서로 필기한 후, 기출문제를 많이 풀어본 후에 시험을 쳤다.\r\n\r\n표 등 일부 내용은 깃허브에서 보는 것이 더 편하다.\r\n\r\n1. [소프트웨어 설계](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n\r\n2. [소프트웨어 개발](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/2.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EA%B0%9C%EB%B0%9C)\r\n\r\n3. [DB구축](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/3.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EA%B5%AC%EC%B6%95)\r\n\r\n4. [프로그래밍 언어 활용](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/4.%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4%20%ED%99%9C%EC%9A%A9)\r\n\r\n5. [정보시스템 구축 관리](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/5.%20%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B5%AC%EC%B6%95%20%EA%B4%80%EB%A6%AC)\r\n\r\n본문은 요약본으로, 노출 빈도가 높다고 느낀 키워드는 ★표로 강조하였다.\r\n\r\n---\r\n\r\n# 소프트웨어\r\n\r\n### 소프트웨어(SW)의 개념\r\n\r\n- 컴퓨터를 동작시키고 어떤 일의 처리 순서와 방법을 지시하는 명령어의 집합인 프로그램과 프로그램의 수행에 필요한 절차, 규칙, 관련 문서 등의 총칭\r\n- 프로그램(Program) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합\r\n- 자료 구조(Data Structure) : 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭하는 것으로, 데이터 간의 논리적 관계나 처리 알고리즘\r\n- 문서(Paper) : 소프트웨어를 개발함에 있어 사용자 설명서, 소프트웨어 요구분석서, 평가서, 명세서, 프로젝트 계획서, 검사 계획서 등\r\n\r\n### 소프트웨어의 특징\r\n\r\n- 상품성 : 소프트웨어를 개발하면 상품이 되어 판매가 된다.\r\n- 복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다.\r\n- 변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다.\r\n- 복제성 : 복제가 용이해 쉽게 복사, 유통이 가능하다.\r\n\r\n### 시스템(System)의 개요와 기본 요소\r\n\r\n- 시스템의 개요\r\n  - 컴퓨터로 처리 가능한 자료를 입력하고 저장, 처리, 가공해 출력할 수 있도록 설계/구현된 정보 체계를 의미한다.\r\n  - 하나의 목적을 위해 다양한 요소가 유기적으로 결합된 것을 의미한다.\r\n- 기본 요소\r\n  - 입력, 처리, 출력, 제어, 피드백으로 구성된다.\r\n\r\n### 소프트웨어 위기(Software Crisis)\r\n\r\n- 컴퓨터의 발달 과정에서 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없는 문제가 발생함을 의미한다.\r\n- 소프트웨어 위기의 원인\r\n  - 하드웨어 비용을 초과하는 개발 비용의 증가\r\n  - 개발 기간의 지연\r\n  - 개발 인력 부족 및 인건비 상승\r\n  - 성능 및 신뢰성 부족\r\n  - 유지보수의 어려움에 따른 엄청난 비용\r\n\r\n# 소프트웨어 공학\r\n\r\n### 소프트웨어 공학이란?\r\n\r\n- 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 방법, 도구와 절차들의 체계를 말한다.\r\n- IEEEE(전기/전자기술협회)는 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법이라 정의하였다.\r\n\r\n### 소프트웨어 공학의 기본 원칙\r\n\r\n- 현대적인 프로그래밍 기술을 적용해야 한다.\r\n- 신뢰성이 높아야 한다.\r\n- 사용의 편리성과 유지보수성이 높아야 한다.\r\n- 지속적인 검증 시행을 해야 한다.\r\n\r\n### 소프트웨어 공학 계층 구조\r\n\r\n- 도구 : 프로세스와 방법을 처리하는 기능을 제공하는 것\r\n- 방법론 : 소프트웨어를 설계하는데 기술적인 방법을 제공하는 것\r\n- 프로세스 : 소프트웨어의 가장 기초가 되며 개발에 사용되는 방법론과 도구가 적용되는 순서를 의미한다.\r\n\r\n### 소프트웨어 품질\r\n\r\n- 사용자의 요구대로 만들어져야 한다.\r\n- 유지보수가 쉬워야 한다.\r\n- 에러를 최소화해야 한다.\r\n- 초반에 정한 비용에 맞춰 개발해야 한다.\r\n- 정확한 결과가 도출되어야 한다.\r\n- 원하는 시간에 원하는 기능을 수행할 수 있어야 한다.\r\n\r\n### 소프트웨어 공학의 목표\r\n\r\n- 소프트웨어의 생산성과 품질을 향상시킨다.\r\n- 최소의 비용으로 단기간에 시스템에 적합한 소프트웨어를 개발하는 것이 소프트웨어 공학의 궁극적 목적이다.\r\n\r\n### 소프트웨어 재공학(Software Reengineering)\r\n\r\n- 재공학의 개념\r\n  - 소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법을 의미한다.\r\n  - 현재의 시스템을 변경하거나 재구조화(Restructuring)하는 것이다.\r\n    - 재구조화: 재공학의 한 유형으로 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선하는 것\r\n  - 소프트웨어 재공학 관점에서 가장 연관 싶은 유지보수 유형은 예방 유지보수(Preventive Maintenance)이다.\r\n- 재공학의 장점\r\n  - 개발 시간 및 비용 감소\r\n  - 품질 향상\r\n  - 생산성 향상\r\n  - 신뢰성 향상\r\n  - 구축 방법에 대한 지식의 공유\r\n  - 프로젝트 실패 위험 감소\r\n- 재공학의 목표\r\n  - 소프트웨어의 유지보수성 향상이 최우선\r\n  - 복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거\r\n  - 수월한 재사용과 소프트웨어의 수명 연장\r\n- 과정\r\n  - 분석(Analysis) =\u003e 구성(Restructuring) =\u003e 역공학(Reverse Engineering) =\u003e 이식(Migration)\r\n\r\n### 역공학\r\n\r\n- 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어내는 작업\r\n- 역공학의 가장 간단하고 오래된 형태 == 재문서화\r\n\r\n# CASE (Computer Aided Software Engineering) ★★★\r\n\r\n### CASE란?\r\n\r\n- 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업이다.\r\n- 자료 흐름도 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어 CASE 도구이다.\r\n- 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대한다.\r\n\r\n### CASE가 제공하는 기능\r\n\r\n- 개발을 신속하게 할 수 있고, 오류 수정이 쉬워 소프트웨어 품질이 향상된다.\r\n- 소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화시켜 주는 통합된 도구를 제공해주는 기술이다.\r\n- 소프트웨어 시스템의 문서회 및 명세화를 위한 그래픽 기능을 제공한다.\r\n- 소프트웨어 개발 단계의 표준화를 기할 수 있으며, 자료 흐름도 작성 기능을 제공한다.\r\n- 모델들 사이의 모순 검사 기능을 제공하며 다양한 소프트웨어 개발 모형을 지원한다.\r\n- 원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술\r\n\r\n### CASE 사용의 장점\r\n\r\n- 소프트웨어 개발 기간 단축 및 개발 비용을 절약하여 소프트웨어 생산성을 향상시킨다.\r\n- 자동화된 검사를 통해 소프트웨어 품질이 향상된다.\r\n- 프로그램의 유지보수가 간편해지고 소프트웨어 모듈의 재사용성이 향상된다.\r\n- 소프트웨어 개발 주기의 표준안 확립, 소프트웨어 개발 기법의 실용화, 문서화의 용이성 제공, 시스템 수정 및 유지보수 축소 등의 효과를 얻을 수 있다.\r\n\r\n### CASE의 분류\r\n\r\n- 상위(Upper) CASE : 요구분석 및 설계 단계 지원\r\n- 하위(Lower) CASE : 소스 코드 작성, 테스트, 문서화 과정 지원\r\n- 통합(Integrate) CASE : 소프트웨어 개발 주기 전체 과정 지원\r\n\r\n### 요구사항 분석을 위한 CASE 도구\r\n\r\n- SADT(Structured Analysis and Design Technique) : SoftTech 사에서 개발한 것으로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위해 널리 이용되어 온 구조적 분석 및 설계 도구이다. 구조적 요구분석을 하귀 위해 블록 다이어그램을 채택한 자동화 도구다.\r\n- REM( Software Requirements Engineering Methodolohy) = RSL/REVS : TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 것으로, RSL과 REVS를 사용하는 자동화 도구다.\r\n  - RSL(Requirement Statement Language) : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어이다.\r\n  - REVS(Requirement Engineering and Validation System) : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분ㅅ거 명세서를 출력하는 요구사항 분석기다.\r\n\r\n# 소프트웨어 개발 방법론 ★★★\r\n\r\n### 소프트웨어 생명주기(Software Life Cycle)\r\n\r\n- 소프트웨어 제품의 개념 형성에서 시작하여 운용/유지보수에 이르기까지 변화의 모든 과정이다.\r\n- 당성 검토 =\u003e 개발 계획 =\u003e 요구사항 분석 =\u003e 설계 =\u003e 구현 =\u003e 테스트 =\u003e 운용 =\u003e 유지보수\r\n\r\n### 폭포수 모형(Waterfall Model) - 순차적 모델\r\n\r\n- 선형 순차적 모델이라고도 하며, Boehm이 제시한 고전적 생명주기 모형으로, 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 모형이다.\r\n\r\n### 나선형 모형(Spiral Model) - 점증적 위험관리 모델\r\n\r\n- Boehm이 제시하였으며, 반복적인 작업을 수행하는 점증적 생명주기 모형이다.\r\n- 점증적 모형, 집중적 모형이라고도 하며 유지보수 과정이 필요 없다.\r\n- 소프트웨어 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적이다.\r\n- 나선을 따라서 돌아가면서 각 개발 순서를 반복하여 수행하는 점진적 방식으로 누락된 요구사항을 추가할 수 있다.\r\n  - 목표설정 =\u003e 위험분석 =\u003e 개발과 검증 =\u003e 고객평가/다음단계 수립 =\u003e 목표설정\r\n\r\n### 하향식/상향식 설계\r\n\r\n- 하향식 설계 : 소프트웨어 설계 시 제일 상위에 있는 Main User Function에서 시작하여 기능을 하위 기능들로 나눠가며 설계하는 방식이다.\r\n- 상향식 설계 : 가장 기본적인 컴포넌트를 먼저 설계한 다음 이것을 사용하는 상위 수준의 컴포넌트를 설계하는 방식이다.\r\n\r\n### 프로토타입 모형(Prototype Model)\r\n\r\n- 실제 개발될 시스템의 견본(Prototype)을 미리 만들어 최종 결과물을 예측하는 모형이다.\r\n- 개발이 완료되고 나서 사용을 하면 문제점을 할 수 있는 폭포수 모형의 단점을 보완하기 위한 모형으로 요구사항을 충실히 반영할 수 있다.\r\n\r\n### HIPO(Hierarchy Input Process Output)\r\n\r\n- 입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법이다.\r\n- 일반적으로 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Overview Diagram), 세부적 다이어그램(Detail Diagram)으로 구성된다.\r\n- 구조도(가시적 도표, Visual Table of Contents), 개요, 도표(Index Diagram), 상세 도표(Detail Diagram)로 구성된다.\r\n- 가시적 도표는 전체적인 기능과 흐름을 보여주는 구조이다.\r\n- 기능과 자료의 의존 관계를 동시에 표현할 수 있다.\r\n- 보기 쉽고 이해하기 쉬우며 유지보수가 쉽다.\r\n- 하향식 소프트웨어 개발을 위한 문서화 도구이다.\r\n\r\n### V-모델\r\n\r\n- 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델이다.\r\n- 세부적인 프로세스로 구성되어 있어서 신뢰도 높은 시스템 개발에 효과적이다.\r\n- 개발 단계의 작업을 확인하기 위해 테스트 작업을 수행한다.\r\n- 생명주기 초반부터 테스트 작업을 지원한다.\r\n- 코드뿐만 아니라 요구사항과 설계 결과도 테스트할 수 있어야 한다.\r\n- 폭포수 모형보다 반복과 재처리 과정이 명확하다.\r\n- 테스트 작업을 단계별로 구분하므로 책임이 명확해진다.\r\n\r\n### 애자일(Agile) 개발 방법론\r\n\r\n- 날렵한, 재빠른 이란 사전적 의미가 있다.\r\n- 특정 방법론이 아닌 소프트웨어를 빠르고 낭비 없이 제작하기 위해 고객과의 협업에 초점을 두고 소프트웨어 개발 중 설계 변경에 신속히 대응하여 요구사항을 수용할 수 있다.\r\n- 절차와 도구보다 개인과 소통을 중요시하고 고객과의 피드백을 중요하게 생각한다.\r\n- 소프트웨어가 잘 실행되는데 가치를 두며, 소프트웨어 배포 시차를 최소화할 수 있다.\r\n  - 특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션 변화\r\n  - 종류\r\n    - 익스트림 프로그래밍(XP, eXtreame Programming)\r\n    - 스크럼(SCRUM)\r\n    - 린(Lean)\r\n    - DSDM(Dynamic System Development, 동적 시스템 개발 방법론)\r\n    - FDD(Feature Driven Development, 기능 중심 개발)\r\n    - Crystal\r\n    - ASD(Adaptive Software Development, 적응형 소프트웨어 개발방법론)\r\n    - DAD(Disciplined Agile Delivery, 학습 애자일 배포)\r\n- Agile 선언문\r\n  - 프로세스나 도구보다 개인과의 소통이 더 중요하다.\r\n  - 완벽한 문서보다 실행되는 소프트웨어가 더 중요하다.\r\n  - 계약 협상보다 고객과의 협업이 더 중요하다.\r\n  - 계획을 따르는 것보다 변경에 대한 응답이 더 중요하다.\r\n\r\n#### XP (eXtream Programming)\r\n\r\n- 개념\r\n  - 1999년 Kent Beck이 제안하였으며, 개발 단계 중 요구사항이 시시각각 변동이 심한 경우 적합한 방법론\r\n  - 요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 함\r\n  - 요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 적용하는 방식으로, 예측성보다는 적응성에 더 높은 가치를 부여한 방법\r\n  - 고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법\r\n- 핵심 가치\r\n  - 소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향한다.\r\n  - 단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다.\r\n  - 피드백(Feedback) : 소프트웨어 개발에서 변화는 불가피하므로 지속적 테스트와 통합, 반복적 결함 수정 등 빠르게 피드백한다.\r\n  - 용기(Courage) : 고객 요구사항 변화에 능동적으로 대응한다.\r\n  - 존중(Respect) : 개발 팀원 간의 상호 존중을 기본으로 한다.\r\n- 효과적인 프로젝트 관리를 위한 3대 요소\r\n  - 사람(People) : 인적 자원\r\n  - 문제(Problem) : 문제 인식\r\n  - 프로세스(Process) : 작업 계획\r\n\r\n#### SCRUM\r\n\r\n- 개념과 특징\r\n  - 요구사항 변경에 신속하게 대처할 수 있는 반복적이고 점진적인 소규모 팀원 간 활발한 소통과 협동심이 필요한 팀 중심의 소프트웨어 개발 방법론\r\n  - 신속하게 반복적으로 실제 작동하는 소프트웨어를 제공\r\n  - 개발자들의 팀 구성과 각 구성원의 역할, 일정 결과물 및 그 외 규칙을 정하는 것을 의미\r\n  - 기능 개선점에 우선순위를 부여하고, 개발 주기 동안 실제 동작 가능한 결과를 제공\r\n  - 개발 주기마다 적용된 기능이나 개선점의 리스트를 제공\r\n  - 커뮤니케이션을 위해 팀은 개방된 공간에서 개발하고, 매일 15분 정도 짧은 회의를 함\r\n  - 팀원 스스로 팀을 구성해야 함(Self Organizing)\r\n- 기본 원리\r\n  - 기능 협업을 기준으로 배치된 팀은 스프린트 단위로 소프트웨어를 개발한다.\r\n  - 스프린트는 고정된 30일의 반복이며, 스프린트를 시행하는 작업은 고정된다.\r\n  - 요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 한다.\r\n  - 정해진 시간을 철저히 지켜야 하며, 완료된 모든 작업은 제품 백로그에 기록된다.\r\n  - 가장 기본적인 정보 교환 수단은 일일 스탠드 업 미팅, 또는 일일 스크럼이다.\r\n\r\n# 요구사항 개발 ★★★\r\n\r\n### 요구공학(Requirements Engineering)\r\n\r\n- 요구공학의 개념\r\n  - 소프트웨어 개발 시 사용자 요구가 정확히 반영된 시스템 개발을 위해 사용자의 요구를 추출, 분석, 명세, 검증, 관리하는 구조화된 활동 집합이다.\r\n  - 요구사항을 정의하고, 문서로 만들고 관리하는 프로세스를 의미한다.\r\n  - 효과적인 의사소통을 통하여 공통 이해를 설정하며, 불필요한 비용 절감, 요구사항 변경 추적이 가능해진다.\r\n  - 분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용할 수 있다.\r\n  - 자료 흐름도, 자료 사전 등이 효과적으로 이용될 수 있으며, 더 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 활용될 수 있다.\r\n- 요구공학의 목적\r\n  - 소프트웨어 개발 시 이해관계자 사이의 원활한 의사소통 수단을 제공한다.\r\n  - 요구사항 누락 방지, 상호 이해 오류 등의 제거로 경제성을 제공한다.\r\n  - 요구사항 변경 이력 관리를 통하여 개발 비용 및 시간을 절약할 수 있다.\r\n  - 비용과 일정에 대한 제약설정과 타당성 조사, 요구사항 정의 문서화 등을 수행한다.\r\n- 요구공학(개발) 프로세스\r\n  - 요구사항을 명확히 분석하여 검증하는 진행 순서를 의미한다.\r\n  - 개발 대상에 대한 요구사항을 체계적으로 도출한다.\r\n  - 도출된 요구사항을 분석하여 분석 결과를 명세서에 정리한다.\r\n  - 정리된 명세서를 마지막으로 확인, 검증하는 일련의 단계를 말한다.\r\n  - 경제성, 기술성, 적법성, 대안성 등 타당성 조사가 선행되어야 한다.\r\n\r\n### 요구사항 분류 기준\r\n\r\n- 기능적 요구사항 : 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항(ex. A라는 기능이 있어야 한다.)\r\n- 비기능적 요구사항 : 시스템 구축에 대한 성능, 보안, 품질, 안정성 등으로 실제 수행에 보조적인 요구사항(ex. 몇 초 내로 A라는 화면이 보였으면 좋겠다 등)\r\n\r\n### 요구사항 명세(Requirement Specification)\r\n\r\n- 시스템 정의, 시스템 요구사항, 소프트웨어 요구사항을 작성한다.\r\n- 체계적으로 검토, 평가, 승인될 수 있도록 문서로 만드는 것을 의미한다.\r\n- 기능 요구사항은 빠지는 부분 없이 명확하게 기술한다.\r\n- 비기능 요구사항은 필요한 것만 명확하게 기술한다.\r\n- 개발자가 효과적으로 설계할 수 있고 사용자가 쉽게 이해할 수 있도록 한다.\r\n\r\n### 요구사항 명세 속성\r\n\r\n- 정확성 : 요구사항은 정확해야 한다.\r\n- 명확성 : 단 한 가지로만 해설되어야 한다.\r\n- 완전성 : 모든 것이 표현(기능+비기능) 가능해야 한다.\r\n- 일관성 : 요구사항 간 충돌이 없어야 한다.\r\n- 수정 용이성 : 요구사항 변경이 가능해야 한다.\r\n- 추적성 : RFP, 제안서를 통해 추적 가능해야 한다.\r\n\r\n### 형상관리(Configuration Management)\r\n\r\n- 애플리케이션 개발 단계에서 도출되는 프로그램, 문서, 데이터 등의 모든 자료를 형상 단위라고 하며, 이러한 자료의 변경을 관리함으로써 애플리케이션 버전 관리 등을 하는 활동이다.(ex. Git, SVN(subversion), Apache CVS 등)\r\n\r\n# UML (Unified Modeling Language) ★★★\r\n\r\n### 개념 모델링(Conceptual Modeling)\r\n\r\n- 요구사항을 이해하기 쉽도록 실 세계의 상황을 단순화하여 개념적으로 표현한 것을 모델이라고 하고, 이렇게 표현된 모델을 생성해 나가는 과정을 개념 모델링이라고 한다.\r\n- 모델은 문제가 발생하는 상황에 대한 이해를 증진하고 해결책을 설명하므로 소프트웨어 요구사항 분석의 핵심이라 할 수 있다.\r\n- 개발 대상 도메인의 엔티티(Entity)들과 그들의 관계 및 종속성을 반영한다.\r\n- 요구사항별로 관점이 다르므로 개념 모델도 다양하게 표현되어야 한다.\r\n- 대부분 UML(Unified Modeling Language)을 사용한다.\r\n- 종류 : Use Case Diagram, Data Flow Model, State Model, Goal-Based Model, User Interactions, Object Model, Data Model\r\n\r\n### UML (Unified Modeling Language)\r\n\r\n- UML 개념\r\n  - 객체지향 소프트웨어 개발 과정에서 시스템 분석, 설계, 구현 등의 산출물을 명세화, 시각화, 문서화 할 때 사용하는 모델링 기술과 방법론을 통합하여 만든 범용 모델링 언어이다.\r\n  - Rumbaugh의 OMT 방법론과 Booch의 Booch 방법론, Jacobson의 OOSE 방법론을 통합하여 만든 모델링 개념의 공통 집합으로, 객체지향 분석 및 설계 방법론의 표준 지정을 목표로 제안된 모델링 언어이다.\r\n  - OMG(Object Management Group)에서 표준화 공고 후 Microsoft, Oracle 등이 참여하여 1997.1 버전 1.0을 Release 하였다.\r\n- 럼바우(Rumbaugh) 객체지향 분석 기법\r\n  - 소프트웨어 구성 요소를 그래픽으로 모형화하였다.\r\n  - 객체 모델링 기법이라고도 한다.\r\n    - 객체 모델링 : 정보 모델링이라고도 한다. 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체를 다이어그램으로 표시한다.(OMT : Object Modeling Technique)\r\n    - 동적 모델링 : 제어 흐름, 상호작용, 동작 순서 등의 상태를 시간 흐름에 따라 상태 다이어그램으로 표시한다.\r\n    - 기능 모델링 : 여러 프로세스 간의 자료 흐름을 표시한다. 어떤 데이터를 입력하여 어떤 결과를 가져올 수 있을지를 표현한다.\r\n- UML의 특성\r\n  - 비주얼화 : 소프트웨어 구성 요소 간의 관계 및 상호작용을 시각화한 것이다.\r\n  - 문서화 : 소프트웨어 생명주기의 중요한 작업을 추적하고 문서화할 수 있다. 개발 프로세스 및 언어와 무관하게 개발자 간의 의사소통 도구를 제공한다.\r\n  - 명세화 : 분석, 설계, 구현의 완벽한 모델을 제공한다. 분석 단계-기능 모델, 설계 단계-동작 수준 모델, 구현 단계-상호작용 모델 수준으로 명세화할 수 있다. 단순 표기법이 아닌 구현에 필요한 개발적 요소 및 기능에 대한 명세를 제공한다.\r\n  - 구축 : 객체지향 언어와 호환되는 프로그래밍 언어는 아니지만, 모델이 객체지향 언어로 매핑될 수 있다.\r\n- UML 소프트웨어에 대한 관점\r\n  - 기능적 관점 : 사용자 측면에서 본 소프트웨어의 기능을 나타낸다. 사용 사례 모델링이라고도 한다. 요구분석 단계에서 사용한다. UML에서는 Use Case Diagram을 사용한다.\r\n  - 정적 관점 : 소프트웨어 내부의 구성 요소 사이의 구조적 관계를 나타낸다. 객체, 속성, 연관 관계, 오퍼레이션의 시스템 구조를 나타내며, UML에서는 Class Diagram을 사용한다. (ex. 클래스 사이의 관계, 클래스 구성과 패키지 사이의 관계)\r\n  - 동적 관점 : 시스템의 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사용한다.\r\n- UML의 기본 구성\r\n  - 사물(Things)\r\n  - 관계(Relationship)\r\n  - 다이어그램(Diagram)\r\n\r\n### Use Case Diagram\r\n\r\n- 객체지향 초반기 분석 작업에 작성되는 사용자의 요구를 기능적 측면에서 기술할 때 사용되는 도구로 Actor와 User Case로 구성된다.\r\n- 얻어지는 결과는 개발 대상 시스템이 제공해야 하는 서비스 목록이 된다.\r\n\r\n#### Use Case Diagram 요소\r\n\r\n- 시스템 경계(System Boundary)\r\n- 액터(Actor)\r\n- 유스케이스(Use Case)\r\n- 접속 관계(Communication Association)\r\n- 사용 관계(Uses Association)\r\n- 확장 관계(Extends Association)\r\n\r\n#### Use Case Diagram 작성단계\r\n\r\n- 액터 식별\r\n- Use Case 식별\r\n- 관계 정의\r\n- Use Case 구조화\r\n\r\n# UI (User Interface) / UX (User eXperience) ★★★\r\n\r\n### UI\r\n\r\n- 인간, 디지털 기기, 소프트웨어 사이에서 의사소통할 수 있도록 만들어진 매개체이다.\r\n- 인간과 컴퓨터의 상호작용(HCI)에 필요한 화상, 문자, 소리, 수단(장치)을 의미한다.\r\n\r\n#### UI 분야\r\n\r\n- 표현에 관한 분야 : 전체적인 구성과 콘텐츠의 상세 표현을 위한 분야이다.\r\n- 정보 제공과 전달 분야 : 물리적 제어를 통한 정보 제공과 전달을 위한 분야이다.\r\n- 기능 분야 : 기능적으로 사용자가 쉽고 간편하게 사용하도록 하는 분야이다.\r\n\r\n#### UI의 특징\r\n\r\n- 사용자 입력의 검증\r\n- 에러 처리의 에러 메시지 처리\r\n- 도움과 프롬프트(Prompt) 제공\r\n  - 프롬프트 : 사용자의 명령을 받아들일 준비가 되었음을 모니터에 나타내는 표시(커서 등)\r\n\r\n#### UI 설계 원칙\r\n\r\n- 직관성 : 누구나 쉽게 이해하고 사용할 수 있도록 한다.\r\n- 유효성 : 사용자의 목적을 정확히 달성할 수 있도록 유용하고 효과적이어야 한다.\r\n- 학습성 : 사용자가 쉽게 배우고 익힐 수 있어야 한다.\r\n- 유연성 : 사용자의 요구를 최대한 수용하면서 오류를 최소화해야 한다.\r\n\r\n#### UI 설계 도구\r\n\r\n- 와이어 프레임(Wire Frame) : UI 중심의 화면 레이아웃을 선(Wire)을 이용하여 대략적으로 작성한다.\r\n- 목업(Mockup) : 실물과 흡사한 정적인 모형을 의미한다.\r\n- 프로토타입(Prototype) : Interaction(상호작용)이 결합하여 실제 작동하는 모형이다.\r\n- 스토리보드(StoryBoard) : 정책, 프로세스, 와이어 프레임, 설명이 모두 포함된 설계 문서이다.\r\n\r\n### UX\r\n\r\n#### UX 사용자 경험\r\n\r\n- 사용자가 제품을 대상으로 직/간접적으로 사용하면서 느끼고 생각하게 되는 지각과 반응, 행동 등 모든 경험을 의미한다.\r\n- UI는 사람과 시스템 간의 상호작용을 의미하지만, UX는 제품과 서비스, 회사와 상호작용을 통해서 전체적인 느낌이나 경험을 말한다.\r\n- UX에 영향을 주는 요소 : 성능, 시간\r\n\r\n#### 모바일 사용자 UX 설계 시 고려사항(행정안전부 고시)\r\n\r\n- 시스템을 사용하는 대상, 환경, 목적, 빈도 등을 고려한다.\r\n- 사용자가 직관적으로 서비스 이용 방법을 파악할 수 있도록 한다.\r\n- 입력의 최소화, 자동 완성 기능을 제공한다.\r\n- 사용자의 입력 실수를 수정할 수 있도록 되돌림 기능을 제공한다.\r\n- 모바일 서비스의 특성에 적합한 디자인을 제공한다.\r\n\r\n# 모듈과 결합도, 응집도 ★★★\r\n\r\n### 모듈\r\n\r\n- 전체 프로그램에서 어떠한 기능을 수행할 수 있는 실행 코드를 의미한다.\r\n- 재사용이 가능하며 자체적으로 컴파일할 수 있다.\r\n- 시스템 개발 시 기간과 노동력을 절감할 수 있다.\r\n- 모듈의 독립성은 결합도와 응집도에 의해 측정된다.\r\n- 서브루틴 = 서브 시스템 = 작업 단위\r\n- 변수의 선언을 효율적으로 할 수 있어 기억 장치를 유용하게 사용할 수 있다.\r\n- 모듈마다 사용할 변수를 정의하지 않고 상속하여 사용할 수 있다.\r\n- 각 모듈의 기능이 서로 다른 모듈과의 과도한 상호 작용을 회피함으로서 이루어지는 것을 기능적 독립성이라 한다.\r\n\r\n### 결합도(Coupling)\r\n\r\n- 서로 다른 두 모듈 간의 상호 의존도로서 두 모듈 간의 기능적인 연관 정도를 나타낸다.\r\n- 모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상되어 시스템을 구현하고 유지보수 작업이 쉬워진다.\r\n- 자료 결합도가 설계 품질이 가장 좋다.\r\n\r\n| 결합도 수준 |              분류              | 특징                                                                                                                                                                                                                                                                                        |\r\n| :---------: | :----------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| 결합도 약함 |   자료 결합도(Data Coupling)   | 모듈 간의 인터페이스가 자료 요소로만 구성된 경우로 다른 모듈에 영향을 주지 않는 가장 바람직한 결합도이다. 모듈 간의 내용을 전혀 알 필요가 없다.                                                                                                                                             |\r\n|             | 스탬프 결합도(Stamp Coupling)  | 두 모듈이 같은 자료 구조를 조회하는 경우의 결합도이며, 자료 구조의 어떠한 변화 즉 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈까지도 영향을 미치게 된다. 배열, 레코드, 구조 등이 모듈 간 인터페이스로 전달되는 경우와 관계된다.            |\r\n| 결합도 보통 | 제어 결합도(Control Coupling)  | 어떤 모듈이 다른 모듈의 내부 논리 조작을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 상위 모듈에 처리 명령을 부여하는 권리 전도 현상이 발생하게 된다.                                                                     |\r\n|             | 외부 결합도(External Coupling) | 어떤 모듈에서 외부로 선언한 변수(데이터)를 다른 모듈에서 참조할 경우와 관계된다.                                                                                                                                                                                                            |\r\n|             |  공통 결합도(Common Coupling)  | 여러 모듈이 공통 자료 영역을 사용하는 경우로 공통 데이터 영역 내용을 수정하면 이 데이터를 사용하는 모든 모듈에 영향을 준다.                                                                                                                                                                 |\r\n| 결합도 강함 | 내용 결합도(Content Coupling)  | 가장 강한 결합도를 가지고 있으며, 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 조회하도록 설계되었을 경우와 관계된다. 한 모듈에서 다른 모듈의 내부로 제어 또는 이동된다. 한 모듈이 다른 모듈 내부 자료의 조회 또는 변경이 가능하다. - 두 모듈이 같은 문자(Literals)의 공유가 가능하다. |\r\n\r\n### 응집도(Cohesion)\r\n\r\n- 명령어, 명령어의 모임, 호출문, 특정 작업 수행 코드 등 모듈 안의 요소들이 서로 관련된 정도를 말한다.\r\n- 구조적 설계에서 기능 수행 시 모듈 간 최소한의 상호작용을 하여 하나의 기능만을 수행하는 정도를 표현한다.\r\n- 모듈이 독립적인 기능으로 구성됨의 정도를 의미한다.\r\n- 응집도가 높다는 것은 필요한 요소들로 구성됨을 의미한다.\r\n- 응집도가 낮다는 것은 요소 간의 관련성이 적음을 의미한다.\r\n\r\n| 응집도      | 분류                                            | 특징                                                                                                     |\r\n| ----------- | ----------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\r\n| 응집도 약함 | 우연적 응집도(Coincidental Cohesion)            | 모듈 내부의 각 기능 요소들이 서로 관련이 없는 요소로만 구성된 경우와 관계된다.                           |\r\n|             | 논리적 응집도(Logical Cohesion)                 | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우와 관계된다.          |\r\n|             | 시간적 응집도(Temporal Cohesion)                | 특정 시간에 처리되는 여러 기능을 모아 한 개의 모듈로 작성할 경우와 관계된다.                             |\r\n|             | 절차적 응집도(Procedural Cohesion)              | 모듕리 다수의 관련 기능을 가질 때 모듈 내부의 기능 요소들이 그 기능을 순차적으로 수행할 경우와 관계된다. |\r\n|             | 통신적(교환적) 응집도(Communicational Cohesion) | 같은 입력과 출력을 사용하는 소 작업이 모인 경우와 관계된다.                                              |\r\n|             | 순차적 응집도(Sequential Cohesion)              | 한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 요소의 입력 자료로 제공되는 경우와 관계된다.    |\r\n| 응집도 강함 | 기능적 응집도(Functional Cohesion)              | 모듈 내부의 모든 기능 요소들이 한 문제와 연관되어 수행되는 경우와 관계된다.                              |\r\n\r\n#### 모듈 설계의 특징\r\n\r\n바람직한 소프트웨어 설계는 응집도는 강하게, 결합도는 약하게 설계하여 모듈의 독립성을 확보할 수 있도록 한다.\r\n\r\n- 유지보수가 수월해야 하며 복잡도와 중복을 피하며 입구와 출구는 하나씩 갖도록 한다.\r\n- 모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.\r\n- 모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.\r\n- 적당한 모듈의 크기를 유지하고 모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.\r\n- 모듈의 크기가 작으면 모듈 개수가 증가하여 모듈 간 통합 비용이 증가하고, 모듈의 크기가 크면 단위 모듈 개발에 큰 비용과 시간이 소요된다.\r\n- 모듈 독립성이 높다는 것은 단위 모듈을 변경하더라도 타 모듈에 영향이 적다는 의미이며, 오류 발견과 해결이 쉬워진다.\r\n\r\n### 모듈과 컴포넌트\r\n\r\n- 모듈\r\n  - 자신만으로 동작할 수 있는 명령의 집합이다.\r\n  - 실제로 가장 맨 앞에 위치하는 구현된 단위이며 자료 구조, 알고리즘 등 이를 제공하는 인터페이스다.\r\n  - 정의하지 않는 이상 바로 재활용할 수 없다.\r\n- 컴포넌트\r\n  - SW 시스템에서 독립적인 업무 또는 기능을 수행하는 모듈로 교체가 가능한 부품이다.\r\n  - 모듈화로 생산성을 향상했으나 모듈의 소스 코드 레벨의 재활용으로 인한 한계성을 극복하기 위하여 등장하였다.\r\n  - 인터페이스를 통해서 연결된다.\r\n\r\n### 공통 모듈 - 명세 기법\r\n\r\n- 정확성(Correctness) : 실제 구현 시 꼭 필요한 기능인지 확인할 수 있도록 정확히 작성한다.\r\n- 명확성(명료성, Clearity) : 해당 기능에 대한 일관된 이해와 하나로 해석될 수 있도록 작성한다.\r\n- 완전성(Completeness) : 시스템 구현 시 필요한 것, 요구되는 것을 모두 작성한다.\r\n- 일관성(Consistency) : 공통 기능 간 서로 충돌이 발생하지 않도록 작성한다.\r\n- 추적성(Traceability) : 공통 기능에 대한 요구사항 출처, 관련 시스템이 유기적 관계 구분이 가능하도록 작성한다.\r\n\r\n# 소프트웨어 아키텍처(Software Architecture)\r\n\r\n- 요구사항을 기반으로 개발 대상 소프트웨어의 기본 틀(뼈대)을 만드는 것이다.\r\n- 다수의 이해관계자가 참여하는 복잡한 개발에서 상호 이해, 타협, 의사소통을 체계적으로 접근하기 위한 것이다.\r\n- 전체 시스템의 전반적인 구조를 체계적으로 설계하는 것이다.\r\n- 권형도(2004) : \"소프트웨어를 구성하는 컴포넌트들의 상호작용 및 관계, 각각의 특성을 기반으로 컴포넌트들이 상호 유기적으로 결합하는 소프트웨어의 여러 가지 원칙들의 집합\"이다.\r\n- 역할 : 설계 및 구현을 위한 구조적/비구조적인 틀(Frame)을 제공한다.\r\n- Structure Frame : 시스템 개발을 위하여 결정된 컴포넌트의 구조 모델이다.\r\n- Non Structure frame : 해당 구조 모델 이외 다른 아키텍처 설계의 결정들이다.\r\n\r\n### Software Architecture 특징\r\n\r\n- 간략성 : 이해하고 추론할 수 있을 정도로 간결해야 한다.\r\n- 추상화 : 시스템의 추상적인 표현을 사용한다.\r\n- 가시성 : 시스템이 포함해야 하는 것들을 가시화해야 한다.\r\n- 복잡도 관리 종류 : 과정 추상화, 데이터 추상화, 제어 추상화\r\n\r\n### MVC(Model View Controller) 패턴\r\n\r\n대화형 애플리케이션을 아래와 같이 3부분으로 분류한다.\r\n\r\n- Model : 핵심 기능 + 데이터\r\n- View : 사용자에게 정보 표시(다수 뷰가 정의될 수 있다.)\r\n- Controller : 사용자로부터 입력을 처리한다.\r\n\r\n### 클라이언트 서버(Client Server) 패턴\r\n\r\n- 하나의 서버와 다수 클라이언트로 구성되며, 클라이언트가 서버에 서비스를 요청하면 커뮤니케이션이 이루어진다. 서버는 응답을 위해 항상 대기 중이어야 한다.\r\n- 여러 컴포넌트에 걸쳐서 데이터와 데이터를 처리하는 애플리케이션에 적합하다.\r\n- 장점 : 직접 데이터 분산, 위치 투명성을 제공한다.\r\n- 단점 : 서비스와 서버의 이름을 관리하는 레지스터가 없어 이용 가능한 서비스 시간에 불편함을 초래한다.\r\n- 활용 : 이메일, 문서 공유, 은행 등 온라인 애플리케이션\r\n\r\n### 파이프 필터(Pipe-Filters)\r\n\r\n- 데이터 흐름(Data Stream - 데이터 송/수신이나 처리의 연속적 흐름)을 생성하고 처리하는 시스템을 위한 구조이다.\r\n- 필터는 파이프를 통해 받은 데이터를 변경시키고 그 결과를 파이프로 전송한다.\r\n- 각 처리 과정은 필터 컴포넌트에서 이루어지며, 처리되는 데이터는 파이프를 통해 흐른다. 이 파이프는 버퍼링 또는 동기화 목적으로 사용될 수 있다.\r\n- 컴파일러, 연속한 필터들은 어휘 분석, 파싱, 의미 분석 그리고 코드 생성을 수행한다.\r\n- 장점 : 필터 교환과 재조합을 통해서 높은 유연성을 제공한다.\r\n- 단점 : 상태정보 공유를 위해 비용이 소요되며 데이터 변환에 과부하가 걸릴 수 있다.\r\n- 활용 : 컴파일러, 어휘 분석, 구문 분석, 의미 분석, 코드 생성\r\n\r\n### Peer To Peer\r\n\r\n- 분산 컴퓨팅 애플리케이션 구축 시 유연성을 제공한다.\r\n- 클라이언트/서버 스타일레 대칭적 특징을 추가한 형태이다.\r\n- Peer가 하나의 컴포넌트로 대응되며 컴포넌트는 클라이언트, 서버 역할 모두 수행한다.\r\n\r\n### 이벤트 버스(Event - Bus)\r\n\r\n- 이벤트 버스 : 이벤트 생성(소스), 이벤트 수행(리스너), 이벤트 통로(채널), 채널 관리(버스)\r\n- 소스 이벤트가 메시지를 발행하면 해당 채널 구독자가 메시지 수신 후 해당 이벤트를 처리하는 방식으로 주로 이벤트를 처리하며 이벤트 소스, 이벤트 리스너(Event Listener), 채널, 이벤트 버스 등 4가지 주요 컴포넌트들을 갖는다.\r\n- 소스는 이벤트 버스를 통해 특정 채널로 메시지를 발행하고, 리스너는 특정 채널에서 메시지를 구독한다. 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.\r\n\r\n### 인터프리터(InterPreter)\r\n\r\n- SQL과 같은 데이터베이스 쿼리 언어, 통신 프로토콜을 정의하기 위한 언어\r\n- 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용된다.\r\n- 주로 특정 언어로 작성된 문장 혹은 표현식이라고 하는 프로그램의 각 라인을 수행하는 방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다.\r\n\r\n# 객체지향 설계 ★★★\r\n\r\n### 구조적 프로그래밍(Structured Programming)\r\n\r\n- 프로그램의 이해가 쉽고 디버깅 작업이 쉽다.\r\n- 한 개의 입구(입력)와 한 개의 출구(출력) 구조를 갖도록 한다.\r\n- GOTO(분기) 문은 사용하지 않는다.\r\n- 구조적 프로그래밍의 기본 구조 : 순차(Sequence) 구조, 선택(Selection) 구조, 반복(Iteration) 구조\r\n\r\n### 절차적 프로그래밍(Procedural Programming)\r\n\r\n- 순서대로 일련의 명령어를 나열하여 프로그래밍한다.\r\n- Function 기반의 프로그래밍이며, 프로시저로써 Function 외에도 Subroutine이 문법적으로 구현되어 있다.\r\n- 절차형 언어의 경우 규모가 커지면 커질수록 함수가 기하급수적으로 늘어난다.\r\n- 함수가 타 프로그램과 문제를 일으킬 수 있는 문제점을 가지고 있다.\r\n- 프로그램과 별개로 데이터 취급이 되므로 완전하지 않고 현실 세계 문제를 프로그램으로 표현하는데 제약이 있다.\r\n\r\n### 객체지향 프로그래밍(Object Oriented Programming)\r\n\r\n- 컴퓨터 소프트웨어를 구조적인 코드 단위로 보는 것이 아니라 Object 단위로 구분하고 Object 간의 모음으로 설계하는 것이다.\r\n- 소프트웨어 내의 Object는 서로 Message를 주고받는다.\r\n- 처리 요구를 받은 객체가 자기 자신 안에 있는 내용을 가지고 처리하는 방식이다.\r\n- 프로그램이 단순화되고 생산성, 신뢰성이 높아져 대규모 개발에 많이 사용된다.\r\n\r\n### 객체지향의 특징\r\n\r\n- 캡슐화(Encapsulation)\r\n  - 서로 관련성이 높은 데이터(속성)와 그와 관련된 기능(메서드, 함수)을 묶는 기법이다.\r\n  - 결합도가 낮아져 소프트웨어 개발에 있어 재사용성이 높아진다.\r\n  - 정보 은닉을 통하여 타 객체와 메시지 교환 시 인터페이스가 단순해진다.\r\n  - 변경 발생 시 오류의 파급 효과가 적다.\r\n- 상속성(Inheritance)\r\n  - 상위 클래스의 모든 속성, 연산을 하위 클래스가 재정의 없이 물려받아 사용하는 것이다.\r\n  - 상위 클래스는 추상적 성질을, 자식 클래스는 구체적 성질을 가진다.\r\n  - 하위 클래스는 상속받은 속성과 연산에 새로운 속성과 연산을 추가하여 사용할 수 있다.\r\n  - 다중 상속 : 다수 상위 클래스에서 속성과 연산을 물려받는 것이다.\r\n- 다형성(Polymorphism)\r\n  - 객체가 다양한 모양을 가지는 성질을 뜻한다.\r\n  - 오퍼레이션이나 속성의 이름이 하나 이상의 클래스에서 정의되고 각 클래스에서 다른 형태로 구현될 수 있는 개념이다.\r\n  - 속성이나 변수가 서로 다른 클래스에 속하는 객체를 지칭할 수 있는 성질이다.\r\n- 추상화(Abstraction)\r\n  - 시스템 내의 공통 성질을 추출한 뒤 추상 클래스를 설정하는 기법이다.\r\n  - 현실 세계를 컴퓨터 시스템에 자연스럽게 표현할 수 있다.\r\n  - 종류 : 기능 추상화, 제어 추상화, 자료 추상화\r\n- 정보은닉(Information Hiding)\r\n  - 객체 내부의 속성과 메서드를 숨기고 공개된 인터페이스를 통해서만 메시지를 주고받을 수 있도록 하는 것을 의미한다.\r\n  - 예기치 못한 SideEffect를 줄이기 위해 사용한다.\r\n\r\n### 오버로딩(Overloading)과 오버라이딩(Overriding)\r\n\r\n- 오버로딩\r\n  - 사전적 의미 : 과적, 과부하\r\n  - 한 클래스 내에서 같은 이름의 메서드를 사용하는 것\r\n  - 같은 이름의 메서드를 여러 개 정의하면서 매개 변수의 유형과 개수가 달라지도록 하는 기술\r\n- 오버라이딩\r\n  - 사전적 의미 : 가장 우선되는, 최우선으로 되는, 다른 것보다 우선인\r\n  - 상속 관계의 두 클래스의 상위 클래스에서 정의한 메서드를 하위 클래스에서 변경(재정의)하는 것\r\n  - JAVA 언어에서는 static 메서드의 오버라이딩을 허용하지 않는다.\r\n  - 오버라이딩의 경우 하위 객체의 매개 변수 개수와 타입은 상위 객체와 같아야 한다.\r\n\r\n### 객체지향 설계 원칙(SOLID)\r\n\r\n1. 단일 책임의 원칙\r\n   - (SRP : Single Responsibility Principle)\r\n   - 모든 클래스는 단일 목적으로 생성되고, 하나의 책임만 가져야 한다.\r\n2. 개방 - 폐쇄의 원칙\r\n   - (OCP : Open Closed Principle)\r\n   - 소프트웨어 구성 요소는 확장에 대해서는 개방되어야 하나 수정에 대해서는 폐쇄적이어야 한다.\r\n3. 리스코프치환 원칙\r\n   - (LSP : Liskov Substitution Principle)\r\n   - 부모 클래스가 들어갈 자리에 자식 클래스를 대체하여도 계획대로 작동해야 한다.\r\n4. 인터페이스 분리 원칙\r\n   - (ISP : Interface Segregation Principle)\r\n   - 클라이언트는 자신이 사용하지 않는 메서드와 의존 관계를 맺으면 안 된다.\r\n   - 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안 된다.\r\n5. 의존 역전 원칙\r\n   - (DIP : Dependency Inversion Principle)\r\n   - 의존 관계를 맺으면 변하기 쉽고 변화 빈도가 높은 것보다 변하기 어렵고 변화 빈도가 낮은 것에 의존한다.\r\n\r\n# 디자인 패턴\r\n\r\n- 자주 사용하는 설계 형태를 정형화하여 유형별로 설계 템플릿을 만들어 두고 소프트웨어 개발 중 나타나는 과제를 해결하기 위한 방법 중 한 가지다.\r\n- 다양한 응용 소프트웨어 시스템들을 개발할 때 서로 간에 공통점이 있으며, 이러한 유사점을 패턴이라 한다.\r\n- 개발자 간 원활한 의사소통, 소프트웨어 구조 파악 용이, 설계 변경에 대한 유연한 대처, 개발의 효율성, 유지보수성, 운용성 등 소프트웨어 품질 향상에 도움을 준다.\r\n- 객체지향 프로그래밍 설계 시 유사한 상황에서 구조적인 문제를 해결할 수 있도록 방안을 제공해주며, Gof(Gang of Four) 분류가 가장 많이 사용된다.\r\n\r\n### 디자인 패턴을 사용할 때의 장/단점\r\n\r\n장점\r\n\r\n- 개발자 간의 월활한 의사소통을 지원한다.\r\n- 소프트웨어 구조 파악이 쉽다.\r\n- 재사용을 통한 개발 시간을 단축할 수 있다.\r\n- 설계 변경 요청에 대해 유연하게 대처할 수 있다.\r\n- 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.\r\n\r\n단점\r\n\r\n- 객체지향 설계/구현 위주로 사용된다.\r\n- 초기 투자 비용이 부담된다.\r\n\r\n### 디자인 패턴의 구성 요소\r\n\r\n- 필수 요소\r\n  - 패턴의 이름 : 패턴을 부를 때 사용하는 이름과 패턴의 유형\r\n  - 문제 및 배경 : 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미\r\n  - 해법 : 패턴을 이루는 요소들, 관계, 협동(Collaboration) 과정\r\n  - 결과 : 패턴을 사용하면 얻게 되는 이점이나 영향\r\n- 추가 요소\r\n  - 알려진 사례 : 간단한 적용 사례\r\n  - 샘플 코드 : 패턴이 적용된 원시 코드\r\n  - 원리, 정당성, 근거\r\n\r\n### GoF(Gangs of Four) 디자인 패턴\r\n\r\n- 에릭 감마, 리처드 헬름, 랄프 존슨, 존 브리시데스가 제안\r\n- 객체지향 설계 단계 중 재사용에 관한 유용한 설계를 디자인 패턴화하였다.\r\n- 생성 패턴, 구조 패턴, 행위 패턴으로 분류한다.\r\n\r\n#### 생성 패턴\r\n\r\n- 객체를 생성하는 것과 관련된 패턴이다.\r\n- 객체의 생성과 변경이 전체 시스템에 미치는 영향은 최소화하도록 만들어주어 유연성을 높일 수 있고 코드를 유지하기가 쉬운 편이다.\r\n- 객체의 생성과 참조 과정을 추상화함으로써 시스템을 개발할 때 부담을 덜어준다.\r\n- 구성\r\n  - Factory Method\r\n    - 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클레스에서 인스턴스를 생성하도록 하는 방식이다.\r\n    - Virtual-Constructor 패턴이라고도 한다.\r\n  - Singleton\r\n    - 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 한다.\r\n    - 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴이다.\r\n  - Prototype\r\n    - prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.\r\n    - 일반적인 방법으로 객체를 생성한다.\r\n    - 비용이 많이 소요되는 경우 주로 사용한다.\r\n  - Builder\r\n    - 작게 분리된 인스턴스를 조립하듯 조합하여 객체를 생성한다.\r\n  - Abstraction Factory\r\n    - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다.\r\n    - 관련된 서브 클래스를 그룹 지어 한 번에 교체할 수 있다.\r\n\r\n#### 구조 패턴\r\n\r\n- 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이다.\r\n- 복잡한 형태의 구조를 갖는 시스템을 개발하기 쉽게 만들어주는 패턴이다.\r\n- 새로운 기능을 가진 복합 객체를 효과적으로 작성할 수 있다.\r\n  - ex. 서로 다른 인터페이스를 지닌 2 개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다. 프로그램 내의 자료 구조나 인터페이스 구조 등 구조를 설계하는데 많이 활용된다.\r\n- 구성\r\n  - Adapter\r\n    - 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해준다.\r\n    - 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.\r\n  - Bridge\r\n    - 큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층구조(추상화 및 구현)로 나눈 후 각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴\r\n    - 기능 클래스 계층과 구현 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 각자 독립적으로 변혈할 수 있도록 해주는 패턴이다.\r\n  - Composite(복합체)\r\n    - 객체들을 트리 구조들로 구성한 후, 이러한 구조들과 개별 객체들처럼 작업할 수 있도록 하는 구조 패턴\r\n  - Decorator\r\n    - 객체들을 새로운 행동들을 포함한 특수 래퍼 객체들 내에 넣어서 위 행동들을 해당 객체들에 연결시키는 구조적 디자인 패턴\r\n  - Facade(퍼사드)\r\n    - 라이브러리에 대한, 프레임워크에 대한 또는 다른 클래스들의 복잡한 집합에 대한 단순화된 인터페이스를 제공하는 구조적 디자인 패턴\r\n  - Flyweight\r\n    - 각 객체에 모든 데이터를 유지하는 대신 여러 객체들 간에 상태의 공통 부분들을 공유하여 사용할 수 있는 RAM에 더 많은 객체들을 포함할 수 있도록 하는 구조 디자인 패턴\r\n  - Froxy\r\n    - 다른 객체에 대한 대체 또는 자리표시자를 제공할 수 있는 구조 디자인 패턴\r\n    - 프록시는 원래 객체에 대한 접근을 제어하므로, 자신의 요청이 원래 객체에 전달되기 전 또는 후에 무언가를 수행할 수 있도록 함.\r\n\r\n### 행위 패턴\r\n\r\n- 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.\r\n- 메시지 교환과 관련된 것으로, 객체 간의 행위나 알고리즘 등과 관련된 패턴을 말한다.\r\n- 구성\r\n  - Chain of Responsibility(책임 연쇄)\r\n    - 핸들러들의 체인(사슬)을 따라 요청을 전달할 수 있게 해주는 행동 디자인 패턴\r\n    - 각 핸들러는 요청을 받으면 요청을 처리할지 아니면 체인의 다음 핸들러로 전달할지를 결정\r\n  - Iterator(반복자)\r\n    - 컬렉션의 요소들의 기본 표현(리스트, 스택, 트리 등)을 노출하지 않고 그들을 하나씩 순회할 수 있도록 하는 행동 디자인 패턴\r\n  - Command(명령)\r\n    - 요청을 요청에 대한 모든 정보가 포함된 독립실행형 객체로 변환하는 행동 디자인 패턴\r\n    - 이 변환은 다양한 요청들이 있는 메서드들을 인수화 할 수 있도록 하며, 요청의 실행을 지연 또는 대기열에 넣을 수 있도록 하고, 또 실행 취소할 수 있는 작업을 지원할 수 있도록 함.\r\n  - Interpreter(해석자)\r\n    - 단순한 언어를 해석할 때 유용한 패턴\r\n    - 간단한 언어의 문법을 정의하고 해석하는 패턴\r\n    - 언어가 주어지면 해당 표현을 사용하여 언어로 문장을 해석하는 인터프리터를 사용하여 문법 표현을 정의하는 방법\r\n  - Memento(기록)\r\n    - 메멘토 패턴은 객체를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴\r\n    - 오리지네이터, 케어테이커, 메멘토 등 3개의 객체로 구현된다.\r\n    - 오리지네이터 : 내부 상태를 보유하고 있는 일부 객체\r\n  - Observer(감시자)\r\n    - 여러 객체에 자신이 관찰 중인 객체에 발생하는 모든 이벤트에 대해 알리는 구독 매커니즘을 정의할 수 있도록 하는 행동 디자인 패턴(관찰자)\r\n  - State(상태)\r\n    - 객체의 내부 상태가 변경될 때 해당 객체가 그의 행동을 변경할 수 있도록 하는 행동 디자인패턴\r\n    - 객체가 행동을 변경할 때 객체가 클래스를 변경한 것처럼 보일 수 있음\r\n  - Strategy(전략)\r\n    - 패턴은 알고리즘들의 패밀리를 정의하고, 각 패밀리를 별도의 클래스에 넣은 후 그들의 객체들을 상호교환할 수 있도록 하는 행동 디자인 패턴\r\n  - Visitor(방문자)\r\n    - 알고리즘들을 그들이 작동하는 객체들로부터 분리할 수 있도록 하는 행동 디자인 패턴\r\n  - Template Method\r\n    - 부모 클래스에서 알고리즘의 골격을 정의하지만, 해당 알고리즘의 구조를 변경하지 않고 자식 클래스들이 알고리즘의 특정 단계들을 오버라이드(재정의)할 수 있도록 하는 행동 디자인 패턴\r\n  - Mediator(중재자)\r\n    - 객체 간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다.\r\n    - Virual-Constructor 패턴이라고도 한다.\r\n    - 객체 간의 혼란스러운 의존 관계들을 줄일 수 있는 행동 디자인 패턴\r\n    - 패턴은 객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 협력하도록 한다.\r\n\r\n---\r\n\r\n참조 : [Github repository](https://github.com/CS-AL-SW/SW/tree/main/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/1.%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%84%A4%EA%B3%84)\r\n"},{"title":"javascript how to use promise.all","description":"Promise.all()은 언제 쓰고 왜 쓰나요? - 여러 비동기 요청 한 번에 처리하기","category":"javascript","keyword":"javascript, Promise.all","date":"2023-05-19","content":"\r\njavascript를 통해 비동기 코드를 처리하는 기본적인 방법으로는 Callback 함수, Promise, async/await 등이 있다. 하지만 다수의 비동기 요청의 실행이 필요한 경우 Promise.all()을 사용해볼 수 있다.\r\n\r\n## **Promise.all()이란?**\r\n\r\n여러 개의 Promise를 동시에 처리하고, 모든 Promise가 완료되었을 때 그 결과들을 반환하는 javascript의 메서드이다.\r\n\r\nPromise.all()은 배열형태의 Promise들을 인자로 받고, 이 Promise들은 병렬적으로 실행된다. Promise.all()은 해당 Promise들의 결과를 배열로 반환한다.\r\n\r\n**만약 하나라고 Promise가 거부되면, 첫 번째 거부된 Promise를 반환하고, 나머지 Promise들은 무시된다.**\r\n\r\n## **Promise.all()을 사용하는 이유**\r\n\r\nPromise.all()을 사용하면 병렬적으로 실행되는 Promise들을 효율적으로 관리하고, 모든 Promise의 결과를 한 번에 처리할 수 있다. 이는 비동기 작업을 동시에 처리하고 작업이 완료되었을 때 결과를 수집해야 하는 상황에서 유용하다.\r\n\r\n예를 들어 3초가 소요되는 비동기 요청 a, 2초가 소요되는 비동기 요청 b, 1초가 소요되는 비동기요청 c를 async/await을 통해 순차적으로 처리하게 되는 경우 총 6초가 소요되지만, Promise.all()을 통해 이전 요청이 완료되는 것을 기다리지 않고 비동기적으로 병렬로 실행시킨다면 3초만에 실행을 완료시킬 수 있는 것이다.\r\n\r\n```javascript\r\n\r\n// acyns/await\r\n\r\ncosnt test1 = async () =\u003e{\r\n\tawait a() // 3000ms\r\n    await b() // 2000ms\r\n    await c() // 1000ms\r\n}\r\n// 약 6초 소요\r\n\r\nconst test2 = async () =\u003e{\r\n\tconst [res1, res2, res3] = await Promise.all([\r\n    \ta(),\r\n        b(),\r\n        c()\r\n    ])\r\n    return [res1, res2, res3]\r\n}\r\n// 약 3초 소요\r\n\r\n```\r\n\r\n## **Promise.all() 사용 상황**\r\n\r\n아래와 같이 특정 DB의 데이터를 연속적으로 도출하기 위해 async/await과 Promise.all()을 사용해봤다.\r\n\r\n```javascript\r\n\r\n// 1) async/await\r\nasync func1(){\r\n\tconst community_with_likes = await community.map(async (item) =\u003e {\r\n      const like_list = await this.communityLikesRepository.find({\r\n        where: {\r\n          community_id: item.community_id,\r\n        },\r\n      });\r\n      return like_list;\r\n    });\r\n}\r\n\r\n// 2) Promise.all()\r\nasync func2(){\r\n\tconst community_with_likes = await Promise.all(\r\n      community.map(async (item) =\u003e {\r\n        const like_list = await this.communityLikesRepository.find({\r\n          where: {\r\n            community_id: item.community_id,\r\n          },\r\n        });\r\n        return like_list;\r\n      }),\r\n    );\r\n}\r\n\r\n```\r\n\r\n### **1. async/await**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOMvFZ%2FbtsgB32dgj6%2FbaANEHQzX0hxTVckIjOPiK%2Fimg.png)\r\n\r\nasync/await을 사용해 결과를 출력하려고 할 때는 위와 같이 원하는 방식대로 데이터가 출력되지 않았다.\r\n\r\n### **2. Promise.all()**\r\n\r\n하지만 Promise.all()을 사용해 결과를 도출하니 아래와 같이 원하는 결과값을 볼 수 있었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fo73VZ%2FbtsgCGeohNN%2F42YW4sTfKAiXcl3VeJgP51%2Fimg.png)\r\n\r\n비동기 처리를 다루는 방법은 여러가지가 있지만, 내가 적용하고자 하는 작업의 특성에 맞게 알맞는 방법을 골라서 사용하는 것이 좋겠다.\r\n\r\n---\r\n\r\n참조\r\n\r\nhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\r\n\r\nhttps://code-masterjung.tistory.com/91\r\n"},{"title":"nestjs localhost https","description":"Localhost 환경에서 HTTPS 적용하기","category":"nestjs","keyword":"nestjs, localhost, HTTPS","date":"2023-04-30","content":"\r\n### Local 환경에서 https 설정이 필요한 이유\r\n\r\n로컬 환경에서 내가 원하는대로 기능들이 작동한다고 해도, 배포 환경과 로컬 개발 환경의 차이로 인해 코드의 수정이 필요해질 수 있다. 이러한 이유로 개발 환경을 배포 환경과 최대한 동일하게 만들어주는 것이 좋다. 또한 최근의 배포 환경들은 대부분 https로 이뤄져 있기 때문에 그에 맞춰 설정해줄 필요가 있다.\r\n\r\n### 자체 서명 인증서 생성 (openssl 사용)\r\n\r\n```bash\r\n# 개인 키 생성\r\n$ openssl genrsa -out private-key.pem 2048\r\n\r\n# 개인 키를 사용한 새로운 인증서 요청서 생성\r\n$ openssl req -new -key private-key.pem -out cert-request.csr\r\n\r\n# 요청서를 사용한 자체 서명 인증서 생성\r\n$ openssl x509 -req -in cert-request.csr -signkey private-key.pem -out cert.pem\r\n```\r\n\r\n인증서 생성 시 입력사항은 모두 건너뛰어도 무관하다.\r\n\r\n### HTTPS 구성 설정 - main.ts\r\n\r\n```typescript\r\nimport * as fs from \"fs\";\r\nimport * as https from \"https\";\r\n\r\nasync function bootstrap() {\r\n  const httpsOptions = {\r\n    key: fs.readFileSync(\"./private-key.pem\"),\r\n    cert: fs.readFileSync(\"./cert.pem\"),\r\n  };\r\n  const app = await NestFactory.create(AppModule, {\r\n    httpsOptions,\r\n  });\r\n  // 필요에 따라 cors 설정도 가능\r\n  // app.enableCors({\r\n  //  origin: [url,...],\r\n  //  credentials: true, 쿠키를 사용하는 경우 설정\r\n  // });\r\n  await app.listen(3000);\r\n}\r\nbootstrap();\r\n```\r\n\r\n설정이 완료되면 로컬에서 https 환경처럼 적용할 수 있다.\r\n\r\n하지만 자체 인증서로 https를 만들어 SSR(ServerSideRendering)이나 API 요청 시 self certifi 에러가 발생할 수 있다. 이런 경우 프론트단 env에 다음과 같이 설정해주면 된다.\r\n\r\n```bash\r\n# .env\r\nNODE_TLS_REJECT_UNAUTHORIZED=0\r\n```\r\n\r\n그럼에도 오류가 발생하는 경우 아래의 링크를 통해 크롬 환경설정을 해주면 된다.\r\n\r\nchrome://flags/#allow-insecure-localhost\r\n\r\n유효하지 않은 인증서 허용으로 설정\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3WChm%2Fbtsdi3DwSL4%2F5cdQ9YFzgaKugT4u9ewDk0%2Fimg.png)\r\n"},{"title":"nestjs server client cookie2","description":"NestJS에서 클라이언트로 쿠키 보내기 (왜 내 쿠키는 안받아줘요?) - 배포환경","category":"nestjs","keyword":"nestjs, 쿠키","date":"2023-04-30","content":"\r\n### **[서버에서 브라우저로 쿠키 저장](https://lee-yo-han.github.io/nestjs-server-client-cookie)**\r\n\r\n분명 로컬에서는 쿠키가 정상적으로 브라우저에 저장되는 것을 볼 수 있었는데, 배포를 하고 나니 또다시 쿠키가 보이지 않았다. response headers에는 쿠키 값과 함께 다음과 같은 에러 문구를 볼 수 있었다.\r\n\r\n\u003e **this attempt to set a cookie via a set cookie header was blocked because its domain attribue was invalid with reqards to the current host url**\r\n\u003e\r\n\u003e \u003e \"설정된 쿠키 헤더를 통해 쿠키를 설정하려는 이 시도는 해당 도메인 속성이 현재 호스트 URL에 대해 유효하지 않기 때문에 차단되었습니다.\"\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcGZzIY%2FbtsdemcKoT1%2FcT16wBLzk5J48gv37fGyPK%2Fimg.png)\r\n\r\n쿠키 전송 옵션은 다음과 같다.\r\n\r\n```typescript\r\nres.cookie(\"cookie\", \"cookie\", {\r\n  maxAge: 0,\r\n  sameSite: process.env.COOKIE_PARSE_SAME_SITE as SameSite, // \"none\"\r\n  secure: true,\r\n  httpOnly: true,\r\n  domain: process.env.COOKIE_PARSE_DOMAIN, // \"www.backend.com\"\r\n});\r\n```\r\n\r\n프론트엔드의 URL이 https://www.frontend.com 이고,\r\n\r\n백엔드의 URL이 https://www.backend.com 이라고 했을 때, domain 속성을 백엔드 URL로 설정했을 때 발생한 오류이며, domain을 프론트엔드 URL로 바꾸면 response headers에 쿠키 값 자체가 확인되지 않았다.\r\n\r\ncors 설정도 credential: true나 origin 등을 정상적으로 해놓은 상태이기 때문에 쿠키 외 다른 데이터는 정상적으로 받아오는걸 확인할 수 있었다.\r\n\r\n다른 자료를 찾아보니, secure 속성을 적용하면 쿠키가 정상적으로 저장된다고는 하지만 본인은 이런 문제가 해결되지 않았다.\r\n\r\n결국 도메인을 구매해서 사용하게 되었다.\r\n\r\n예를 들어 프론트엔드의 URL은 https://www.product.com 로,\r\n\r\n백엔드의 URL은 https://api.product.com 으로 연동시켜주고, 쿠키 옵션은 아래처럼 바꿨다.\r\n\r\n```typescript\r\nres.cookie(\"cookie\", \"cookie\", {\r\n  maxAge: 0,\r\n  sameSite: process.env.COOKIE_PARSE_SAME_SITE as SameSite, // \"lax\"\r\n  secure: true,\r\n  httpOnly: true,\r\n  domain: process.env.COOKIE_PARSE_DOMAIN, // \".product.com\"\r\n});\r\n```\r\n\r\n같은 도메인을 사용하고 나서야 쿠키가 정상적으로 브라우저로 접속하는 것을 확인할 수 있었다.\r\n"},{"title":"nextjs pages api dir unsupported","description":"NextJS에서 API 디렉토리가 사용되지 않는 이유","category":"nextjs","keyword":"nextjs api 디렉토리","date":"2023-04-30","content":"\r\nNextJS는 pages/api 디렉토리를 통해 백엔드에 대한 처리를 수행할 수 있다.\r\n\r\n하지만 정적으로 배포된 사이트(ex. 블로그 등)에서는 pages/api 등과 같은 동적 로직은 지원되지 않기 때문에 api 디렉토리를 사용할 수 없다.\r\n\r\n정적 배포 방법\r\n\r\n```javascript\r\n// package.json\r\n// NextJS 13.3 이전 버전\r\n\"scripts\": {\r\n    \"dev\": \"next dev\",\r\n    \"start\": \"next start\",\r\n    \"lint\": \"next lint\",\r\n    \"build\": \"next build \u0026\u0026 next export\", // ## 정적 배포\r\n    \"predeploy\": \"npm run build\",\r\n    \"deploy\": \"touch out/.nojekyll \u0026\u0026 gh-pages -d out --dotfiles\"\r\n  },\r\n\r\n\r\n// next.config.js\r\n// NextJS v13.3 ~\r\n/**\r\n * @type {import('next').NextConfig}\r\n */\r\nconst nextConfig = {\r\n  output: 'export',\r\n}\r\n\r\nmodule.exports = nextConfig\r\n```\r\n\r\n---\r\n\r\n참조\r\n\r\nhttps://nextjs.org/docs/advanced-features/static-html-export\r\n"},{"title":"nextjs prop classname did not match","description":"prop `classname` did not match. with styled-components","category":"nextjs","keyword":"prop 'classname' did not match. with styled-components","date":"2023-04-30","content":"\r\n## prop 'classname' did not match. with styled-components 에러 해결 방법\r\n\r\nNextJS의 next.config를 수정해준다.\r\n\r\n```javascript\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactStrictMode: false,\r\n  compiler: {\r\n    styledComponents: true, // 컴파일러 옵션 추가\r\n  },\r\n};\r\n\r\nmodule.exports = nextConfig;\r\n```\r\n"},{"title":"nestjs server client cookie","description":"NestJS에서 클라이언트로 쿠키 보내기 (왜 내 쿠키는 안받아줘요?)","category":"nestjs","keyword":"nestjs, 쿠키","date":"2023-04-13","content":"\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpD9qr%2Fbtr9Oa0APIT%2FFuzZyjjney7aKkIXy6BAfK%2Fimg.png)\r\n\r\n## 쿠키(Cookie)란?\r\n\r\n쿠키는 서버에서 클라이언트에게 보내는 작은 데이터 조각이다. 일반적으로 브라우저에서 웹 사이트를 방문할 때 쿠키를 사용하여 사용자의 활동을 기록하고, 이후에 그 사용자가 같은 웹 사이트를 방문할 때 이 정보를 사용해 그에 맞게 동작하게 해준다. 하지만 쿠키는 당사자뿐만 아닌 제 3자가 조회하는 것도 가능하기 때문에 개인 정보를 담는 등 보안상 민감한 정보를 저장하는 데에는 적합하지 않기 때문에 탈취되거나 사용자에 의해 조작되어도 크게 문제 되지 않을 정보를 주로 저장한다. (ex. 다크 모드, 장바구니 목록 등)\r\n\r\n## 서버에서 클라이언트로 Cookie 전송 예제\r\n\r\n### 모듈 설치\r\n\r\n```bash\r\nyarn add cookie-parser @types/cookie-parser # 쿠키 관리 모듈\r\n```\r\n\r\n### 모듈 적용\r\n\r\n```typescript\r\n// main.ts\r\n\r\nimport { NestFactory } from \"@nestjs/core\";\r\nimport { AppModule } from \"./app.module\";\r\nimport * as cookieParser from \"cookie-parser\";\r\n\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule);\r\n  app.enableCors({\r\n    // cors 설정\r\n    origin: \"http://localhost:3000\",\r\n    credentials: true, // 쿠키를 사용할 수 있게 해당 값을 true로 설정\r\n  });\r\n  app.use(cookieParser()); // 쿠키의 편리한 이용을 위해 cookieParser 적용\r\n  await app.listen(3001);\r\n}\r\nbootstrap();\r\n```\r\n\r\n### 쿠키 사용 로직\r\n\r\n```typescript\r\n// controller.ts\r\n\r\nimport { Response } from \"express\";\r\nimport { Controller, Get, Res } from \"@nestjs/common\";\r\n\r\n@Controller(\"myController\")\r\nexport class MyController {\r\n  @Get()\r\n  getCookie(@Res() res: Response) {\r\n    // express의 Response 객체를 불러와 사용해준다.\r\n    // 쿠키 설정\r\n    res.cookie(\"cookieName\", \"cookieValue\", { maxAge: 900000, httpOnly: true });\r\n    // maxAge : 유효기간을 밀리초 단위로 설정\r\n    // httpOnly : 클라이언트에서 쿠키에 접근할 수 없도록 설정\r\n\r\n    // HTTP 응답 반환\r\n    return res.send(\"쿠키가 설정되었습니다.\");\r\n  }\r\n}\r\n```\r\n\r\n쿠키를 요청하는 클라이언트에서도 withCredentials 값을 true로 설정해준다.\r\n\r\n```typescript\r\naxios.get(BASE_URL, {\r\n  withCredentials: true,\r\n  headers: {\r\n    \"Content-Type\": \"application/json\",\r\n  },\r\n});\r\n```\r\n\r\n## 문제상황\r\n\r\n보통 예제는 위와 같지만 나는 쿠키가 브라우저에 저장되지 않았다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd0P7QS%2Fbtr9SjoI9ke%2FIW9CJf8K5mS7kDuau67KDK%2Fimg.png)\r\n\r\n로직이 잘못된 것처럼 보이지도 않았고 별도의 에러 메시지도 없어서 문제 파악이 어려웠다.\r\n\r\n네트워크 탭을 통해 확인해 보니 response 헤더에 쿠키도 정상적으로 들어가 있었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDRJgW%2Fbtr9NnsBfTs%2FlGo4A2uw6n2UXPJJQVwbb1%2Fimg.png)\r\n\r\n그런데 노란 경고판이 눈에 띄었다.\r\n\r\n경고 문구는 다음과 같다.\r\n\r\n\u003e **this set-cookie header didn't specify a samesite attribute, was defaulted to sameSite=Lax, and was blocked because it came from a cross-site reponse which was not the response to a top-level navigation. this response is considered cross-site because the URL has a different scheme than the current site**\r\n\r\n요청 URL과 서버 URL의 체계가 달라서 차단됐다고 한다. 내 클라이언트는 http://localhost인데 서버가 https://localhost라서 그런 것 같았다.\r\n\r\nsameSite를 none으로 설정해주고 난 후에는 다음과 같은 경고 문구가 생겼다.\r\n\r\n\u003e **this attempt to set a cookie via a set-cookie header was blocked because it had the \"SameSite=None\" attribute but did not have the \"Secure\" attibute, which is required in order to user \"sameSite=None\"**\r\n\r\nsameSite=none을 적용하기 위해 필요한 Secure 속성이 없기 때문에 쿠키 설정이 차단되었단다.\r\n\r\n쿠키 생성 옵션을 마저 추가해 줬다.\r\n\r\n```typescript\r\nres.cookie(\"cookieName\", \"cookieValue\", {\r\n  maxAge: 300000,\r\n  // none, lax, strict 중 none은 쿠키가 항상 전송되도록 허용.\r\n  sameSite: \"none\", // HTTPS 프로토콜을 사용하고 secure 옵션이 설정된 경우에만 사용 가능\r\n  secure: true, // 쿠키가 HTTPS 프로토콜을 사용하는 경우에만 전송되도록 제한\r\n  httpOnly: true, // 쿠키에 접근할 수 있는 영역을 HTTP(S) 프로토콜로 제한하여,\r\n  // 브라우저의 자바스크립트 코드로부터 쿠키에 접근할 수 없게 함\r\n});\r\n```\r\n\r\nsecure 속성을 사용하기 위한 https 설정은 아래를 참고할 수 있다.\r\n\r\n### [Localhost 환경에서 https 적용하기](https://lee-yo-han.github.io/nestjs-localhost-https)\r\n\r\n그 결과 쿠키를 브라우저에서 잘 받는 것을 볼 수 있었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJwJs6%2Fbtr9SkupB08%2FbXf0Hf9swCaY3uL8cxMh7K%2Fimg.png)\r\n\r\n마지막으로 서버에서 쿠키를 받아 사용하는 방법이다.\r\n\r\n```typescript\r\nimport { Response, Request } from \"express\";\r\nimport { Controller, Get, Post, Res, Req } from \"@nestjs/common\";\r\n\r\n@Controller(\"myController\")\r\nexport class MyController {\r\n  @Get()\r\n  getCookie(@Res() res: Response) {\r\n    // express의 Response 객체를 불러와 사용해준다.\r\n    // 쿠키 설정\r\n    res.cookie(\"cookieName\", \"cookieValue\", { maxAge: 900000, httpOnly: true });\r\n    // maxAge : 유효기간을 밀리초 단위로 설정\r\n    // httpOnly : 클라이언트에서 쿠키에 접근할 수 없도록 설정\r\n\r\n    // HTTP 응답 반환\r\n    return res.send(\"쿠키가 설정되었습니다.\");\r\n  }\r\n\r\n  @Get()\r\n  postCookie(@Req() req: Request) {\r\n    // express의 Request 객체를 불러와 사용해준다.\r\n    // request 객체의 cookies를 통해 생성했던 쿠키의 이름을 통해 값을 가져온다.\r\n    req.cookies[\"cookieName\"];\r\n  }\r\n}\r\n```\r\n\r\n클라이언트 단에서는 withCredentials:true 옵션 설정 외에는 특별히 해줄 것이 없다.\r\n\r\n---\r\n\r\n참조 : https://docs.nestjs.com/techniques/cookies\r\n"},{"title":"nestjs use bcrypt","description":"Nestjs에서 bcrypt 사용하기","category":"nestjs","keyword":"Nestjs, bcrypt","date":"2023-04-13","content":"\r\n## bycrypt란?\r\n\r\n비밀번호 등을 안전하게 암호화하여 저장하고 검증할 수 있도록 도와주는 라이브러리로, 랜덤한 salt를 생성하고 이를 비밀번호와 함께 암호화하여 저장한다. 이후 비밀번호 검증 시에도 같은 salt를 사용하여 입력받은 비밀번호를 암호화한 후, 저장된 암호화된 비밀번호와 비교하여 일치하는지 검증한다.\r\n\r\nbcrypt는 암호화 강도를 선택할 수 있는 기능을 제공한다. 기본값은 10으로, 숫자가 클수록 강도가 높아지며 암호화에 소요되는 시간도 늘어난다. 보안을 위해 기본값 이상의 값을 권장한다.\r\n\r\n## 사용법\r\n\r\n```bash\r\nyarn add bcrypt @types/bcrypt # nestjs는 타입스크립트가 기본이기 때문에 타입으로 설치\r\n```\r\n\r\n따로 module이나 main에 등록할 필요 없이 사용하고자 하는 파일에 불러오면 된다.\r\n\r\n```typescript\r\nimport * as bcrypt from 'bcrypt';\r\n\r\n// 암호화 후 저장\r\nconst someFN = async (userData:UserData) =\u003e {\r\n\tconst hashPassword = await bcrypt.hash(userData.password,10)\r\n\tconst saveData = {\r\n    \temail:userData.email,\r\n        password: hashPassword,\r\n    }\r\n    // 정보 저장 로직\r\n}\r\n\r\n// 저장된 데이터를 통해 비밀번호 확인\r\nconst checkFN = async (userData:UserData) =\u003e{\r\n\tconst hashedPassword = // 저장된 정보 불러오는 로직\r\n\r\n    // true or false\r\n    const match = await bcrypt.compare(userData.password,hashedPassword)\r\n    if(match) // 인증 후 로직\r\n}\r\n```\r\n\r\n---\r\n\r\n참조 : https://github.com/kelektiv/node.bcrypt.js#readme\r\n"},{"title":"react common components","description":"React 공통 컴포넌트 제작 (input, button)","category":"react","keyword":"react, 공통 컴포넌트","date":"2023-04-13","content":"\r\n## 공통 컴포넌트 제작의 필요성\r\n\r\n\u003e 하나의 사이트를 제작할때 비슷한 input이나 button을 사용해야 하는 상황이 자주 있는데, 공통된 컴포넌트를 만들어 놓으면 코드 중복을 줄이면서 상황에 맞춰 적절하게 사용할 수 있게 된다.\r\n\r\n## 컴포넌트 제작\r\n\r\n### Input\r\n\r\n```typescript\r\nimport React from \"react\"; // element 속성을 가져오기 위해 import\r\nimport styled from \"styled-components\"; // CSS 적용\r\n\r\n// 컴포넌트의 props 타입을 InputElement의 속성과 내가 설정하고자 하는 타입을 포함한다.\r\ntype Props = React.HTMLAttributes\u003cHTMLInputElement\u003e \u0026 InputProps;\r\n\r\ninterface InputProps {\r\n  type?: string | undefined; // type?: 의 ?는 있어도 되고 없어도 된다는 의미\r\n  name?: string | undefined;\r\n  autoComplete?: string | undefined;\r\n  width: string;\r\n  height: string;\r\n  border?: string | undefined;\r\n}\r\n\r\n// width와 height는 number로 지정해도 무관하나,\r\n// 상황에 따라 뷰포트에 맞춰 쓸지, px에 맞춰 쓸지 달라질 수 있기 때문에 string으로 설정한 경우\r\n\r\nexport const MainInput = ({\r\n  type,\r\n  name,\r\n  autoComplete,\r\n  width,\r\n  height,\r\n  border,\r\n  ...props\r\n}: Props) =\u003e {\r\n  return (\r\n    \u003cMain\r\n      // input이 갖고 있는 속성을 사용할 수 있도록 도와준다. (placeholder, onChange 등 속성과 이벤트들)\r\n      {...props}\r\n      name={name}\r\n      autoComplete={autoComplete || \"on\"}\r\n      type={type || \"text\"}\r\n      style={{\r\n        width: `${width}`,\r\n        height: `${height}`,\r\n        border: `${border \u0026\u0026 border !== \"\" ? `1px solid ${border}` : \"\"}`,\r\n      }}\r\n    /\u003e\r\n  );\r\n};\r\n\r\nconst Main = styled.input`\r\n  padding: 5px;\r\n  border: none;\r\n  border: 1px solid ${props =\u003e props.theme.inputBorderColor};\r\n  border-radius: 5px;\r\n  font-size: 1.2rem;\r\n  \u0026:hover {\r\n    background: ${props =\u003e props.theme.inputBorderColor};\r\n  }\r\n  \u0026:focus {\r\n    outline: none;\r\n    border-color: ${props =\u003e props.theme.hoverBorderColor};\r\n    box-shadow: 0 0 1px ${props =\u003e props.theme.hoverBorderColor};\r\n  }\r\n`;\r\n```\r\n\r\n### TextArea\r\n\r\n```typescript\r\ntype TaProps = React.HTMLAttributes\u003cHTMLTextAreaElement\u003e \u0026 TextAreaProps;\r\ninterface TextAreaProps {\r\n  name?: string | undefined;\r\n  width: string;\r\n  height: string;\r\n  border?: string | undefined;\r\n}\r\n\r\nexport const MainTextArea = ({\r\n  name,\r\n  width,\r\n  height,\r\n  border,\r\n  ...props\r\n}: TaProps) =\u003e {\r\n  return (\r\n    \u003cTextArea\r\n      {...props}\r\n      name={name}\r\n      autoComplete=\"off\"\r\n      style={{\r\n        width: `${width}`,\r\n        height: `${height}`,\r\n        border: `${border \u0026\u0026 border !== \"\" ? `1px solid ${border}` : \"\"}`,\r\n      }}\r\n    /\u003e\r\n  );\r\n};\r\n\r\nconst TextArea = styled.textarea`\r\n  padding: 5px;\r\n  border: none;\r\n  border: 1px solid ${props =\u003e props.theme.inputBorderColor};\r\n  border-radius: 5px;\r\n  font-size: 1.2rem;\r\n  resize: none;\r\n  white-space: pre;\r\n  \u0026:hover {\r\n    background: ${props =\u003e props.theme.inputBorderColor};\r\n  }\r\n  \u0026:focus {\r\n    outline: none;\r\n    border-color: ${props =\u003e props.theme.hoverBorderColor};\r\n    box-shadow: 0 0 1px ${props =\u003e props.theme.hoverBorderColor};\r\n  }\r\n`;\r\n```\r\n\r\n## Button\r\n\r\n```typescript\r\ntype Props = React.HTMLAttributes\u003cHTMLButtonElement\u003e \u0026 ButtonProps;\r\n\r\ninterface ButtonProps {\r\n  type?: \"button\" | \"submit\" | \"reset\" | undefined; // 버튼 타입은 이와 같이 설정해준다.\r\n  content: string;\r\n  width: string;\r\n  height: string;\r\n}\r\n\r\nexport const MainButton = ({\r\n  type,\r\n  content,\r\n  width,\r\n  height,\r\n  ...props\r\n}: Props) =\u003e {\r\n  return (\r\n    \u003cMain\r\n      {...props}\r\n      type={type || \"button\"}\r\n      style={{ width: `${width}`, height: `${height}` }}\r\n    \u003e\r\n      {content}\r\n    \u003c/Main\u003e\r\n  );\r\n};\r\n\r\nconst Main = styled.button`\r\n  border: none;\r\n  border-radius: 5px;\r\n  background: none;\r\n  background-color: ${props =\u003e props.theme.mainButton};\r\n  color: ${props =\u003e props.theme.mainFontColor};\r\n  font-size: 1rem;\r\n  font-weight: bold;\r\n  cursor: pointer;\r\n  \u0026:hover {\r\n    background-color: ${props =\u003e props.theme.mainButtonHover};\r\n  }\r\n`;\r\n```\r\n"},{"title":"react type assertion","description":"React Form event type (feat. 타입 단언 as)","category":"react","keyword":"typescript, 이벤트타입","date":"2023-04-13","content":"\r\n## Form Event Type\r\n\r\n우리는 로그인이나 포스팅 등의 화면을 만들어줄 때 클라이언트가 입력하는 데이터를 입력받는 방법 중 하나로 onChange 등의 FormEvent를 이용해 원하는 값을 추출할 수 있다. 이때 이벤트 타입은 아래와 같이 사용될 수 있다.\r\n\r\n```typescript\r\nimport { FormEvent } from \"react\";\r\n\r\nexport type FormEvents = FormEvent\u003cHTMLFormElement\u003e;\r\nexport type InputEvent = FormEvent\u003cHTMLInputElement\u003e;\r\nexport type LabelEvent = FormEvent\u003cHTMLLabelElement\u003e;\r\n```\r\n\r\nreact에서 FormEvent 타입을 받아오고, 해당되는 element를 제네릭 타입으로 넣어주면 된다.\r\n\r\n## onChangeHandler\r\n\r\n```typescript\r\nconst [formData, setFormData] = useState(formDataInit);\r\nconst formChangeHandler = (e: FormEvent\u003cHTMLFormElement\u003e) =\u003e {\r\n  const target = e.target;\r\n  const name = target.name;\r\n  const value = target.value;\r\n  setFormData(prev =\u003e ({ ...prev, [name]: value }));\r\n};\r\n```\r\n\r\n원하는 데이터를 받을 수는 있지만, name과 value의 타입 에러가 발생한다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F80Q0s%2Fbtr9SOPHzuW%2F7t6EmYi1k5gMiyeurxmCP0%2Fimg.png)\r\n\r\ntarget의 타입을 정해줘도 타입 에러가 발생하는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbsb5ww%2Fbtr9N2aq2VJ%2FsFJkJduLoSt1bhyae9SFdK%2Fimg.png)\r\n\r\n하지만 우리는 form의 input이 변할때마다 대상의 값을 받아오는 것을 알고 있다.\r\n\r\n이때 필요한 것이 타입 단언(as)이다.\r\n\r\n## 타입 단언 사용 예시\r\n\r\n```typescript\r\nconst formChangeHandler = (e: FormEvents) =\u003e {\r\n  const target = e.target as InputTarget; // InputTarget === HTMLInputElement\r\n  const name = target.name;\r\n  const value = target.value;\r\n  setFormData(prev =\u003e ({ ...prev, [name]: value }));\r\n};\r\n```\r\n\r\n### 주의사항\r\n\r\n타입 단언을 사용하면 타입 체크를 할 수 없다. 사실상 강제로 타입을 지정하는 행위이기 때문에 타입 체커에게 해당 타입 에러를 무시하라는 명령이나 다름없다. as를 남발하거나 내려받는 데이터가 확실하지 않는 경우에는 오류 탐색에 지장이 있을 수 있으니, 로직에 따라 조건문 등을 사용해 타입 에러를 피해 주는 것이 좋을 수 있다.\r\n\r\n```typescript\r\n// ex)\r\nconst someFN = (someData) =\u003e{\r\n\tconst someMutation = someData..logic\r\n    if(someMutation){\r\n    \t// ... nest logic\r\n    }\r\n}\r\n```\r\n"},{"title":"css use download font","description":"CSS - 배포 사이트에 다운로드 폰트 적용하기","category":"css","keyword":"css, 폰트 적용","date":"2023-03-31","content":"\r\n\u003e 기본적으로 CSS에서 제공하는 폰트가 마음에 들지 않거나 내 프로젝트에 어울리지 않는 경우 간단하게 다운로드한 폰트를 프로젝트에 적용해볼 수 있다.\r\n\r\n## 1. 폰트 다운로드\r\n\r\n우선 마음에 드는 폰트를 다운받는다.\r\n\r\n카페24무료폰트: https://fonts.cafe24.com/\r\n\r\n무료 폰트 사이트는 찾아보면 사용할 수 있는게 많다.\r\n\r\n## 2. 프로젝트에 파일 복사\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbHA9Qr%2Fbtr60vtCf7O%2FMaaAsK1Lg4t5QDXd3bC1Uk%2Fimg.png)\r\n\r\n위와 같이 다운로드한 폰트를 작업중인 프로젝트에 넣어준다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FA7Inw%2Fbtr61haATVa%2F9mFQHIOUCbjYI7SnPm8wI0%2Fimg.png)\r\n\r\n필자는 styles/fonts/\\*\\*.ttf 와 같이 저장해줬다.\r\n\r\n## 3. CSS 설정\r\n\r\n@font -face{}를 이용해 불러올 폰트를 설정해준다.\r\n\r\n```css\r\n/* global.css */\r\n\r\n@font-face {\r\n  font-family: maplestory;\r\n  src: url(\"./fonts/Maplestory\\ Light.ttf\");\r\n}\r\n@font-face {\r\n  font-family: maplestoryBold;\r\n  src: url(\"./fonts/Maplestory\\ Bold.ttf\");\r\n}\r\n```\r\n\r\n## 4. CSS 사용\r\n\r\n평소에 폰트를 적용하는 것처럼 CSS를 적용해주면 된다.\r\n\r\n```css\r\nbody {\r\n  font-family: maplestory;\r\n}\r\n```\r\n"},{"title":"github markdown syntex","description":"Markdown 문법 정리","category":"github","keyword":"github, markdown","date":"2023-03-31","content":"\r\n## 1. headers\r\n\r\n\\# 으로 시작하는 텍스트로 1-6개 가능 (h1 ~ h6)\r\n\r\n```\r\n# h1\r\n## h2\r\n### h3\r\n#### h4\r\n##### h5\r\n###### h6\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FIOzmy%2Fbtr7d8qRKov%2FiXZSIKWKSOiAtliDzN63vK%2Fimg.png)\r\n\r\n## 2. 구분선\r\n\r\n\"---\"이나 \"\\*\\*\\*\"를 통해 구분선 생성 가능\r\n\r\n```\r\n***\r\n---\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbgcFby%2Fbtr7dx5ZjTh%2FlEqZkNRdg7rLooCPmMFZW0%2Fimg.png)\r\n\r\n## 3. 줄바꿈\r\n\r\n\"\u003cbr\u003e\"\r\n\r\n```\r\n줄을\u003cbr\u003e바꿈\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc8z1Q4%2Fbtr7fs3s9fI%2FhLPfWRYRfKMIC2tUvU8531%2Fimg.png)\r\n\r\n## 4. 강조\r\n\r\n기울여쓰기(italic) : \\* 또는 \\_로 감싼 텍스트.\r\n\r\n두껍게 쓰기(bold) : \\*\\* 또는 \\_\\_로 감싼 텍스트.\r\n\r\n취소선 : ~~로 감싼 텍스트\r\n\r\n```\r\n_기울여쓰기 1_\r\n*기울여쓰기 2*\r\n**두껍게 1**\r\n__두껍게 2__\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbu2sXJ%2Fbtr7dNgeNxn%2FcCfQQ9PumZ7OzrH2KeXq5K%2Fimg.png)\r\n\r\n## 5. 인용\r\n\r\n\\\u003e로 시작하는 텍스트로 \u003e\u003e\u003e와 같이 3개까지 사용 가능\r\n\r\n```\r\n\u003e 인용문\r\n\u003e \u003e 3개까지\r\n\u003e \u003e \u003e 사용 가능\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbGU0Me%2Fbtr7ghUUjee%2FqgoUnVkdOOkK7Kb5Gq1oPK%2Fimg.png)\r\n\r\n## 6. 리스트\r\n\r\n리스트는 Tab을 통해 목록 안의 목록 생성 가능\r\n\r\n### 순서가 없는 목록\r\n\r\n\\*, +, -를 통해 순서가 없는 목록 생성 가능\r\n\r\n```\r\n- 순서가 없는 목록1\r\n- 순서가 없는 목록1\r\n- 순서가 없는 목록1\r\n\r\n* 순서가 없는 목록2\r\n  - 탭을 이용한 목록 안의 목록\r\n    - 탭을 이용한 목록 안의 목록 안의 목록\r\n\r\n1. 순서가 있는 목록1\r\n2. 순서가 있는 목록1\r\n3. 순서가 있는 목록1\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdQp7i8%2Fbtr7e1ygv06%2FvMIjB3OsI8Q5fAteCTJbF1%2Fimg.png)\r\n\r\n### 순서가 있는 목록\r\n\r\n숫자를 기입하면 순서가 있는 목록이 됨\r\n\r\n들여쓰기를 하면 모양이 바뀜\r\n\r\n숫자를 무엇을 쓰든 순서대로 알아서 숫자를 매김\r\n\r\n리스트 안에 하위 리스트를 만들기 위해서는 tab과 함께 숫자 1번부터 나열하면 적용 가능\r\n\r\n```\r\n1. 순서가 있는 목록2\r\n2. 순서가 있는 목록2\r\n   1. 탭을 이용한 순서가 있는 목록 안의 목록\r\n      1. 탭을 이용한 순서가 있는 목록 안의 목록 안의 목록\r\n   2. 탭을 이용한 순서가 있는 목록 안의 목록\r\n5. 순서가 있는 목록2\r\n```\r\n\r\n혼합 리스트도 적용 가능\r\n\r\n```\r\n1. 순서가 있는 목록2\r\n2. 순서가 있는 목록2\r\n   1. 탭을 이용한 순서가 있는 목록 안의 목록\r\n      * 탭을 이용한 순서가 있는 목록 안의 목록 안의 순서가 없는 목록\r\n   2. 탭을 이용한 순서가 있는 목록 안의 목록\r\n5. 순서가 있는 목록2\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlhYHi%2Fbtr7dPd52Gh%2FY87O8eblzYL1LiuEiIdMik%2Fimg.png)\r\n\r\n## 7. 이미지\r\n\r\n링크와 비슷하나 앞에 느낌표가 붙음\r\n\r\n인라인 이미지 : ![텍스트](이미지파일 경로)\r\n\r\n![image](\"./../../../../public/images/cards/GITHUB.png)\r\n\r\n링크 이미지 : ![텍스트] (이미지파일URL)\r\n\r\n![image](https://img1.daumcdn.net/thumb/C428x428/?scode=mtistory2\u0026fname=https%3A%2F%2Ftistory1.daumcdn.net%2Ftistory%2F5148697%2Fattach%2Fc60c2213f3984f0b9da48413e3fa277e)\r\n\r\n이미지 파일에 마우스를 올렸을 때 커서 앞에 나오는 텍스트 설정\r\n\r\n![텍스트] (이미지경로/URL \"이미지이름\")\r\n\r\n![image](https://img1.daumcdn.net/thumb/C428x428/?scode=mtistory2\u0026fname=https%3A%2F%2Ftistory1.daumcdn.net%2Ftistory%2F5148697%2Fattach%2Fc60c2213f3984f0b9da48413e3fa277e \"이미지지롱\")\r\n\r\n링크와 이미지를 합친 문법 (이미지를 링크로 사용)\r\n\r\n[![텍스트] (이미지URL)] (링크URL)\r\n\r\n[![image](https://img1.daumcdn.net/thumb/C428x428/?scode=mtistory2\u0026fname=https%3A%2F%2Ftistory1.daumcdn.net%2Ftistory%2F5148697%2Fattach%2Fc60c2213f3984f0b9da48413e3fa277e)](https://lee-yo-han.github.io/github-token-expired)\r\n\r\n## 8. Link (Anchor)\r\n\r\n글자로 된 하이퍼링크\r\n\r\n```\r\n[구글] (링크)\r\n```\r\n\r\n[구글](https://www.google.com/)\r\n\r\n내부(해시) 링크\r\n\r\n[보여지는 내용] (#이동할 헤드(제목))\r\n\r\n괄호 안 링크의 띄어쓰기는 -로 연결, 영어는 모두 소문자로 작성\r\n\r\n```\r\n[어디로든문](#1-headers)\r\n```\r\n\r\n[어디로든문](#1-headers)\r\n\r\n## 9. 코드 블럭\r\n\r\n백틱(`) 3개씩으로 감싸서 사용\r\n\r\n```\r\n'''javascript\r\nsome code ...\r\n'''\r\n```\r\n\r\n## 10. 테이블\r\n\r\n헤더와 셀 구분 시 3개 이상의 하이픈(-) 필요\r\n헤더 셀을 구분하면서 콜론(:)으로 정렬 가능\r\n가장 좌측과 가장 우측에 있는 vertical bar( | ) 기호 생략 가능\r\n\r\n```\r\n| 헤더1 | 헤더2    |   헤더3    |    헤더4 |\r\n| ----- | :------- | :--------: | -------: |\r\n| 셀1   | 셀2      |    셀3     |      셀4 |\r\n| 기본  | 좌로정렬 | 가운데정렬 | 우로정렬 |\r\n| 셀9   | 셀10     |    셀11    |     셀12 |\r\n```\r\n\r\n| 헤더1 | 헤더2    |   헤더3    |    헤더4 |\r\n| ----- | :------- | :--------: | -------: |\r\n| 셀1   | 셀2      |    셀3     |      셀4 |\r\n| 기본  | 좌로정렬 | 가운데정렬 | 우로정렬 |\r\n| 셀9   | 셀10     |    셀11    |     셀12 |\r\n\r\n---\r\n\r\n참조 https://inpa.tistory.com/entry/MarkDown-%F0%9F%93%9A-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC\r\n"},{"title":"github token expired","description":"Github Token을 이용한 GithubAPI 사용","category":"github","keyword":"github, api","date":"2023-03-31","content":"\r\n### **본 포스팅은 NextJS 13 환경에서 진행한 내용을 바탕으로 한다. GithubAPI 사용법은 공식 문서에 상세히 나와있기 때문에 사용법보다 토큰 만료 문제를 주로 다룬다.**\r\n\r\n## GithubAPI란?\r\n\r\n\u003e Github의 기능을 REST API 형식으로 사용할 수 있도록 도와주는 기능이다.\r\n\r\n**[GithubAPI docs](https://docs.github.com/en/rest?apiVersion=2022-11-28)**\r\n\r\n아래와 같이 사용할 수 있는 기능이 많다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6rpoI%2Fbtr65pd5Q0W%2F7NUKUqiXklINKYLwJWPow1%2Fimg.png)\r\n\r\n## 1. 토큰 발급\r\n\r\n간단한 조회 정도는 토큰이 필요하지 않지만, 요청의 종류에 따라 토큰이 필요한 경우가 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbS8fhz%2Fbtr60iAL28F%2FxJ66qxT7PKF4U6JjLkCA91%2Fimg.png)\r\n\r\n우선 우측 상단의 Settings로 들어가서\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdU186G%2Fbtr61k5X0vE%2FdrgRV6uJMfho9JCIhoUghk%2Fimg.png)\r\n\r\nSettings의 좌측 하단 Developer settings에 들어간다.\r\n\r\n그 안에 Pat(personal access tokens)를 발급받을 수 있는 창을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FE3TPa%2Fbtr60DxUYrw%2FtWMeaxCI78Cyx9838COCVK%2Fimg.png)\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnE2jt%2Fbtr60gbWaov%2FQ897sC2Gk2RxKlsBVZ5jLK%2Fimg.png)\r\n\r\nGenerate new token을 통해 원하는 종류의 토큰을 받을 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHPjvr%2Fbtr61gW4V3n%2Fvqk7jPvdQAcdlAfXomGiQ0%2Fimg.png)\r\n\r\n토큰명, 유효기간, access할 repo를 설정하고\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbX6MQh%2Fbtr61lcFYwt%2F1fkFl327Q0I91UIwAgfCfK%2Fimg.png)\r\n\r\n원하는 기능에 대한 권한을 설정해준다.\r\n\r\n이번엔 간단하게 issue에 대한 작업만 진행해본다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVESxa%2Fbtr63YA3qrw%2FCedCRRISe4SG6PLHK4H0dK%2Fimg.png)\r\n\r\n생성된 토큰은 잘 복사해 안전한 공간에 저장해준다.\r\n\r\n## 2. Token 사용\r\n\r\n기본적인 사용법은 아래와 같다.\r\n\r\nhttps://docs.github.com/en/rest/guides/getting-started-with-the-rest-api?apiVersion=2022-11-28\r\n\r\n```typescript\r\n// issues 등록하기\r\nimport { Octokit } from \"octokit\";\r\n\r\nconst octokit = new Octokit({\r\n  auth: `api token`,\r\n});\r\n\r\nconst issueUpdate = async (name: string, feed: string) =\u003e {\r\n  await octokit.request(\r\n    \"POST /repos/{owner}/{repository name}/issues/1/comments\",\r\n    {\r\n      owner: \"user name\",\r\n      repo: \"repository name\",\r\n      title: `title`,\r\n      body: `body`,\r\n      // headers: {\r\n      //   \"X-GitHub-Api-Version\": \"2022-11-28\",\r\n      // },\r\n    },\r\n  );\r\n};\r\n```\r\n\r\n위 요청을 실행하면 정상적으로 issue 등록이 되는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbjcLkP%2Fbtr65o7kXPZ%2Fh739Lzn25eBdRhDzcPPU8K%2Fimg.png)\r\n\r\n## 유의할 점\r\n\r\n### 1. headers 설정\r\n\r\n우선 headers를 주석처리한 이유는 공식 문서에서는 github API version을 headers에 담으라고 돼있지만, 버전과 함께 요청을 실행하면 cors에러가 발생하는 것을 볼 수 있다.\r\n\r\n**[Github CORS ISSUE](https://github.com/orgs/community/discussions/40619)**\r\n\r\nheaders는 별도로 추가하지 말고 auth만 설정해준 후 사용해 주도록 한다.\r\n\r\n### 2. auth Token 설정\r\n\r\nAPI key와 같은 토큰은 대부분 .env를 통해 변수를 설정해 사용해줘야 한다.\r\n\r\n하지만 .env에 토큰을 설정하고 commit을 하게되면 gitignore를 설정해줘도 github가 자동으로 감지해 토큰을 만료시키기 때문에 .env.local서 테스트하고 .env의 토큰은 지운 뒤에 사용해주자.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FuJQsS%2Fbtr62Xh6jLO%2FHkR7hA4k0cMffBKY55DHu1%2Fimg.png)\r\n\r\n---\r\n\r\n참조 : https://docs.github.com/en\r\n"},{"title":"react smooth scroll","description":"React/Javascript 부드러운 스크롤 이동 적용","category":"react","keyword":"react, smoooth scroll","date":"2023-03-25","content":"\r\n# **부드러운 스크롤 이동 적용 방법**\r\n\r\n\u003e behavior:\"smooth\" 속성을 scroll 이벤트와 scroll 메서드와 같이 사용하며 부드러운 스크롤 이동을 적용해볼 수 있다.\r\n\r\n본 보스팅은 Nextjs 13 환경에서 작성되었다.\r\n\r\n## **scroll() 메서드**\r\n\r\n### **scroll() , scrollTo()**\r\n\r\nscroll(x,y) || scroll(options), scrollTo(x,y) || scrollTo(options) 와 같이 사용할 수 있다.\r\n\r\n사실상 두 메서드는 동일하게 작동한다.\r\n\r\nxy 좌표를 통해서도 사용 가능하며 options를 적용한다면 아래와 같이 사용할 수 있다.\r\n\r\n```javascript\r\nwindow.scroll({\r\n  top: 0,\r\n  left: 0,\r\n  behavior: \"smooth\", // smooth: 부드럽게 전환 , auto: 즉시 이동\r\n});\r\n\r\nwindow.scrollTo({\r\n  top: 0,\r\n  left: 0,\r\n  behavior: \"smooth\", // smooth: 부드럽게 전환 , auto: 즉시 이동\r\n});\r\n```\r\n\r\n### **scrollBy()**\r\n\r\n**scrollBy(x,y) || scrollBy(options)**\r\n\r\nscroll()과 scrollTo()가 특정 좌표로 이동한다면, scrollBy는 길이만큼 스크롤을 이동시킨다.\r\n\r\n옵션과 예제는 아래와 같다.\r\n\r\n```javascript\r\n// 기본 사용\r\nwindow.scrollBy(x, y);\r\n\r\n// 한 페이지 아래\r\nwindow.scrollBy(0, window.innerHeight);\r\n\r\n// 한 페이지 위\r\nwindow.scrollBy(0, -window.innerHeight);\r\n\r\n// 옵션\r\nwindow.scrollBy({\r\n  top: 0,\r\n  left: 0,\r\n  behavior: \"smooth\", // smooth: 부드럽게 전환 , auto: 즉시 이동\r\n});\r\n```\r\n\r\nscroll 메서드가 적용된 화면과 예제코드\r\n\r\n![image](https://blog.kakaocdn.net/dn/bV3l2O/btr5OcgXBcx/ickRekJIOy3VMmRLtzt2pK/img.gif)\r\n\r\n```javascript\r\n// 최상단으로 이동\r\nconst moveScroll = () =\u003e {\r\n  scroll({ top: 0, behavior: \"smooth\" });\r\n};\r\n\r\n// 한 페이지 위로 이동\r\nconst moveScrollByUp = () =\u003e {\r\n  scrollBy({ top: -window.innerHeight, behavior: \"smooth\" });\r\n};\r\n\r\n// 한 페이지 아래로 이동\r\nconst moveScrollByDown = () =\u003e {\r\n  scrollBy({ top: window.innerHeight, behavior: \"smooth\" });\r\n};\r\n\r\n// top 500 위치로 이동\r\nconst moveScrollTo = () =\u003e {\r\n  scrollTo({\r\n    top: 500,\r\n    behavior: \"smooth\",\r\n  });\r\n};\r\n\r\n// jsx\r\n\u003cContainer\u003e\r\n  \u003cNavBtn\u003e\r\n    \u003cbutton onClick={moveScroll}\u003eScroll최상단\u003c/button\u003e\r\n    \u003cbutton onClick={moveScrollByUp}\u003emoveScrollByUp\u003c/button\u003e\r\n    \u003cbutton onClick={moveScrollByDown}\u003emoveScrollByDown\u003c/button\u003e\r\n    \u003cbutton onClick={moveScrollTo}\u003emoveScrollTo\u003c/button\u003e\r\n  \u003c/NavBtn\u003e\r\n  \u003cTestContainer1 id=\"box1\" /\u003e\r\n  \u003cTestContainer2 id=\"box2\" /\u003e\r\n  \u003cTestContainer3 id=\"box3\" /\u003e\r\n  \u003cTestContainer4 id=\"box4\" /\u003e\r\n  \u003cTestContainer5 id=\"box5\" /\u003e\r\n  \u003cTestContainer6 id=\"box6\" /\u003e\r\n\u003c/Container\u003e;\r\n```\r\n\r\n## **Chrome 브라우저에서 behavior:\"smooth\" 속성이 적용되지 않을 때**\r\n\r\n아래와 같이 크롬 버전은 최신이지만, smooth 속성이 적용되지 않는 현상이 나타났다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fx3Fal%2Fbtr5ORwXdp3%2FAHsT7DB2D5i76OjhYqcN9k%2Fimg.png)\r\n\r\n![image](https://blog.kakaocdn.net/dn/bourLn/btr5NyrsLbU/nkulo83V1NSn2kEMQb2xYK/img.gif)\r\n\r\n호환성에도 문제가 없지만 MDN의 예제를 실행해 봐도 크롬에선 smooth 속성이 사용되지 않았다.\r\n\r\nMDN 스크롤 예제 : https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmJ1Dl%2Fbtr5Nv2OZvD%2Fmk5c6Hks8ai7J4UKhL6wR1%2Fimg.png)\r\n\r\n크롬 브라우저 설정을 따로 해주면 해결된다고는 하지만, 내 PC에서만 작동하는 건 근본적인 해결방법이 아니기 때문에 배제했다.\r\n\r\n참조 : http://www.devdic.com/css/refer/properties/property:1195/scroll-behavior\r\n\r\n### **smoothscroll-polyfill - 적용 실패**\r\n\r\n사용법 : https://www.npmjs.com/package/smoothscroll-polyfill?activeTab=readme\r\n\r\n```typescript\r\n// 패키지 설치\r\n// yarn add smoothscroll-polyfill\r\n\r\n// 최상단 파일\r\n\r\nimport smoothscroll from \"smoothscroll-polyfill\";\r\n\r\nif (typeof window !== \"undefined\") {\r\n  smoothscroll.polyfill();\r\n}\r\n```\r\n\r\n브라우저 호환성 적용을 위한 패키지라고 하는데, 본인에겐 효과가 없었다.\r\n\r\n## **scroll 이벤트를 통한 스크롤 이동 적용**\r\n\r\n스크롤만 이용해서 기능을 적용할 생각이었기에 직접 만들기로 했다.\r\n\r\naddEventListener를 통해 스크롤 이벤트를 감지해 주는 hook을 만들어줬다.\r\n\r\n```typescript\r\n// 스크롤 위 아래 여부 확인\r\nimport { useState, useEffect, useRef } from \"react\";\r\n\r\ninterface MutableRefObject\u003cT\u003e {\r\n  current: T;\r\n}\r\n\r\nexport const useScroll = () =\u003e {\r\n  const [scrollCheck, setScrollCheck] = useState(\"\");\r\n  const prevScrollPos: MutableRefObject\u003cnumber\u003e = useRef(0);\r\n\r\n  useEffect(() =\u003e {\r\n    const handleScroll = () =\u003e {\r\n      const currentScrollPos = window.pageYOffset; // window객체의 pageYOffset 를 통해 현재 스크롤 위치 저장\r\n      if (currentScrollPos \u003e prevScrollPos.current) {\r\n        // 스크롤 위치에 따른 스크롤 진행 방향 검증\r\n        setScrollCheck(\"DOWN\");\r\n      } else {\r\n        setScrollCheck(\"UP\");\r\n      }\r\n      prevScrollPos.current = currentScrollPos; // 사용된 현재 스크롤 위치를 다음 이벤트 비교대상으로 저장\r\n    };\r\n\r\n    window.addEventListener(\"scroll\", handleScroll); // event 등록\r\n    return () =\u003e {\r\n      window.removeEventListener(\"scroll\", handleScroll); // event clear\r\n    };\r\n  }, [prevScrollPos]);\r\n  return {\r\n    scrollCheck, // up/down 여부 return\r\n  };\r\n};\r\n\r\n// hook 사용 컴포넌트\r\nimport { useScroll } from \"@/hooks/useScroll\";\r\nconst { scrollCheck } = useScroll();\r\nuseEffect(() =\u003e {\r\n  if (scrollCheck === \"UP\") {\r\n    console.log(\"scroll UP\");\r\n  }\r\n  if (scrollCheck === \"DOWN\") {\r\n    console.log(\"scroll DOWN\");\r\n  }\r\n}, [scrollCheck]);\r\n```\r\n\r\n원하는 값이 잘 나오는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FF7CNJ%2Fbtr5QzP3p9N%2FErlbv8julxnc1PKZSGRC71%2Fimg.png)\r\n\r\n\u003e 스크롤 이벤트 특성상 한 번 휠을 돌릴 때마다 많은 호출이 일어나기 때문에 필요한 경우에만 사용될 수 있도록 setTimeout 등을 통해 적용하고자 하는 코드에 맞게 함수 실행을 조절해줘야 한다.\r\n\r\n```typescript\r\nimport { useState, useEffect, useRef } from \"react\";\r\nimport { scrollToSmoothly } from \"@/components/profile/SmoothScroll\";\r\nimport { useScroll } from \"@/hooks/useScroll\";\r\nconst { scrollCheck } = useScroll();\r\nconst scrollRef = useRef({\r\n  // window.innerHeight 값 저장\r\n  height: 0,\r\n});\r\n\r\nconst smoothScrollHandler = () =\u003e {\r\n  let maxHeight = window.innerHeight * 6; // 최대 스크롤 길이\r\n  let currentHeight = scrollRef.current.height; // 현재 스크롤 저장\r\n  if (scrollCheck === \"UP\" \u0026\u0026 currentHeight !== 0) {\r\n    // scroll up이고 맨 위가 아닐 때\r\n    scrollRef.current.height -= window.innerHeight; // useRef에 이동할 height 조정\r\n    scrollToSmoothly(scrollRef.current.height, 500); // 이동할 height까지 500ms동안 이동시킬 함수 (requestAnimationFrame 사용)\r\n  } else if (scrollCheck === \"DOWN\" \u0026\u0026 currentHeight !== maxHeight) {\r\n    // scroll이 down이고 맨 아래가 아닐 때\r\n    scrollRef.current.height += window.innerHeight; // 상기 동일\r\n    scrollToSmoothly(scrollRef.current.height, 500);\r\n  }\r\n};\r\n\r\nuseEffect(() =\u003e {\r\n  smoothScrollHandler();\r\n}, [scrollCheck]); // useScroll()을 통해 구분한 UP/Down이 변경될 때마다 실행\r\n```\r\n\r\n위의 함수를 실행하면 아래와 같이 그나마 정상 작동하는 모습을 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/cpwxY9/btr5NJNGHOP/34qTHrvGprHknp2jmkpkpK/img.gif)\r\n\r\n## **a 태그를 통한 스크롤 이동**\r\n\r\na 태그의 href 속성을 이용해 간단하게 스크롤을 이동시키는 방법도 있다.\r\n\r\n```javascript\r\n\u003cProfileContainer\u003e\r\n  \u003cNavBtn\u003e\r\n    \u003cLink href=\"#box1\"\u003e1번박스로 이동\u003c/Link\u003e // nextjs에서 Link는 a태그의 역할을\r\n    한다.\r\n    \u003cLink href=\"#box2\"\u003e2번박스로 이동\u003c/Link\u003e // href에 스크롤을 이동시킬 'ID'를 입력하고\r\n    클릭하면\r\n    \u003cLink href=\"#box3\"\u003e3번박스로 이동\u003c/Link\u003e // 해당 ID요소로 스크롤을\r\n    이동시킨다.\r\n    \u003cLink href=\"#box4\"\u003e4번박스로 이동\u003c/Link\u003e\r\n    \u003cLink href=\"#box5\"\u003e5번박스로 이동\u003c/Link\u003e\r\n    \u003cLink href=\"#box6\"\u003e6번박스로 이동\u003c/Link\u003e\r\n  \u003c/NavBtn\u003e\r\n  \u003cTestContainer1 id=\"box1\" /\u003e\r\n  \u003cTestContainer2 id=\"box2\" /\u003e\r\n  \u003cTestContainer3 id=\"box3\" /\u003e\r\n  \u003cTestContainer4 id=\"box4\" /\u003e\r\n  \u003cTestContainer5 id=\"box5\" /\u003e\r\n  \u003cTestContainer6 id=\"box6\" /\u003e\r\n\u003c/ProfileContainer\u003e\r\n```\r\n\r\n---\r\n\r\n**참조**\r\n\r\n**scroll 메서드**\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/Window/scroll\r\n\r\n**requestAnimationFrame**\r\n\r\nhttps://developer.mozilla.org/ko/docs/Web/API/window/requestAnimationFrame\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp\r\n"},{"title":"react component lifecycle","description":"React 함수형 컴포넌트와 Class형 컴포넌트 생명주기","category":"react","keyword":"react, 함수형 컴포넌트, Class형 컴포넌트","date":"2023-03-23","content":"\r\n# **React state와 LifeCycle**\r\n\r\n\u003e 함수형 컴포넌트와 class형 컴포넌트의 LifeCycle이 어떻게 되는지 간단하게 비교해 보는 글이다.\r\n\r\n## 클래스형 컴포넌트와 생명주기 메서드\r\n\r\n### 1. Mount(컴포넌트가 처음 실행될 때)\r\n\r\n- state, context, defalutProps 저장\r\n- componentWillMount - 안전하지 않은 접근\r\n- render\r\n- componentDidMount - DOM 접근 가능\r\n\r\n### 2. Props Update(프롭스가 업데이트될때)\r\n\r\n- componentWillReceiveProps - 사용 종료\r\n- shouldComponentUpdate\r\n- componentWillUpdate - 사용 종료\r\n- render\r\n- componentDidUpdate - DOM 접근 가능\r\n\r\n### 3. State Update (스테이트가 업데이트됐을 때)\r\n\r\n- shouldComponentUpdate\r\n- componentWillUpdate - 사용 종료\r\n- render\r\n- componentDidUpdate - DOM 접근 가능\r\n\r\n**사실상 componentWillReceiveProps와 componentWillUpdate의 사용 종료로 state와 props가 업데이트될 때 동일하게 작동한다.**\r\n\r\n### 4. Unmount (컴포넌트가 제거되는 것)\r\n\r\n- componentWillUnmount\r\n\r\n사용 종료의 기준은 아래와 같다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb0qQTJ%2Fbtr5h96VtyB%2FqLpFZAk7aybC21CEWPD9H1%2Fimg.png)\r\n\r\n## 함수형 컴포넌트와 useEffect 훅\r\n\r\n### 컴포넌트의 실행\r\n\r\n- 함수형 컴포넌트 호출\r\n\r\n- 함수형 컴포넌트의 내부에서 실행\r\n\r\n- return()으로 화면에 렌더링\r\n\r\n- 생명주기 메서드 대신 useEffect를 통한 비슷한 처리 가능\r\n\r\n### dependency에 따른 useEffect의 실행\r\n\r\n- deps 값이 없는 경우 : 화면이 렌더링 된 이후 수행이 되며, 리렌더링이 발생할 때마다 다시 실행\r\n\r\n- deps 값이 빈 배열인 경우 : 첫 렌더링 완료 후 1회만 실행\r\n\r\n- deps 값이 존재하는 경우 : 첫 렌더링 완료 후 1회 실행 \u0026\u0026 deps 값이 변경되었을 경우마다 실행\r\n\r\n```javascript\r\n// dep X\r\nuseEffect(() =\u003e {\r\n  // effect\r\n  return () =\u003e {\r\n    // cleanup\r\n  };\r\n});\r\n\r\n// dep []\r\nuseEffect(() =\u003e {\r\n  return () =\u003e {};\r\n}, []);\r\n\r\n// dep [some dep...]\r\nuseEffect(() =\u003e {\r\n  return () =\u003e {};\r\n}, [dep]);\r\n```\r\n\r\n**[Mounting]** useEffect() - 컴포넌트 렌더링 이후 실행\r\n\r\n- dep 설정에 따라 실행됨\r\n\r\n**[Updating]** useEffect() - 컴포넌트 내에서 변화가 발생했을 경우 실행\r\n\r\n- 부모 컴포넌트의 리렌더링, 부모로부터의 props값 변화, 해당 컴포넌트 내에서 state 변경 등\r\n\r\n**[Unmounting]** useEffect() - 컴포넌트 내에서 DOM을 제거할 때 실행되는 메서드\r\n\r\n- 컴포넌트의 DOM이 제거될 때 수행되며 useEffect 내부의 return 값이 사용됨\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbryvuq%2Fbtr5pFcEsKC%2FIUUp45qfkl3kWGMGsXLoF0%2Fimg.png)\r\n\r\n**위와 같이 컴포넌트를 여닫는 페이지가 있다고 가정했을 때, console을 통해 대략적인 흐름을 확인해 볼 수 있다.**\r\n\r\n### **Class형 컴포넌트**\r\n\r\n**컴포넌트가 처음 실행될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOvMHN%2Fbtr5nGi34Pf%2Fr7cGOBhis0thuYoKgE5Y81%2Fimg.png)\r\n\r\n**state가 변경될 때 (props가 변경될 때와 동일)**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FD45Ra%2Fbtr5gtxPbHC%2FBcyreT9Rmknfdukr6PuUMK%2Fimg.png)\r\n\r\n**컴포넌트가 제거될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6mDAw%2Fbtr5qsKSrcJ%2FSzo6Rjkm0liLDy3wCZZ27k%2Fimg.png)\r\n\r\n### **함수형 컴포넌트**\r\n\r\n**컴포넌트가 처음 실행될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3fXKy%2Fbtr5paDZhii%2FxGLf5vByXzPMT1jphHzBkK%2Fimg.png)\r\n\r\n**컴포넌트가 업데이트될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7vKwD%2Fbtr5paYhomj%2F5iPCpcpuRTIKbpr0dFNNO1%2Fimg.png)\r\n\r\n\u003e 콘솔에 출력된 것과 같이, useEffect의 return 이후 부분은 componentWillUnmount와 비슷하지만, 컴포넌트가 다시 렌더링 되기 전마다 다시 실행된다.\r\n\r\n**컴포넌트가 제거될 때**\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5feUj%2Fbtr5sdzGrHx%2F1FTXMaZBnR6FmKQmslJRK1%2Fimg.png)\r\n\r\n컴포넌트가 제거될 때는 componentWillUnmount처럼 useEffect의 return 부분이 실행되는 것을 볼 수 있다.\r\n\r\n사용된 코드\r\n\r\n```javascript\r\n// Lifecycle.jsx\r\n\r\nimport { useState } from \"react\";\r\nimport { FunctionComponent } from \"./FunctionComponent\";\r\nimport { ClassComponent } from \"./ClassComponent\";\r\n\r\nexport const Lifecycle = () =\u003e {\r\n  const [fnOpen, setFnOpen] = useState(false);\r\n  const [classOpen, setClassOpen] = useState(false);\r\n  const effectComponentHandler = num =\u003e {\r\n    if (num) {\r\n      setFnOpen(!fnOpen);\r\n    } else {\r\n      setClassOpen(!classOpen);\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eFn component / Class component\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e effectComponentHandler(1)}\u003e함수 open/close\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e effectComponentHandler(\"\")}\u003e\r\n        클래스 open/close\r\n      \u003c/button\u003e\r\n      {fnOpen ? \u003cFunctionComponent some1={1} some2={2} some3={3} /\u003e : null}\r\n      {classOpen ? \u003cClassComponent some1={1} some2={2} some3={3} /\u003e : null}\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n```javascript\r\n// FunctionComponent.jsx\r\n\r\nimport { useState, useEffect } from \"react\";\r\n\r\nexport const FunctionComponent = props =\u003e {\r\n  console.log(\"컴포넌트 렌더링\", props);\r\n  const [count, setCount] = useState(0);\r\n  useEffect(() =\u003e {\r\n    // effect\r\n    if (count === 0) {\r\n      console.log(`useEffect 첫 등장`);\r\n    } else {\r\n      console.log(`useEffect 다시 등장 count: ${count}`);\r\n    }\r\n    return () =\u003e {\r\n      // cleanup\r\n      console.log(\r\n        \"useEffect 퇴장 --- componentWillUnmount와 비슷하지만 리렌더링마다 사용됨\",\r\n      );\r\n    };\r\n  }, [count]);\r\n\r\n  const plus = () =\u003e {\r\n    setCount(prev =\u003e prev + 1);\r\n  };\r\n  const minus = () =\u003e {\r\n    setCount(prev =\u003e prev - 1);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e함수형 컴포넌트\u003c/p\u003e\r\n      \u003cspan\u003e{count}\u003c/span\u003e\r\n      \u003cbutton onClick={plus}\u003e+\u003c/button\u003e\r\n      \u003cbutton onClick={minus}\u003e-\u003c/button\u003e\r\n      \u003cp\u003eProps 받기\u003c/p\u003e\r\n      \u003cdiv\u003eprops1 = {props.some1}\u003c/div\u003e\r\n      \u003cdiv\u003eprops2 = {props.some2}\u003c/div\u003e\r\n      \u003cdiv\u003eprops3 = {props.some3}\u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n```javascript\r\n// ClassComponent.jsx\r\n\r\nimport { Component } from \"react\";\r\n\r\nexport class ClassComponent extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    // Class형 컴포넌트의 state는 무조건 객체 형태여야 한다.\r\n    this.state = {\r\n      counter: 0,\r\n    };\r\n    console.log(\r\n      \"Mount - 컴포넌트가 처음 실행될 때 state, context, defalutProps 저장\",\r\n      props,\r\n    );\r\n  }\r\n  plus = () =\u003e {\r\n    this.setState(state =\u003e ({ counter: state.counter + 1 }));\r\n  };\r\n  minus = () =\u003e {\r\n    this.setState(state =\u003e ({ counter: state.counter - 1 }));\r\n  };\r\n\r\n  componentWillMount() {\r\n    console.log(\"componentWillMount\");\r\n  }\r\n  componentDidMount() {\r\n    console.log(\"componentDidMount - DOM 접근 가능\");\r\n  }\r\n  componentDidUpdate() {\r\n    console.log(\"componentDidUpdate\");\r\n  }\r\n  shouldComponentUpdate() {\r\n    console.log(\"shouldComponentUpdate - state or props 업데이트\");\r\n    return true;\r\n  }\r\n  componentWillUnmount() {\r\n    console.log(\"componentWillUnmount\");\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      \u003cdiv\u003e\r\n        \u003cp\u003eClass형 컴포넌트\u003c/p\u003e\r\n        \u003cspan\u003e{this.state.counter}\u003c/span\u003e\r\n        \u003cbutton onClick={this.plus}\u003e+\u003c/button\u003e\r\n        \u003cbutton onClick={this.minus}\u003e-\u003c/button\u003e\r\n        \u003cp\u003eProps 받기\u003c/p\u003e\r\n        \u003cdiv\u003eprops1 = {this.props.some1}\u003c/div\u003e\r\n        \u003cdiv\u003eprops2 = {this.props.some2}\u003c/div\u003e\r\n        \u003cdiv\u003eprops3 = {this.props.some3}\u003c/div\u003e\r\n      \u003c/div\u003e\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n참조\r\n\r\nhttps://ko.reactjs.org/docs/state-and-lifecycle.html\r\n\r\nhttps://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html\r\n"},{"title":"javascript dynamic import","description":"Dynamic import를 사용해 동적으로 모듈 가져오기","category":"javascript","keyword":"javascript, Dynamic import","date":"2023-03-18","content":"\r\n# Dynamic import란?\r\n\r\n\u003e import() 표현식으로 사용하며, 표현식은 모듈을 읽고 해당 모듈이 내보내는 것들을 모두 포함하는 객체를 담은 이행된 Promise를 반환한다. 호출은 어디서나 가능하다.\r\n\r\n# Dynamic import를 사용하는 이유\r\n\r\n- 기존 import문은 정적인 방식으로, 정적으로 가져오는 경우 코드 로드 속도가 느려지고, 가져오는 코드가 필요할 가능성이 적거나 없을 수 있다.\r\n- 정적으로 가져올 때 프로그램의 메모리 사용량이 크게 증가하고 가져오는 코드가 필요할 가능성이 낮다.\r\n- import문에 동적 매개변수를 사용할 수 없다.\r\n\r\n\u003e 즉, 동적으로 import하는 것은 성능 향상과 필요한 경우에 맞춰 사용하는 것에 용이하다.\r\n\r\n## 사용법\r\n\r\n필요한 함수들을 정의하고, 필요한 곳에서 import하여 원하는 방식대로 적용해준다.\r\n\r\n예시 코드\r\n\r\n```javascript\r\n// someFn.js\r\n\r\nexport const greeting = () =\u003e {\r\n  console.log(\"어서오시고\");\r\n};\r\n\r\nexport const importMe = () =\u003e {\r\n  console.log(\"다이나믹 임포트를 해주세요\");\r\n};\r\n\r\nexport const easy = () =\u003e {\r\n  console.log(\"쉽죠?\");\r\n};\r\n\r\nexport const add = (a, b) =\u003e console.log(a + b);\r\n```\r\n\r\n```javascript\r\n// use import()\r\nexport const DynamicImport = () =\u003e {\r\n  // async / await 방식\r\n  const loadGreeting = async () =\u003e {\r\n    const DI = await import(\"./someFn.js\");\r\n    DI.greeting();\r\n  };\r\n  const loadImportMe = async () =\u003e {\r\n    const DI = await import(\"./someFn.js\");\r\n\r\n    DI.importMe();\r\n  };\r\n  const loadEasy = async () =\u003e {\r\n    const DI = await import(\"./someFn.js\");\r\n    DI.easy();\r\n  };\r\n\r\n  const loadAddAwait = async (a, b) =\u003e {\r\n    const DI = await import(\"./someFn.js\");\r\n    return DI.add(a, b);\r\n  };\r\n  // 기본 방식\r\n  const loadAdd = (a, b) =\u003e {\r\n    const DI = import(\"./someFn.js\")\r\n      .then(module =\u003e {\r\n        module.add(a, b);\r\n      })\r\n      .catch(err =\u003e err);\r\n    return DI;\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eDynamicImport component\u003c/p\u003e\r\n      \u003cbutton onClick={loadGreeting}\u003eloadGreeting\u003c/button\u003e\r\n      \u003cbutton onClick={loadImportMe}\u003eloadImportMe\u003c/button\u003e\r\n      \u003cbutton onClick={loadEasy}\u003eloadEasy\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e loadAdd(1, 2)}\u003eloadAdd\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e loadAddAwait(5, 5)}\u003eloadAddAwait\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n## Promise를 반환하기 때문에 async/await을 통한 사용도 가능하다.\r\n\r\n위 코드를 통해 생성한 버튼들을 모두 한 번씩 클릭해주면 아래와 같이 사용되는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FyOVoT%2Fbtr4v801voG%2FmX38iUM5zpLCGKZ5nkyWYK%2Fimg.png)\r\n\r\n\u003e 참고사항 : Dynamic import는 일반 스크립트에서도 동작하기 때문에 script type=\"module\"이 없어도 된다.\r\n\r\n### 주의사항 : import()는 함수 호출과 문법이 유사해 보이지만 함수 호출이 아니다. super()처럼 괄호를 사용하는 특별한 문법 중 하나이다. 따라서 import를 변수에 복사하거나 call/apply 등의 사용은 불가능하다.\r\n\r\n---\r\n\r\n참조\r\n\r\nMDN : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import\r\n\r\nModern js : https://ko.javascript.info/modules-dynamic-imports\r\n"},{"title":"javascript jest test code","description":"jest를 통한 테스트코드 사용","category":"javascript","keyword":"javascript, 테스트코드","date":"2023-03-18","content":"\r\n# jest란?\r\n\r\n\u003e 단순성에 중점을 둔 javascript 테스트 프레임워크로, babel, Typescript, node, React, Angular, Vue 등을 사용하는 프로젝트에서 작동한다.\r\n\r\n본 포스팅은 React 환경을 기준으로 작성되었다.\r\n\r\n## 1. jest 설치\r\n\r\n```bash\r\nnpm install --save-dev jest @babel/preset-env\r\n# or\r\nyarn add --dev jest @babel/preset-env\r\n```\r\n\r\nnode.js 환경에서 import 등의 ES6 문법을 사용하기 위해 @babel/preset-env도 함께 설치해준다.\r\n\r\n## 2. 루트 경로에 babel.config.js 파일 생성\r\n\r\n```javascript\r\nmodule.exports = {\r\n  presets: [\r\n    \"@babel/preset-env\",\r\n    // typescript를 사용하는 경우 yarn add --dev @babel/preset-typescript 설치 후\r\n    // 아래와 같이 preset을 추가해준다.\r\n    // \"@babel/preset-typescript\"\r\n  ],\r\n};\r\n```\r\n\r\nbabel config 파일까지 생성이 완료됐다면 test 파일을 사용할 준비가 다 된 것이다.\r\n\r\n## 3. jest가 인식하는 test file 이름\r\n\r\n- {filename}.test.js\r\n- {filename}.spec.js\r\n\r\n## 4. 테스트 실행\r\n\r\njest 커맨드만으로도 테스트 코드를 진행할 수 있지만, 다른 플래그와 함께 사용할 수 있다.\r\n\r\n```bash\r\n--coverage # 프로젝트의 테스트 커버리지를 함께 나타내준다.\r\n--watch # 대상 코드나 테스트 코드에 변경이 생기면 테스트를 다시 실행한다.\r\n\r\n# ex) yarn jest --watch --coverage\r\n```\r\n\r\njest만 실행한 터미널\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbmEHBz%2Fbtr4t9fB6IJ%2Fl1JqzgbkjoBxDREUdoSgzK%2Fimg.png)\r\n\r\n--coverage와 함께 실행한 터미널\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPTj6f%2Fbtr4vjvmeEt%2Ft5NIYNk6kzRJ4PQ1IQA48k%2Fimg.png)\r\n\r\n\u003e 참고 : jest는 테스트 코드 내에서 오류가 발생할 때만 테스트를 fail시키기 때문에 test(\"\",()=\u003e{})와 같이 테스트 코드가 비어있더라도 테스트를 통과할 수 있다.\r\n\r\n## 5. 테스트 코드 패턴\r\n\r\n### AAA 패턴 (Arrange - Act - Assert)\r\n\r\n- A 조건에서 B를 실행했을때 예상한 결과가 C가 나오는가? 라는 흐름의 패턴이다.\r\n\r\n예제\r\n\r\n```javascript\r\n// 기존 함수\r\nexport const add = (a, b) =\u003e {\r\n  return a + b;\r\n};\r\n\r\n// somefn.spec.js - 테스트코드 함수\r\n\r\nimport { add } from \"./someFn\";\r\n\r\ntest(\"add 함수 테스트: result = a+b\", () =\u003e {\r\n  // 조건\r\n  const a = 2;\r\n  const b = 3;\r\n  const result = 5;\r\n\r\n  // 실행\r\n  const actResult = add(a, b);\r\n\r\n  // 평가\r\n  expect(actResult).toBe(result);\r\n});\r\n```\r\n\r\n평가 부분의 코드는 .toBe()라는 matcher 함수를 통해 actResult를 실행했을 때 result가 나올 것이라는 기대를 갖고 코드를 평가하게 된다.\r\n\r\n아래와 같이 여러 함수를 한 테스트 코드 안에 넣을 수도 있지만, 리팩토링 시 불편한 경험을 할 수 있기 때문에 상황에 맞게 사용해주는 것이 좋을 것 같다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FckHjWD%2Fbtr4t5Eptqn%2FccX4fWxWW6GZ9edDMtjdAK%2Fimg.png)\r\n\r\n주요 matcher 함수\r\n\r\n- toBe() : 원시형 데이터 비교\r\n- toEqual() : 참조형 데이터를 깊은 비교를 통해 비교\r\n- toBeTruthy() : 값이 참인지 검사\r\n- toContain() : 특정 요소가 배열 안에 존재하는지 검사\r\n- not : 다른 matcher 함수 앞에 체이닝해 사용하며, 해당 값의 반대값이 참인지 검사 (not은 함수가 아닌 property)\r\n\r\n공식 문서에서 더 자세하게 확인해볼 수 있다. (https://jestjs.io/docs/using-matchers)\r\n\r\n## 6. 테스트 코드를 통해 할 수 있는 것\r\n\r\n- 내가 작성한 함수들이 내가 원하는대로 작동하는지 확인할 수 있다.\r\n- 테스트 코드 작성을 통해 TDD 방식의 개발 방법론을 적용할 수 있다.\r\n\r\n## TDD란?\r\n\r\n\u003e TDD는 테스트 주도 개발(Test Driven Development)을 뜻하며, 테스트 케이스를 우선적으로 설계해 개발을 진행하는 방법론이다.\r\n\r\n### 1. 테스트 케이스를 우선적으로 설계하고,\r\n\r\n### 2. 함수를 테스트 케이스에 맞춰 제작하며,\r\n\r\n### 3. 로직을 개선하며 1~3을 반복한다.\r\n\r\n즉, 실패-성공-리팩토링의 반복으로 볼 수 있다.\r\n\r\nTDD의 예시\r\n\r\nhttps://velog.io/@velopert/TDD%EC%9D%98-%EC%86%8C%EA%B0%9C\r\n\r\n---\r\n\r\n참조 : https://jestjs.io/\r\n"},{"title":"nextjs link userouter","description":"Nextjs Link와 useRouter의 차이","category":"nextjs","keyword":"nextjs, Link, useRouter","date":"2023-03-18","content":"\r\n# Link / useRouter 사용법\r\n\r\n```javascript\r\n// Link\r\nimport Link from \"next/link\";\r\n\r\nexport const compo1 = () =\u003e {\r\n  return (\r\n    \u003cLink href=\"url\"\u003e\r\n      \u003cdiv\u003esome element\u003c/div\u003e\r\n    \u003c/Link\u003e\r\n  );\r\n};\r\n\r\n// useRouter\r\nimport { useRouter } from \"next/router\";\r\n\r\nexport const compo2 = () =\u003e {\r\n  const router = useRouter();\r\n\r\n  const routeHandler = () =\u003e {\r\n    router.push(url);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv onClick={routeHandler}\u003e\r\n      \u003cspan\u003esome element\u003c/span\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n### Nextjs에서 페이지를 전환하기 위해 사용하는 방법으로, Link를 이용하거나 useRouter를 이용해 router.push()와 같이 사용하여 전환해줄 수 있는데, 비슷해 보이는 두 가지 방법의 차이를 간단히 정리해본다.\r\n\r\n## Link의 특징\r\n\r\n- Link는 Client-side navigation으로, javascript로 페이지 전환이 이뤄진다.\r\n- 기본 navigation보다 빠르며 SPA(Single Page Application)의 특성을 유지한다.\r\n\r\n## useRouter의 특징\r\n\r\n- react-router-dom의 history.push()와 유사하다.\r\n- 크롤러가 링크를 감지하지 못해 SEO가 좋지 않을 수 있다.\r\n- 외부 URL을 사용할 경우 window.location 혹은 a 태그를 사용해야 한다.\r\n\r\n또한 Link는 클릭 시 바로 페이지가 전환되지만, useRouter는 로직을 처리한 후 원하는 시점에 전환이 가능하다.\r\n\r\n## 결론\r\n\r\n\u003e router.push()는 onClick에 사용되는 행동(action)이기 때문에 Link 태그보다 검색에 불리하지만, 로직의 처리에 따라 활용도가 높다.\r\n\r\n\u003e Nextjs의 장점인 SEO(Search Engine Optimization - 검색 엔진 최적화)를 원한다면 Link를 사용하는 것이 더 유리하다.\r\n\r\n---\r\n\r\n참조\r\n\r\nhttps://stackoverflow.com/questions/65086108/next-js-link-vs-router-push-vs-a-tag\r\n\r\nhttps://nextjs.org/docs/api-reference/next/link\r\n\r\nhttps://nextjs.org/docs/api-reference/next/router\r\n"},{"title":"nextjs marked webpack imported module 7 default","description":"WEBPACK_IMPORTED_MODULE_7_default is not a function 에러 해결","category":"nextjs","keyword":"WEBPACK_IMPORTED_MODULE_7_default is not a function ERROR","date":"2023-03-18","content":"\r\n# 에러 해결 방법\r\n\r\n나의 경우 SSR 데이터를 contextAPI를 통해 패치하려 했으나, 정상적으로 받아오지 못할때 발생한 오류였다.\r\n\r\n로컬 실행 종료 후 재실행하니 정상적으로 데이터를 받아올 수 있었다.\r\n\r\n다소 허탈한 해결방안이었지만, SSR을 다루는 페이지의 데이터가 정상적으로 받아와지지 않는 경우, 코드 작성 후 프로그램을 다시 실행해보자.\r\n\r\n---\r\n\r\n참조 : https://github.com/vercel/next.js/issues/18090\r\n"},{"title":"react memo","description":"React.memo() 를 통한 컴포넌트 최적화","category":"react","keyword":"react, memo()","date":"2023-03-16","content":"\r\n\u003e 유저에게 UI를 빠르게 제공하기 위해서는 컴포넌트의 렌더링을 최소화해 성능을 향상시킬 필요가 있다. 이를 위해 React.memo()에 대한 간단한 사용법을 기록해본다.\r\n\r\n# 1. React.memo()\r\n\r\n컴포넌트가 React.memo()로 래핑될 때, React는 컴포넌트를 렌더링하고 결과를 Memoizing한다.\r\n\r\n그리고 다음 렌더링이 일어날 때 props가 값다면, React는 Memoizing된 내용을 재사용한다.\r\n\r\n## 사용법\r\n\r\n```javascript\r\nimport React from \"react\";\r\n\r\nexport const MemoTest = ({ someProps }) =\u003e {\r\n  console.log(\"Memo test, props 바뀔때만 콘솔 작동\");\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cp\u003eMemoTest 컴포넌트\u003c/p\u003e\r\n      \u003cp\u003eprops가 바뀔때만 렌더링\u003c/p\u003e\r\n      \u003cspan\u003ecount와 연동된 props: {someProps}\u003c/span\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 다른 컴포넌트에서 불러올 때, 해당 컴포넌트를 import 해주면 된다.\r\nexport const MemoTestComponent = React.memo(MemoTest);\r\n```\r\n\r\n## 사용 예시\r\n\r\n```javascript\r\nexport const TestApp = () =\u003e {\r\n  const values = useContextValue();\r\n  const update = useContextUpdate();\r\n  const [count, setCount] = useState(0);\r\n  console.log(\"최상위 컴포넌트 : 렌더링 될때마다 콘솔 작동\");\r\n\r\n  const contextHandler = () =\u003e {\r\n    values === \"someData\" ? update(\"dataSome\") : update(\"someData\");\r\n  };\r\n\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cNormalComponent /\u003e\r\n      \u003cMemoTestComponent someProps={count} /\u003e\r\n      \u003cbutton\r\n        onClick={() =\u003e {\r\n          setCount(pre =\u003e pre + 1);\r\n        }}\r\n      \u003e\r\n        +count버튼\r\n      \u003c/button\u003e\r\n      \u003cbutton\r\n        onClick={() =\u003e {\r\n          setCount(pre =\u003e pre - 1);\r\n        }}\r\n      \u003e\r\n        -count버튼\r\n      \u003c/button\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003econtext value\u003c/p\u003e\r\n        \u003cspan\u003evalue : {values}\u003c/span\u003e\r\n        \u003cbutton onClick={contextHandler}\u003econtext 변경 버튼\u003c/button\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVQkSV%2Fbtr37vCBXzm%2FVXiqfYdD4H2FTcw3tGVFzk%2Fimg.png)\r\n\r\n위 이미지는 TestApp 코드의 초기 화면이다.\r\n\r\n모든 컴포넌트가 첫 렌더링을 거쳐 각각 콘솔을 찍어내고 있다.\r\n\r\n### TestApp의 count state는 MemoTest 컴포넌트에 props로 전달해주고 있기 때문에 React.memo()의 효과는 사용되지 않고, 일반 컴포넌트와 마찬가지로 TestApp count state가 변경될 때마다 렌더링되는 것을 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/Hl6oT/btr4gSJ05tT/kipvw3VkehYfnxf2Pbq780/img.gif)\r\n\r\n### 하지만 contextAPI처럼 MemoTest의 props와 연관되지 않은 다른 방식을 통해 통해 리렌더링을 발생시키는 경우라면, memoTest 컴포넌트의 props가 변경되지 않기 때문에 MemoTest는 렌더링을 발생시키지 않는다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/cmaheq/btr36GRW8J1/uhzNP5d6ymqDxVDGFK4Ay1/img.gif)\r\n\r\n\u003e contextAPI의 기본 사용법 : https://lee-yo-han.github.io/react/react-context-api\r\n\r\n---\r\n\r\n## 1-1 - props 동등 비교 커스터마이징\r\n\r\nReact.memo()는 props 혹은 props의 객체를 비교할 때 얕은 비교를 하기 때문에, 비교 방식을 수정하고 싶다면 React.memo() 두 번째 매개변수로 비교함수를 만들어 수동으로 연산 후 넘겨주면 된다.\r\n\r\n```javascript\r\nimport React from \"react\";\r\n\r\nexport const MemoTest = ({ someProps }) =\u003e {\r\n  console.log(\"Memo test, props 바뀔때만 콘솔 작동\");\r\n  return (\r\n    \u003cdiv style={{ border: \"1px solid black\" }}\u003e\r\n      \u003cp\u003eMemoTest 컴포넌트\u003c/p\u003e\r\n      \u003cp\u003eprops가 바뀔때만 렌더링\u003c/p\u003e\r\n      \u003cspan\u003ecount와 연동된 props: {someProps}\u003c/span\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\nconst propsAreEqual = (prev, next) =\u003e {\r\n  return (\r\n    prev.someProps === next.someProps\r\n    // 다른 props들이 있는 경우 \u0026\u0026을 통해 연산 추가\r\n  );\r\n};\r\n\r\nexport const MemoTestComponent = React.memo(MemoTest, propsAreEqual);\r\n```\r\n\r\n# 2. React.memo()는 언제 사용해야 하는가?\r\n\r\n### - 함수형 컴포넌트가 같은 props로 자주 렌더링 될거라 예상될 경우\r\n\r\nprops가 변경되지 않는 경우에도 상위 컴포넌트의 지속적인 렌더링에 의해 하위 컴포넌트의 불필요한 렌더링이 예상되는 경우라면 React.memo()를 통해 오직 props의 변화에만 반응시켜주는 것이 효율적이다.\r\n\r\n### - 무겁고 비용이 큰 연산이 있는 경우\r\n\r\n한 번 렌더링 될 때 큰 연산이 발생한다고 했을때 불필요한 렌더링이 일어난 경우 연산에 사용되는 비용이 낭비될 수 있기 때문에 이러한 경우 또한 React.memo()를 통한 memoization이 적절하다고 볼 수 있다.\r\n\r\n# 3. React.memo()를 언제 사용하지 말아야 하는가?\r\n\r\n### - 위에 언급한 상황과 맞지 않는 경우 React.memo()를 사용할 필요가 없을 가능성이 높다.\r\n\r\n경험적으로 ㅅ어능적인 이점을 얻지 못한다면 memoization을 사용하지 않는 것이 좋다. 성능 관련 변경이 잘못 적용된다면 성능이 오히려 악화될 수 있다.\r\n\r\n### - 기술적으로는 가능하지만 클래스 기반의 컴포넌트를 React.memo()로 래핑하는 것은 적절하지 않다.\r\n\r\n클래스 기반의 컴포넌트에서 memoization이 필요하다면, pureComponent를 확장하여 사용하거나, shouldComponentUpdate() 메서드를 구현하는 것이 적절하다.\r\n\r\n### - props가 자주 바뀌는 경우\r\n\r\nprops가 자주 바뀌는 경우도 React.memo()로 래핑하더라도 이전 props와 다음 props를 비교 함수를 통해 비교할때 거의 false를 반환할 것이기 때문에 props가 자주 바뀌는 경우도 React.memo()의 사용이 적절하지 않다.\r\n\r\n## 결론\r\n\r\n\u003e React.memo는 memoization의 장점을 얻게 해주는 좋은 도구이지만, 렌더링 방지를 위해 memoization에만 의존하면 안된다.\r\n\r\n---\r\n\r\n## 참조\r\n\r\nhttps://dmitripavlutin.com/use-react-memo-wisely/\r\n\r\nhttps://ui.toast.com/weekly-pick/ko_20190731\r\n"},{"title":"react usecallback","description":"useCallback을 이용한 컴포넌트 최적화하기","category":"react","keyword":"useCallback, 컴포넌트, 최적화","date":"2023-03-16","content":"\r\n# useCallback이란?\r\n\r\n\u003e 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용하는 함수 메모이제이션용 React hook이다.\r\n\r\n```javascript\r\nconst memoFn = useCallback(() =\u003e {}, [dep]);\r\n```\r\n\r\n첫번째 인자의 함수를 두번째 인자의 종속성 배열 내의 값이 변경될 때까지 저장하여 재사용할 수 있도록 해준다.\r\n\r\njavascript에서 함수(function () {} or () =\u003e {})는 객체 리터럴( {...} )이 항상 새 객체를 생성하는 것과 유사하게 항상 다른 함수를 생성한다. 그렇다면 함수를 props 로 내려준다고 하면 하위 컴포넌트는 props가 변경되었다고 인식하게 된다.\r\n\r\n그렇게되면 React.memo를 이용한 최적화가 원하는대로 작동하지 않을 수 있기 때문에 이러한 점을 useCallback이 메꿔줄 수 있게 된다.\r\n\r\n\u003e 종속성 배열이 없는 경우 매번 새 함수를 반환하기 때문에 항상 dependencises 배열을 포함해줘야 한다. (특정 상황에서 빈 배열 [] 은 있을 수 있지만, 배열 자체가 없으면 의미가 없어진다.)\r\n\r\n## 사용예\r\n\r\n```javascript\r\nconst add = useCallback(() =\u003e x + y, [x, y]);\r\n```\r\n\r\n# useCallback과 React.memo를 통한 최적화\r\n\r\n```javascript\r\n// 최상단 (1번) 컴포넌트\r\nimport { useState } from \"react\";\r\nimport { UseCallbackChildren } from \"./UseCallbackChildren\";\r\n\r\nexport const UseCallbackTest = () =\u003e {\r\n  const [isDark, setIsDark] = useState(false);\r\n  return (\r\n    \u003c\u003e\r\n      \u003clabel\u003e\r\n        \u003cinput\r\n          type=\"checkbox\"\r\n          checked={isDark}\r\n          onChange={e =\u003e setIsDark(e.target.checked)}\r\n        /\u003e\r\n        Dark mode\r\n      \u003c/label\u003e\r\n      \u003chr /\u003e\r\n      \u003cUseCallbackChildren\r\n        productId={123}\r\n        referrer=\"wizard_of_oz\"\r\n        theme={isDark ? \"dark\" : \"light\"}\r\n      /\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n\r\n// 중간 (2번) 컴포넌트\r\nimport React, { useCallback } from \"react\";\r\nimport { CallbackForm } from \"./UseCallbackForn\";\r\n\r\nexport const UseCallbackChildren = ({ referrer, productId, theme }) =\u003e {\r\n  const post = (url, data) =\u003e {\r\n    console.log(\"POST /\" + url);\r\n    console.log(data);\r\n  };\r\n\r\n  const handleSubmit = useCallback(\r\n    orderDetails =\u003e {\r\n      post(\"/product/\" + productId + \"/buy\", {\r\n        referrer,\r\n        orderDetails,\r\n      });\r\n    },\r\n    [productId, referrer],\r\n  );\r\n\r\n  return (\r\n    \u003cdiv\r\n      style={\r\n        theme === \"dark\" ? { backgroundColor: \"black\", color: \"white\" } : {}\r\n      }\r\n    \u003e\r\n      \u003cCallbackForm onSubmit={handleSubmit} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 하위 (3번) 컴포넌트\r\nimport React, { useState } from \"react\";\r\n\r\nexport const UseCallbackForm = ({ onSubmit }) =\u003e {\r\n  const [count, setCount] = useState(1);\r\n\r\n  console.log(\"강제로 느리게\");\r\n  let startTime = performance.now();\r\n  while (performance.now() - startTime \u003c 500) {\r\n    // Do nothing for 500 ms to emulate extremely slow code\r\n  }\r\n\r\n  const handleSubmit = e =\u003e {\r\n    e.preventDefault();\r\n    const formData = new FormData(e.target);\r\n    const orderDetails = {\r\n      ...Object.fromEntries(formData),\r\n      count,\r\n    };\r\n    onSubmit(orderDetails);\r\n  };\r\n\r\n  return (\r\n    \u003cform\r\n      onSubmit={handleSubmit}\r\n      style={{ display: \"flex\", flexDirection: \"column\", width: \"200px\" }}\r\n    \u003e\r\n      \u003cp\u003e\r\n        \u003cb\u003e\r\n          Note: \u003ccode\u003eShippingForm\u003c/code\u003e is artificially slowed down!\r\n        \u003c/b\u003e\r\n      \u003c/p\u003e\r\n      \u003clabel\u003e\r\n        Number of items:\r\n        \u003cbutton type=\"button\" onClick={() =\u003e setCount(count - 1)}\u003e\r\n          -\r\n        \u003c/button\u003e\r\n        {count}\r\n        \u003cbutton type=\"button\" onClick={() =\u003e setCount(count + 1)}\u003e\r\n          +\r\n        \u003c/button\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        Street:\r\n        \u003cinput name=\"street\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        City:\r\n        \u003cinput name=\"city\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003clabel\u003e\r\n        Postal code:\r\n        \u003cinput name=\"zipCode\" /\u003e\r\n      \u003c/label\u003e\r\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n};\r\n\r\nexport const CallbackForm = React.memo(UseCallbackForm);\r\n```\r\n\r\n위 코드를 보면, 최상단(1)에 있는 다크모드는 중간(2) 컴포넌트까지만 전달해주고, 중간(2) 컴포넌트는 하위(3) 컴포넌트에 useCallback 함수만 전달해주고 있다.\r\n\r\nuseCallback은 함수를 캐시해 재사용할 수 있도록 도와주기 때문에 종속성이 변하지 않으면 계속 재사용할 수 있다. 즉, 동일한 props로써 함수를 하위(3) 컴포넌트에 내려주고 있기 때문에 하위 컴포넌트의 렌더링에 영향이 없다.\r\n\r\n이 상태로 코드를 작동시키면 하위(3) 컴포넌트에 있는 count를 동작할때마다 느려지겠지만, 다크모드와 submit 이벤트에는 영향을 주지 않는다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/bEYsKw/btr4gSLc8BG/hJKpnBKbFziku3fjI6hphK/img.gif)\r\n\r\n만약 하위(3) 컴포넌트의 React.memo()를 없애게 되면 submit 이벤트에는 영향이 없지만, 최상위(1) 컴포넌트의 다크모드 state 변경에 의해 하위(3) 컴포넌트의 렌더링이 일어나게 되어 다크모드와 count의 동작이 느려지는걸 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/mfxA0/btr4iTijPZD/XNzKmFrScoUZ6qSyiCMV2K/img.gif)\r\n\r\n자세히 보면 콘솔이 먼저 찍히고 0.5초정도 뒤에 동작하는 것을 볼 수 있다.\r\n\r\n# useMemo와의 차이점\r\n\r\n\u003e useMemo는 함수의 호출 결과를 캐시하고, useCallback은 함수 자체는 캐시한다. 그러므로 useCallback은 useMemo와 달리 제공한 함수를 호출하지 않는다. 대신 사용자가 제공한 함수를 캐시하기 때문에 불필요한 렌더링 없이 함수를 전달할 수 있다.\r\n\r\n## useMemo와 useCallback의 동시 사용\r\n\r\n```javascript\r\nfunction useCallback(fn, dependencies) {\r\n  return useMemo(() =\u003e fn, dependencies);\r\n}\r\n```\r\n\r\n## useCallback이 유용한 경우\r\n\r\n- useCallback을 통해 props로 하위 컴포넌트에 넘겨줄때\r\n- useEffect 등 다른 hook의 종속성으로 이용할때\r\n- 종속성 변화가 적고 재사용이 용이할때\r\n\r\n## useCallback 남용 시 문제점\r\n\r\n\u003e 모든 함수를 useCallback으로 감싸게 되면 컴포넌트가 리렌더 될 때마다 모든 함수가 다시 재생성될 필요가 있는지 검사하는 연산이 수행된다. 따라서 보통은 특정 함수가 props로 전달되어 불필요한 컴포넌트 리렌더를 유발할 때에만 적용하는 것이 좋다.\r\n\r\n### memo, useMemo, useCallback 등 어떤 Memoization이나 부적절하게 사용할 경우 오히려 성능이 떨어질 수 있기 때문에 상황에 맞게 적절하게 사용하는 것이 좋은 것 같다.\r\n\r\n---\r\n\r\n참조: https://beta.reactjs.org/reference/react/useCallback\r\n"},{"title":"react usememo","description":"useMemo를 이용한 컴포넌트 최적화하기","category":"react","keyword":"useMemo, 컴포넌트, 최적화","date":"2023-03-16","content":"\r\n# useMemo란?\r\n\r\n\u003e useMemo는 React.memo(), useCallback과 같이 컴포넌트를 최적화하기 위한 훅 중 하나이다.\r\n\r\n# useMemo를 사용하는 이유\r\n\r\nReact의 컴포넌트는 부모 컴포넌트가 렌더링되거나, 자신의 state변경, 상위 컴포넌트에서 내려받는 props가 변경될 때마다 다시 렌더링된다. 그런데 내려받는 props나 state가 여러 가지일때 한 개 props의 변경으로 모든 값이 다시 계산되는 경우 불필요한 비용이 누적되게 된다.\r\n\r\nuseMemo는 이러한 현상을 효율적으로 전환하기 위한 hook이다.\r\n\r\n## useMemo를 적용하기 전\r\n\r\n```javascript\r\n// 상위 컴포넌트\r\nimport { useState } from \"react\";\r\nimport { UseMemoChildren } from \"./UseMemoChildren\";\r\n\r\nexport const UseMemoTest = () =\u003e {\r\n  const [number, setNumber] = useState(0);\r\n  const [text, setText] = useState(\"\");\r\n\r\n  const changeNumber = e =\u003e {\r\n    setNumber(e.target.value);\r\n  };\r\n  const changeText = e =\u003e {\r\n    setText(e.target.value);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eUseMemoText\u003c/p\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003enumber\u003c/p\u003e\r\n        \u003cinput type=\"number\" onChange={changeNumber} value={number} /\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003etext\u003c/p\u003e\r\n        \u003cinput type=\"text\" onChange={changeText} value={text} /\u003e\r\n      \u003c/div\u003e\r\n      \u003cUseMemoChildren number={number} text={text} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\n// 하위 컴포넌트\r\nexport const UseMemoChildren = ({ number, text }) =\u003e {\r\n  const getNumber = number =\u003e {\r\n    console.log(\"숫자 변경\");\r\n    return number;\r\n  };\r\n\r\n  const getText = text =\u003e {\r\n    console.log(\"글자 변경\");\r\n    return text;\r\n  };\r\n\r\n  const showNumber = getNumber(number);\r\n\r\n  const showText = getText(text);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eMemo Child Component\u003c/p\u003e\r\n      \u003cp\u003enumber: {showNumber}\u003c/p\u003e\r\n      \u003cp\u003etext: {showText}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n상위 컴포넌트는 각 input 값이 변경될 때마다 그 값을 저장해 하위 컴포넌트로 내려준다.\r\n\r\n하위 컴포넌트는 내려받은 props를 통해 화면에 노출시켜줄 값을 return해주는 역할을 한다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/9hqzj/btr4hQeyTmU/PzYhcCiwuZq08zOkhBqeWk/img.gif)\r\n\r\n이 상태에서 input을 업데이트하면 숫자를 바꾸든 텍스트를 바꾸든 getNumber 함수와 getText 함수 둘 다 다시 연산되는 것을 볼 수 있다.\r\n\r\n이런 경우 변경된 props에 대해서만 다시 연산될 수 있도록 useMemo를 적용해볼 수 있다.\r\n\r\n## useMemo 사용법\r\n\r\n```javascript\r\nconst cachedValue = useMemo(calculateValue, dependencies);\r\n```\r\n\r\n### 적용 예시\r\n\r\n```javascript\r\n// 하위 컴포넌트\r\n\r\nimport { useMemo } from \"react\";\r\n\r\nexport const UseMemoChildren = ({ number, text }) =\u003e {\r\n  //   console.log(\"useMemoChildren start\");\r\n  const getNumber = number =\u003e {\r\n    console.log(\"숫자 변경\");\r\n    return number;\r\n  };\r\n\r\n  const getText = text =\u003e {\r\n    console.log(\"글자 변경\");\r\n    return text;\r\n  };\r\n\r\n  const showNumber = useMemo(() =\u003e {\r\n    return getNumber(number);\r\n  }, [number]);\r\n\r\n  const showText = useMemo(() =\u003e {\r\n    return getText(text);\r\n  }, [text]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eMemo Child Component\u003c/p\u003e\r\n      \u003cp\u003enumber: {showNumber}\u003c/p\u003e\r\n      \u003cp\u003etext: {showText}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 useMemo를 적용하고 나면 다음과 같이 useMemo 적용 이후 변경된 props에 대한 연산만 처리해주는 것을 볼 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/4Vcyh/btr4hPz1xwm/0zNRNCdyJKwpsWk2LU73KK/img.gif)\r\n\r\n\u003e useMemo 마지막의 dependencies [ ] 배열은 필수적으로 어떤 값을 변경에 반응할 것인지 포함시켜줘야 한다.\r\n\r\n# 연산 비용이 비싸다는 기준은?\r\n\r\nReact 공식 사이트에서 권장하는 useMemo 적용 기준은 연산에 소요된 시간이 1ms 이상일 경우로 안내하고 있다.\r\n\r\nconsole.time/timeEnd 등을 통해 useMemo를 적용하고자 하는 함수의 총 연산시간을 도출해볼 수 있다.\r\n\r\n```javascript\r\nconst getText = text =\u003e {\r\n  console.time(\"memo\");\r\n  console.log(\"글자 변경\");\r\n  console.timeEnd(\"memo\");\r\n  return text;\r\n};\r\n```\r\n\r\n위와 같이 코드 작성 후 text를 변경해보면 다음과 같은 콘솔을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8mGtS%2Fbtr4iU19jHE%2FH0huW2SytbAtalR3urepr0%2Fimg.png)\r\n\r\n\u003e 입력하는 계산이 눈에 띄게 느리고, 종속성이 거의 변경되지 않는 경우에는 useMemo를 이용한 최적화가 적합하지만, 컴포넌트 구조 변경과 상태 관리의 최소화, state를 업데이트하는 Effect의 불필요한 종속성을 제거하거나 특정 함수들을 별도로 관리하는 방법이 useMemo보다 적합할 수 있다.\r\n\r\n\u003e 실제로 React의 성능 문제 대부분은 Effect에서 발생하는 업데이트 체인으로 인해 발생한다고 한다.\r\n\r\n---\r\n\r\n참조 : https://beta.reactjs.org/reference/react/useMemo\r\n"},{"title":"react context api","description":"ContextAPI 사용하기","category":"react","keyword":"react, contextAPI","date":"2023-03-15","content":"\r\n# ContextAPI\r\n\r\n\u003e 간단한 데이터의 변화를 props drilling 없이 전역적으로 관리해주기 위해 ContextAPI를 사용해볼 수 있다.\r\n\r\n## 사용법\r\n\r\n## 1. context component 생성\r\n\r\n```javascript\r\n// context.jsx\r\nimport { createContext, useContext, useState } from \"react\";\r\n\r\n// context 생성\r\nconst AnyContextValue = createContext();\r\nconst AnyContextUpdate = createContext();\r\n\r\n// useContext 생성\r\nexport const useContextValue = () =\u003e {\r\n  const context = useContext(AnyContextValue);\r\n  return context;\r\n};\r\nexport const useContextUpdate = () =\u003e {\r\n  const update = useContext(AnyContextUpdate);\r\n  return update;\r\n};\r\n\r\n// context Component 생성\r\n// children props를 Contextname.provider로 감싸준다.\r\nexport const SomeContext = ({ children }) =\u003e {\r\n  const [someData, setSomeData] = useState(\"someData\");\r\n  return (\r\n    \u003cAnyContextValue.Provider value={someData}\u003e\r\n      \u003cAnyContextUpdate.Provider value={setSomeData}\u003e\r\n        {children}\r\n      \u003c/AnyContextUpdate.Provider\u003e\r\n    \u003c/AnyContextValue.Provider\u003e\r\n  );\r\n};\r\n```\r\n\r\n## 2. context import\r\n\r\n```javascript\r\nimport { TestApp } from \"./components/blogtest/TestApp\";\r\nimport { SomeContext } from \"./components/context/RenderingContext\";\r\n\r\n// import된 Context를 적용하고자 하는 컴포넌트들의 최상위에 감싸준다.\r\nfunction App() {\r\n  return (\r\n    \u003cSomeContext\u003e\r\n      \u003cChildrenComponent /\u003e\r\n    \u003c/SomeContext\u003e\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n\r\n## 3. context 사용\r\n\r\n```javascript\r\nimport { useState } from \"react\";\r\n// 생성한 useContext import\r\nimport { useContextUpdate, useContextValue } from \"../context/RenderingContext\";\r\n\r\nexport const ChildrenComponent = () =\u003e {\r\n  const values = useContextValue();\r\n  const update = useContextUpdate();\r\n\r\n  const contextHandler = () =\u003e {\r\n    values === \"someData\" ? update(\"dataSome\") : update(\"someData\");\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003econtext value\u003c/p\u003e\r\n      \u003cspan\u003evalue : {values}\u003c/span\u003e\r\n      \u003cbutton onClick={contextHandler}\u003econtext 변경 버튼\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 설정이 완료된 후 정상적으로 contextAPI를 사용할 수 있다.\r\n\r\n![image](https://blog.kakaocdn.net/dn/d0hnZa/btr35w9FvGX/zDcTOjtXxg23vMKk6LxaM0/img.gif)\r\n\r\n\u003e contextAPI는 간단하게 상태를 관리해줄 수 있지만, provider를 전역으로 감쌌을 때 컴포넌트들이 전반적으로 렌더링이 일어날 수 있기 때문에 상황과 구조에 맞게 적절하게 사용해주는 것이 좋다.\r\n\r\n---\r\n\r\n## 참고 : typescript에서의 contextAPI 사용\r\n\r\n### TypeScript에서는 context 초기값 등의 설정이 필요하다.\r\n\r\n```typescript\r\n// context component\r\n\r\nimport { createContext, useContext, useState } from \"react\";\r\nimport { PostType } from \"@/types/pages\";\r\nimport { ProviderProps, ContextType } from \".\";\r\n\r\n// context 초기화\r\nconst initialContext = {\r\n  posts: [],\r\n  setPosts: () =\u003e {},\r\n};\r\n\r\n// context 생성\r\nconst PostContextValue = createContext\u003cPostType[]\u003e(initialContext.posts);\r\nconst PostContextUpdate = createContext\u003cContextType\u003e(initialContext.setPosts);\r\n\r\n// useContext 생성\r\nexport const useMdContextValue = () =\u003e {\r\n  const context = useContext(PostContextValue);\r\n  return context;\r\n};\r\nexport const useMdContextUpdate = () =\u003e {\r\n  const update = useContext(PostContextUpdate);\r\n  return update;\r\n};\r\n\r\n// context component 생성\r\nexport const MdContext = ({ children }: ProviderProps) =\u003e {\r\n  const [posts, setPosts] = useState\u003cPostType[]\u003e([]);\r\n\r\n  return (\r\n    \u003cPostContextValue.Provider value={posts}\u003e\r\n      \u003cPostContextUpdate.Provider value={setPosts}\u003e\r\n        {children}\r\n      \u003c/PostContextUpdate.Provider\u003e\r\n    \u003c/PostContextValue.Provider\u003e\r\n  );\r\n};\r\n\r\n// 다른 컴포넌트에서의 사용\r\nimport { useEffect } from \"react\";\r\nimport { useMdContextUpdate } from \"@/context/mdContext\";\r\n\r\nexport default function Home({ posts }: { posts: PostType[] }) {\r\n  const update = useMdContextUpdate();\r\n\r\n  useEffect(() =\u003e {\r\n    if (posts) {\r\n      update(posts);\r\n    }\r\n  }, [posts, update]);\r\n```\r\n"},{"title":"github git blog utterances comment","description":"utterances를 이용한 Nextjs Github 블로그 댓글 기능 구현","category":"github","keyword":"github, utterances, 댓글","date":"2023-03-14","content":"\r\n# utterances란?\r\n\r\n\u003e Github repository의 이슈 기능을 활용해 내 웹사이트에 댓글 기능을 추가할 수 있는 도구로, 별도의 백엔드 구성을 하지 않고 댓글들을 관리할 수 있다는 장점이 있다.\r\n\r\n많이 비교되는 disqus라는 툴도 있다. 하지만, disqus는 댓글 작성을 누구나 할 수 있다는 장점이 있는 반면에 광고가 많다는 단점이 있다.\r\n그에 비해 utterances는 Github 계정 소유자만 댓글을 작성할 수 있지만, 별도의 광고도 없고 댓글 작성 시 Markdown을 지원한다는 특징이 있다.\r\n\r\n나는 utterances를 Github blog에 사용할 생각이기에 굳이 utterances의 장점을 버리고 disqus를 사용할 이유가 없었다.\r\n\r\n# 사용방법\r\n\r\n## 1. repository 생성\r\n\r\npublic으로 설정된 새 레포가 필요하다.\r\n\r\nGithub blog repo에 연동해도 상관은 없지만 댓글만을 위한 저장소를 만들어 놓는게 관리가 훨씬 쉬울 것 같아 새 repo를 생성해줬다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbq4F8z%2Fbtr34VuvScp%2FwmTQX2iIjKtMjlowowHw80%2Fimg.png)\r\n\r\n저장소 이름은 상관 없다.\r\n\r\n## 2. utterances 설치\r\n\r\nGithub app에서 설치할 수 있다.\r\n\r\nhttps://github.com/apps/utterances\r\n\r\n## 3. utterances access 설정\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPS87y%2Fbtr35bYlHCH%2FhE9akcKFM7qYE6yAfvKD4k%2Fimg.png)\r\n\r\napp이 설치되면 Configure를 통해 어떤 저장소에 연동해줄지 설정할 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F55bSC%2Fbtr37BBZd9Y%2FfSwpH2VCQKwXKpQkXAbO00%2Fimg.png)\r\n\r\n나는 선택한 저장소에만 연동되게 설정했다.\r\n\r\n## 4. utterances.json 생성\r\n\r\n```javascript\r\n{\r\n  \"origins\": [\"https://{my url}\"]\r\n}\r\n```\r\n\r\n위와 같이 자신이 댓글 기능을 사용할 사이트를 utterances.json에 입력해준다.\r\n\r\n## 5. script를 블로그 repo code에 복사\r\n\r\nhttps://utteranc.es/?installation_id=35005881\u0026setup_action=install\r\n\r\n해당 사이트에 들어가면 어떤 방식으로 script를 구성할지 설정할 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fo9X4N%2Fbtr34VVyI7q%2F2PbuKqgkmKDtfogCNj7Nx0%2Fimg.png)\r\n\r\n\u003e Issue mapping같은 경우, 댓글과 포스팅을 어떻게 연동할지 설정하는 것인데, 통상적으로 pathname이나 URL을 많이 사용하지만 본인 프로젝트의 상황에 맞춰 설정해주는 것이 가장 좋다.\r\n\r\n\u003e 또한 한글 파일명을 사용해 URL이나 pathname을 생성하는 경우, 유니코드 인식 문제로 비정상적인 URL이 생성될 수 있기 때문에 설정에 유의해야 한다.\r\n\r\n```javascript\r\n// 복사할 스크립트\r\n\u003cscript\r\n  src=\"https://utteranc.es/client.js\"\r\n  repo=\"name/repositoey\" // utterances를 연동한 repo 이름\r\n  issue-term=\"pathname\" // issue mapping\r\n  theme=\"github-light\" // 테마 색상\r\n  crossorigin=\"anonymous\"\r\n  async\r\n\u003e\u003c/script\u003e\r\n```\r\n\r\n테마 색상도 다양하기 때문에 utterances 사이트에서 원하는 색상을 골라가며 설정해줘도 괜찮다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxYtiI%2Fbtr35FEVVmk%2FcS0dxRjlWfFukRPCaL9y61%2Fimg.png)\r\n\r\n위에 생성한 script는 통상적으로 댓글 부분에 해당되는 곳에 그대로 복사해 넣지만, 나는 Nextjs를 통해 댓글 컴포넌트를 생성할 것이기 때문에 다른 방식을 사용했다.\r\n\r\n```javascript\r\nexport const Comment = () =\u003e {\r\n  return (\r\n    \u003csection\r\n      ref={elem =\u003e {\r\n        if (!elem) {\r\n          return;\r\n        }\r\n        const scriptElem = document.createElement(\"script\");\r\n        scriptElem.src = \"https://utteranc.es/client.js\";\r\n        scriptElem.async = true;\r\n        scriptElem.setAttribute(\"repo\", \"{utterances repo name}\");\r\n        scriptElem.setAttribute(\"issue-term\", \"pathname\");\r\n        scriptElem.setAttribute(\"theme\", \"github-dark\");\r\n        scriptElem.setAttribute(\"label\", \"blog-comment\");\r\n        scriptElem.crossOrigin = \"anonymous\";\r\n        elem.appendChild(scriptElem);\r\n      }}\r\n    /\u003e\r\n  );\r\n};\r\n```\r\n\r\n해당 컴포넌트에 사용하기 위해 기존의 script와 같은 속성들을 넣어줬다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fckai9y%2Fbtr4aKSLFRA%2F9p3HEGqDCEkfa8sg7Nnd0k%2Fimg.png)\r\n\r\n하지만 strict 모드를 false로 해도 종종 댓글찾이 2개가 되어버려 useEffect를 통해 1번만 script를 붙일 수 있도록 코드를 수정했다.\r\n\r\n```javascript\r\nimport { useEffect } from \"react\";\r\n\r\nexport const Comment = () =\u003e {\r\n  const makeRef = (el: HTMLElement | null) =\u003e {\r\n    if (!el) {\r\n      return;\r\n    } else {\r\n      const scriptElem = document.createElement(\"script\");\r\n      scriptElem.src = \"https://utteranc.es/client.js\";\r\n      scriptElem.async = true;\r\n      scriptElem.setAttribute(\"repo\", \"{utterances repo name}\");\r\n      scriptElem.setAttribute(\"issue-term\", \"pathname\");\r\n      scriptElem.setAttribute(\"theme\", \"github-dark\");\r\n      scriptElem.setAttribute(\"label\", \"blog-comment\");\r\n      scriptElem.crossOrigin = \"anonymous\";\r\n      el.appendChild(scriptElem);\r\n    }\r\n  };\r\n\r\n  useEffect(() =\u003e {\r\n    const newEl = document.getElementById(\"comment-box\");\r\n    makeRef(newEl);\r\n  }, []);\r\n\r\n  return \u003csection id=\"comment-box\" /\u003e;\r\n};\r\n```\r\n\r\n코드 수정 후 원하는대로 동작하는 모습을 볼 수 있었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcNZNaQ%2Fbtr38NhUPkk%2FSH2Dgj2Si71gH3Gykm9kYK%2Fimg.png)\r\n"},{"title":"github github api get repo data","description":"GithubAPI를 이용한 repository 내 Markdown 파일 정보 불러오기","category":"github","keyword":"github, api","date":"2023-03-13","content":"\r\n# Github REST API 설명서\r\n\r\nhttps://docs.github.com/ko/rest?apiVersion=2022-11-28\r\n\r\n## GithubAPI 이용 시 토큰이 필요한 경우 아래와 같이 토큰 발급도 가능하다.\r\n\r\n- 우측 상단의 프로필을 통해 Settings 접근\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc5d9NT%2Fbtr3XWt2ipS%2FlVrpZru5irR5mDft0cLaO0%2Fimg.png)\r\n\r\n- 좌측 하단의 Developer settings 접속\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdnMYAN%2Fbtr37uQgb1j%2Fz3lG0JXTBq5gkIhvk1HEek%2Fimg.png)\r\n\r\n- Tokens나 Fine-grained tokens를 통해 원하는 권한들을 설정해 토큰을 생성할 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcKOqYU%2Fbtr3V6YgATa%2Fc3QmI12TDR3vgoNL0ZTZR1%2Fimg.png)\r\n\r\n\u003e Github 홈페이지에 여러 api들이 많기 때문에 필요에 따라 사용하면 좋을 것 같다. 이 글에서는 repository 안의 파일들의 정보만을 가져올 것이다.\r\n\r\n## 1. requestURL\r\n\r\n```javascript\r\nconst BASE_URL =\r\n  \"https://api.github.com/repos/{유저명을 포함한/레포지토리 이름}/contents/{데이터를 가져올 디렉토리}\";\r\nconst options = {\r\n  headers: {\r\n    \"Content-Type\": \"application/json\",\r\n  },\r\n};\r\n```\r\n\r\n예를 들어 src의 posting이라는 디렉토리의 데이터들을 가져오고 싶다면\r\n\r\nhttps://api.github.com/repos/name/some-repo/contents/src/posting\r\n\r\n정도가 될 수 있다.\r\n\r\n요청이 정상적으로 작동했다면 아래와 같이 데이터를 받을 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXHDFb%2Fbtr3WcDXFiZ%2FmFW3Q3uyQPHEOBpkOFVKA0%2Fimg.png)\r\n\r\n하지만 하나의 파일에 대한 구체적인 정보는 들어있지 않다.\r\n\r\n한 단계로 더 들어가 정보를 받아온다면 아래와 같은 base64로 인코딩된 content 데이터를 받아올 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcaVD0e%2Fbtr38M4cfZ6%2FMLUYZ4OarG3pXvjnSCW7VK%2Fimg.png)\r\n\r\n## 2. decoding\r\n\r\n해당 콘텐츠의 데이터를 정상적으로 받아오기 위해서는 디코딩이 필요하다.\r\n\r\n```typescript\r\nconst eachMarkdown = async (name: string) =\u003e {\r\n    const url = `${BASE_URL}/${categoryName}/${name}`;\r\n    const response = await axios.get(url, options);\r\n    const content = Buffer.from(response.data.content, \"base64\").toString();\r\n\r\n    ...\r\n};\r\n```\r\n\r\ncontent 데이터를 추출하고 콘솔을 확인하면 아래와 같이 string을 받아볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Flctvp%2Fbtr38LKZ6o1%2FnwU9EK44kJmKCfanQsdw0K%2Fimg.png)\r\n\r\n## 3. 데이터 가공\r\n\r\n캡쳐 이미지 아래로 마크다운 파일의 본문들이 함께 있지만, 내가 필요한 부분은 머리말 부분이기 때문에 이 데이터를 추출해야 했다.\r\n\r\n```typescript\r\nconst eachMarkdown = async (name: string) =\u003e {\r\n  const url = `${BASE_URL}/${categoryName}/${name}`;\r\n  const response = await axios.get(url, options);\r\n  const content = Buffer.from(response.data.content, \"base64\").toString();\r\n  const frontmatter = content.match(/^---\\n([\\s\\S]+?)\\n---/);\r\n  if (frontmatter) {\r\n    const matters = JSON.stringify(frontmatter[0]).split(\"\\\\n\");\r\n    const dateRegex = /\\d{4}-\\d{2}-\\d{2}/;\r\n    const match = matters[4].match(dateRegex);\r\n    if (match) {\r\n      const result = {\r\n        title: matters[1].split(\"title: \")[1].replaceAll(\" \", \"-\"),\r\n        description: matters[2].split(\"description: \")[1],\r\n        category: matters[3].split(\"category: \")[1],\r\n        date: match[0],\r\n      };\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n상수 frontmatter는 머리말을 가져오지만 예쁘게 가져오진 않는다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTC1yi%2Fbtr35bRukP2%2FnWJ0mgeFgu2LlEBk0KyupK%2Fimg.png)\r\n\r\n때문에 if(frontmatter){...}와 같이 필요한 데이터를 정규식이나 string메서드를 통해 원하는대로 가공해 사용하여 사용해야 한다.\r\n"},{"title":"github git use markdown viewer","description":"Github pages 블로그 Markdown 불러오기","category":"github","keyword":"github, markdown","date":"2023-03-12","content":"\r\n## Markdown을 통해 블로그를 작성하는 이유\r\n\r\n- 머리말을 따로 설정해 route 링크를 설정해주거나 제목, 날짜, 카테고리, 등을 설정하여 블로그 탐색을 용이하게 해줄 수 있다.\r\n- Markdown을 repository에 저장함으로써 githubAPI 등을 이용한 데이터 조회를 가능하게 한다.\r\n\r\n## 필요한 패키지\r\n\r\n```bash\r\nyarn add gray-matter # 문자열이나 파일에서 머리말을 구문 분석, 파일에서 메타데이터와 내용 등 추출 시 사용\r\nyarn add marked\r\nyarn add @types/marked # 타입스크립트의 경우\r\nyarn add react-markdown # \u003cdiv dangerouslySetInnerHTML={createMarkup()} /\u003e과 유사함\r\nyarn add remark-gfm # 마크다운 문법이 다양하게 적용될 수 있도록 도와주는 플러그인\r\nyarn add react-syntax-highlighter\r\nyarn add @types/react-syntax-highlighter # 타입스크립트의 경우\r\n```\r\n\r\n참조\r\n\r\nhttps://yarnpkg.com/package/react-markdown\r\n\r\nhttps://yarnpkg.com/package/react-syntax-highlighter\r\n\r\n## posting 파일들은 src 파일 안에 있다고 가정\r\n\r\n## 1. [slug].tsx 파일 생성\r\n\r\n```javascript\r\n\r\nimport { GetStaticPaths, GetStaticProps } from \"next\";\r\nimport { join } from \"path\";\r\nimport fs from \"fs/promises\";\r\nimport matter from \"gray-matter\";\r\nimport ReactMarkdown from \"react-markdown\";\r\nimport remarkGfm from \"remark-gfm\"; // Link, table, checklist 등의 형식을 표현할 수 있게 해줌\r\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\r\n// import { darcula } from \"react-syntax-highlighter/dist/esm/styles/prism\"; - 에러 발생\r\nimport { dark } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\r\nimport { vsDark } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\r\nimport { darcula } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\r\n\r\n\r\ninterface Props {\r\n  title: string;\r\n  date: string;\r\n  content: string;\r\n}\r\n\r\nexport default function BlogPost({ title, date, content }: Props) {\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch1\u003e{title}\u003c/h1\u003e\r\n      \u003cp\u003e{date}\u003c/p\u003e\r\n      \u003cReactMarkdown\r\n          className=\"markdown\"\r\n          remarkPlugins={[remarkGfm]}\r\n          components={{\r\n            code({ inline, className, children, ...props }) {\r\n              const match = /language-(\\w+)/.exec(className || \"\");\r\n              return !inline \u0026\u0026 match ? (\r\n                \u003cSyntaxHighlighter\r\n                  language={match[1]}\r\n                  PreTag=\"pre\"\r\n                  {...props}\r\n                  // style={dark}\r\n                  style={darcula}\r\n                  // style={vsDark}\r\n                \u003e\r\n                  {String(children).replace(/\\n$/, \"\")}\r\n                \u003c/SyntaxHighlighter\u003e\r\n              ) : (\r\n                \u003ccode className={className} {...props}\u003e\r\n                  {children}\r\n                \u003c/code\u003e\r\n              );\r\n            },\r\n          }}\r\n        \u003e\r\n          {content}\r\n        \u003c/ReactMarkdown\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\n// 파일명을 통해 url 생성\r\nexport const getStaticPaths: GetStaticPaths = async () =\u003e {\r\n  const postsDirectory = join(process.cwd() + \"src\" + \"/posting\", \"blog\");\r\n  const filenames = await fs.readdir(postsDirectory);\r\n  const paths = filenames.map(filename =\u003e ({\r\n    params: { slug: filename.replace(/\\.md$/, \"\") },\r\n  }));\r\n  return { paths, fallback: false };\r\n};\r\n\r\n// url에 해당하는 파일명을 찾아 matter로 데이터 추출\r\nexport const getStaticProps: GetStaticProps\u003cProps\u003e = async ({ params }) =\u003e {\r\n  const slug = params?.slug as string;\r\n  const filePath = join(process.cwd() + \"src\" + \"/posting\", \"blog\", `${slug}.md`);\r\n  const fileContents = await fs.readFile(filePath, \"utf8\");\r\n  const { data, content } = matter(fileContents);\r\n  return {\r\n    props: {\r\n      title: data.title,\r\n      date: data.date,\r\n      content,\r\n    },\r\n  };\r\n};\r\n\r\n```\r\n\r\n## 2. SyntaxHighlighter style 설정\r\n\r\nSyntaxHighlighter 내부의 코드블록 style을 이용하기 위해서는 그에 맞는 소스를 가져와야 한다.\r\n\r\n### 에러가 발생하는 ...dist/esm/styles/prism\r\n\r\nimport { darcula } from \"react-syntax-highlighter/dist/esm/styles/prism\";\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrNEOn%2Fbtr34VAZ3qk%2Fhy9KPHftPMrHNswKxBdBk0%2Fimg.png)\r\n\r\n### 정상 작동하는 imports ...dist/cjs/styles/prism\r\n\r\n```javascript\r\nimport { darcula } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FQTv0s%2Fbtr37t4PDmS%2Fc0Sw6mnao0GUU05pG0mnb0%2Fimg.png)\r\n\r\n```javascript\r\nimport { dark } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdjz47g%2Fbtr35dhlOF6%2FmmOkOQB6R1x5TgzkEcQ27K%2Fimg.png)\r\n\r\n```javascript\r\nimport { vsDark } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F29uf2%2Fbtr3V6KDHYg%2FeTnSoSaIAgZYqOcK7MTr8K%2Fimg.png)\r\n\r\n원하는 스타일을 SyntaxHighlighter style에 넣어주면 된다.\r\n\r\n\u003e Markdown content(내용)는 ReactMarkdown 컴포넌트의 className을 통해 수정해줄 수 있다.\r\n\r\n## 3. Markdown 파일 생성\r\n\r\n```markdown\r\n// 파일명 : first-post.md\r\n--- 머리말\r\ntitle: First-Post\r\ndate: \"2023-02-28\" \u003c- 숫자만 사용하면 newDate()처럼 생성되어 타입 오류 발생 가능\r\n\r\n---\r\n\r\n# Deploy and test\r\n\r\ntest\r\n```\r\n\r\nMarkdown 파일의 데이터를 불러올때, 머리말을 이용한 metaTag 설정이나 제목 등을 자유롭게 설정할 수 있다.\r\n\r\n파일 생성 후 해당 링크 접속 시 정상적으로 접속이 가능해진다.\r\n\r\n## ex\r\n\r\nlocalhost:3000/first-post\r\n\r\nurl은 [slug].tsx 파일이 위치한 경로에 따라 달라질 수 있다. (nextjs 라우팅 방식)\r\n"},{"title":"github git custom blog","description":"Nextjs를 이용한 Github pages 블로그 만들기","category":"github","keyword":"github, pages","date":"2023-03-11","content":"\r\n# Github pages와 Nextjs를 선택한 이유\r\n\r\n### 1. Github pages\r\n\r\n\u003e vercel도 Nextjs로 쉽게 배포할 수 있지만, 백엔드는 별도로 만들지 않을 계획이었기에, 추후 댓글 기능이나 추천 글 목록 등을 Github 사이트 하나로 모두 관리하기 위해서 Github pages를 이용하기로 했다.\r\n\r\n### 2. Nextjs\r\n\r\n\u003e 블로그는 검색엔진에 잘 노출되어야 그 의미가 있다. 또한 React 환경을 이용한 블로그 개발을 원했기에 SSR(Server Side Rendering) 등을 통한 SEO(검색엔진 최적화)에 유리한 React 프레임워크인 Nextjs를 사용하기로 결정했다.\r\n\r\n# Github Pages 호스팅 방법\r\n\r\n### 1. Repository 생성\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbkBnCf%2Fbtr3TGZh4t7%2F0VD4ycS4u8EvTAeIxvjsP1%2Fimg.png)\r\n\r\nRepo 이름은 {username}.github.io 로 저장해준다.\r\n\r\n- 생성된 repo의 settings =\u003e pages에서 배포를 확인할 수 있다. (배포되는데 5~10분 정도 소요될 수 있다.)\r\n\r\n### 2. Repository 클론 후 Nextjs 설치\r\n\r\n```bash\r\n# 현재 디렉토리에 설치\r\nyarn create next-app .\r\n\r\n# typescript\r\nyarn create next-app . --typescript\r\n```\r\n\r\n### 3. gh-pages 설치\r\n\r\nGithub pages를 이용하기 위해 아래 명령어를 통해 설치해준다.\r\n\r\n```bash\r\nyarn add gh-pages --save-dev\r\n```\r\n\r\n### 4. package.json 설정\r\n\r\n홈페이지 도메인 추가 및 scripts를 수정해준다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbSbOFc%2Fbtr33yMA8BY%2FYBMjkb8aNMMR8jv7bhlrxk%2Fimg.png)\r\n\r\n1번째 줄처럼 홈페이지를 입력하고, scripts를 위와 같이 수정해준다.\r\n\r\n```javascript\r\n\"build\": \"next build \u0026\u0026 next export\",\r\n\"predeploy\": \"npm run build\",\r\n\"deploy\": \"touch out/.nojekyll \u0026\u0026 gh-pages -d out --dotfiles\"\r\n```\r\n\r\n- next export : Nextjs를 정적 사이트로 배포하기 위해 설정\r\n- -- touch out/.nojekyll : 본래 guthub pages는 jekyll 기반으로, \\_\\_{filename}을 특수 리소스로 간주하고 최종 사이트에 복사하지 않기 때문에 jekyll을 사용하지 않는다고 명시해 정상적으로 처리될 수 있도록 설정\r\n- gh-pages -d out --dotfiles : 현재 repo의 임시 복제본 생성 후, gh-pages 브랜치가 없는 경우 브랜치 생성. 기본 경로의 모든 파일 또는 선택적 src 구성의 패턴과 일치하는 파일만 복사하고 모든 변경 사항 커밋 후 푸시. 이미 gh-pages 브랜치가 있는 경우 제공된 파일에서 커밋을 추가하기 전에 원격의 모든 커밋으로 업데이트됨. src 패턴과 일치하는 도트 파일도 포함시킴\r\n\r\n참조 : https://github.com/tschaub/gh-pages\r\n\r\n명령어 보기\r\n\r\n```bash\r\nyarn gh-pages --help\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbJQQKR%2Fbtr34cpsLGR%2FDtpXfGfLf2p8bph05dvvnk%2Fimg.png)\r\n\r\n### next.config.js 수정\r\n\r\nconfig는 본인이 적용하려는 방식에 맞게 설정해줘도 괜찮다.\r\n\r\n```javascript\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  reactStrictMode: false,\r\n  images: {\r\n    unoptimized: true, // 이미지 정상적으로 불러올 수 있도록함\r\n  },\r\n  compiler: {\r\n    styledComponents: true, // styled-components 사용 시 컴파일러에 추가\r\n  },\r\n};\r\n\r\nmodule.exports = nextConfig;\r\n```\r\n\r\n### 6. 배포\r\n\r\n```bash\r\nyarn deploy\r\n```\r\n\r\n\u003e cmd(명령 프롬프트)에서 실행 시 tought를 사용할 수 없다는 에러가 발생하기 때문에 git bash로 실행\r\n\r\n### 7. 배포 후 설정\r\n\r\n```bash\r\nExport successful. Files written to D:\\0. CORDING\\INDI-PROJECT\\github-blog\\out\r\n$ gh-pages -d out --dotfiles\r\nPublished\r\n```\r\n\r\n터미널에 위와 같은 메세지가 뜨면, repository =\u003e setting =\u003e pages의 branch에 gh-pages가 생성돼있는 것을 볼 수 있음\r\n\r\ngh-pages를 배포 브랜치로 설정해준 후 저장\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXcGvE%2Fbtr35F5rS1r%2FgTSz4ck3EW2y6KOnmS9EiK%2Fimg.png)\r\n\r\n설정을 완료하고 상단의 Visit site로 페이지를 접속하면 Nextjs 기본 화면이 잘 나오는 것을 볼 수 있다.\r\n"},{"title":"css a tag style fix","description":"a 태그(Link 태그) 기본 스타일 제거하기","category":"css","keyword":"css, a태그, link태그","date":"2023-03-09","content":"\r\n# a태그 기본 스타일 제거와 스타일 적용\r\n\r\n```css\r\n/* 기본 밑줄 제거 */\r\na {\r\n  text-decoration: none;\r\n}\r\n\r\n/* 아직 방문하지 않은 링크의 글자색 정의 */\r\na:link {\r\n  color: pink;\r\n}\r\n\r\n/* 사용자가 방문한 적이 있는(클릭한 이후) 링크의 글자색 \r\n정의 */\r\na:visited {\r\n  color: black;\r\n}\r\n\r\n/* 마우스를 링크에 올려두었을 때, 글자색을 정의 */\r\na:hover {\r\n  color: red;\r\n}\r\n\r\n/* 마우스로 링크를 클릭하고 뗄 때까지의 글자색을 정의 */\r\na:active {\r\n  color: green;\r\n}\r\n```\r\n"},{"title":"css no selection","description":"CSS로 글자 더블클릭 시 선택자(파란색 마스킹) 없애기","category":"css","keyword":"css, 마스킹 제거","date":"2023-03-09","content":"\r\n# 더블클릭시 파란색 선택자 생성 막는 방법\r\n\r\n```css\r\ndiv {\r\n  user-select: none;\r\n  -webkit-user-select: none;\r\n  /* (safari, chrome) browsers */\r\n  -moz-user-select: none;\r\n  /* mozilla browsers */\r\n  -khtml-user-select: none;\r\n  /* konqueror browsers */\r\n\r\n  -ms-user-select: none; /* IE10+ */\r\n}\r\n```\r\n"},{"title":"github git cmd","description":"깃 명령어 모음","category":"github","keyword":"github, 명령어","date":"2023-03-09","content":"\r\n# 깃 명령어 모음\r\n\r\n## 디렉토리\r\n\r\n1. 홈 디렉토리로 이동\r\n\r\n```bash\r\n$ cd ~\r\n```\r\n\r\n2. 새 디렉토리에 디렉토리명을 생성\r\n\r\n```bash\r\n$ mkdir [디렉토리명]\r\n```\r\n\r\n3. [디렉토리명]으로 이동\r\n\r\n```bash\r\n$ cd [디렉토리명]\r\n```\r\n\r\n4. 부모 디렉토리로 이동\r\n\r\n```bash\r\n$ cd ..\r\n```\r\n\r\n5. 현재 경로를 출력 // print working directory\r\n\r\n```bash\r\n$ pwd\r\n```\r\n\r\n6. 디렉토리의 내용을 출력\r\n\r\n```bash\r\n$ ls\r\n```\r\n\r\n7. 디렉토리의 폴더 상세 정보까지 출력\r\n\r\n```bash\r\n$ ls -l\r\n```\r\n\r\n8. 디렉토리의 숨김 파일과 디렉토리까지 출력\r\n\r\n```bash\r\n$ ls -a\r\n```\r\n\r\ntip: 옵션은 합쳐서 ls -al 처럼 사용이 가능하다.\r\n\r\n9. 파일이 있는 디렉토리를 내용물과 함께 삭제\r\n\r\n```bash\r\n$ rm -r [디렉토리명]\r\n```\r\n\r\n10. vi 편집기로 [파일명.확장자명] 파일을 작성\r\n\r\n```bash\r\n$ vim [파일명.확장자명]\r\n```\r\n\r\n11. 터미널 창의 내용을 삭제\r\n\r\n```bash\r\n$ clear\r\n```\r\n\r\n12. 터미널 창을 종료\r\n\r\n```bash\r\n$ exit\r\n```\r\n\r\n## git 유저 / 업로드\r\n\r\n1. 현재 위치에서 지역 저장소를 생성\r\n\r\n```bash\r\n$ git init\r\n```\r\n\r\n2. 깃 환경에서 사용자 이름을 [사용자명]으로 지정\r\n\r\n```bash\r\n$ git config --global user.name \"[사용자명]\"\r\n```\r\n\r\n3. 깃 환경에서 사용자 이메일을 [사용자이메일명]으로 지정\r\n\r\n```bash\r\n$ git config --global user.email \"[사용자이메일명]\"\r\n```\r\n\r\n4. 깃의 상태를 확인\r\n\r\n```bash\r\n$ git status\r\n```\r\n\r\n## commit 명령어\r\n\r\n1. [파일명.확장자명]을 스테이지에 올림\r\n\r\n```bash\r\n$ git add [파일명.확장자명]\r\n```\r\n\r\n2. 커밋 메시지 [메시지명]을 붙여 커밋\r\n\r\n```bash\r\n$ git commit -m \"[메시지명]\"\r\n```\r\n\r\n3. 메시지 [메시지명]을 붙여서 스테이징과 커밋을 동시에 진행\r\n\r\n```bash\r\n$ git commit -a -m \"[메시지명]\"\r\n```\r\n\r\n4. 커밋 내역 확인\r\n\r\n```bash\r\n$ git log\r\n$ git log --pretty=oneline   # 한줄로 표기하기\r\n```\r\n\r\n5. 특정 커밋 내역 확인\r\n\r\n```bash\r\n$ git show [커밋 id]\r\n```\r\n\r\n6. 최근 버전과 작업 폴더의 수정 파일 사이의 차이를 출력\r\n\r\n```bash\r\n$ git diff\r\n$ git diff [이전커밋 id] [이후커밋 id]\r\n```\r\n\r\n7. 지정한 커밋 해시로 이동\r\n\r\n```bash\r\n$ git checkout [커밋 해시]\r\n```\r\n\r\n8. 가장 최근 커밋을 취소\r\n\r\n```bash\r\n$ git reset HEAD^ # 현재 HEAD의 이전 커밋으로 되돌리기\r\n$ git reset HEAD~n # 현재로 부터 n 번째 이전 커밋으로 되돌리기\r\n```\r\n\r\n9. 지정한 커밋 해시로 이동하고 커밋을 취소\r\n\r\n```bash\r\n$ git reset [커밋 해시]\r\n\r\n# reset의 3가지 옵션\r\n$ git reset --soft [커밋ID]  # head 만 바뀜\r\n$ git reset --mixed [커밋ID] # staging 도 그 때로 바뀜\r\n$ git reset --hard [커밋ID] # working디렉토리/staging 모두 그 때로 바꿈\r\n```\r\n\r\n10. 지정한 커밋 해시의 변경 이력을 취소\r\n\r\n```bash\r\n$ git revert [커밋 해시]\r\n```\r\n\r\n11. 커밋 수정하는 법\r\n\r\n```bash\r\n# 파일 수정 한 뒤\r\n$ git add .\r\n$ git commit --amend  : 최신 커밋 수정\r\n```\r\n\r\n## 브랜치 명령어\r\n\r\n1. 새로운 브랜치 [브랜치명]을 생성\r\n\r\n```bash\r\n$ git branch [브랜치명]\r\n# 브랜치 조회하기\r\n$ git branch\r\n```\r\n\r\n2. [브랜치명]으로 체크아웃(이동)\r\n\r\n```bash\r\n$ git checkout [브랜치명]\r\n$ git checkout -b [브랜치명]  # 브랜치만들고 바로 이동\r\n# 브랜치 삭제\r\n$ git branch -d 브랜치명\r\n```\r\n\r\n3. 커밋 로그에서 한 줄에 한 커밋씩 출력\r\n\r\n```bash\r\n$ git log --oneline\r\n```\r\n\r\n4. 수정한 전체 파일을 스페이지에 올린다.\r\n\r\n```bash\r\n$ git add .\r\n```\r\n\r\n5. 커밋 로그에 각 브랜치의 커밋을 그래프로 표시\r\n\r\n```bash\r\n$ git log --branches --graph\r\n```\r\n\r\n6. [브랜치명]을 master 브랜치와 병합\r\n\r\n```bash\r\n$ git merge [브랜치명]\r\n$ git merge [브랜치명] --edit # 병합 후 바로 vi  편집기가 나오면서 커밋 메시지 수정 가능\r\n$ git merge [브랜치명] --no-edit # 커밋 메시지 수정없이 바로 병합\r\n```\r\n\r\n7. merge 취소하기\r\n\r\n```bash\r\n$ git merge --abort\r\n```\r\n\r\n## git hub 원격 저장소\r\n\r\n1. 원격 저장소에 연결\r\n\r\n```bash\r\n$ git remote add origin [github 레포지 주소]\r\n$ git remote add origin [branch 이름]   #없으면 생성됨\r\n```\r\n\r\n2. 원격 저장소에 연결됐는지 확인\r\n\r\n```bash\r\n$ git remote -v\r\n```\r\n\r\n3. 지역 저장소의 커밋을 맨 처음 원격 저장소에 올리는 경우\r\n\r\n```bash\r\n$ git push -u origin master\r\n```\r\n\r\n4. 3번을 한 후에 지역 저장소의 커밋을 원격 저장소에 올리는 경우(업로드)\r\n\r\n```bash\r\n$ git push\r\n$ git push origin master\r\n```\r\n\r\n5. 원격 저장소의 커밋을 지역 저장소로 가져옴\r\n\r\n```bash\r\n$ git pull\r\n$ git pull origin master\r\n```\r\n\r\n6. SSH 키를 생성함\r\n\r\n```bash\r\n$ ssh-keygen\r\n```\r\n\r\n7. 원격 저장소 복제하기\r\n\r\n```bash\r\n# 첫번째 커밋이 아니라면 풀 먼저하기\r\n$ git remote remove origin\r\n\r\n#원격 저장소를 [지역저장소명]에 복제하기\r\n$ git clone [원격 저장소 주소]\r\n```\r\n\r\n8. 원격 저장소의 커밋을 가져오기만 하고 merge하지 않는다\r\n   가져온 branch 내용은 origin/[브랜치] 로 저장됨\r\n\r\n```bash\r\n$ git fetch\r\n# 이후엔 diff 로 비교\r\n$ git diff test origin/test # 브랜치 이름이 test일 경우 예시\r\n```\r\n\r\n9. 패치로 가져온 정보가 있는 브랜치\\[FETCH_HEAD\\]로 이동\r\n\r\n```bash\r\n$ git checkout FETCH_HEAD\r\n```\r\n\r\n10. 패치로 가져온 정보가 있는 브랜치[FETCH_HEAD]를 master 브랜치에 병합한다\r\n\r\n```bash\r\n$ git merge FETCH_HEAD\r\n```\r\n\r\n11. [브랜치명]을 만드는 것과 동시에 체크아웃한다\r\n\r\n```bash\r\n$ git checkout -b [브랜치명]\r\n```\r\n\r\n12. 원격 저장소에 [브랜치명]의 브랜치의 커밋을 올린다\r\n\r\n```bash\r\n$ git push origin [브랜치명]\r\n```\r\n\r\n13. 원격저장소 삭제\r\n\r\n```bash\r\n$ git remote remove origin\r\n```\r\n\r\n## 파일/보관 명령어(stash)\r\n\r\n1. 파일 내용 출력\r\n\r\n```bash\r\n$ cat [파일명.확장자명]\r\n```\r\n\r\n2. 디렉토리를 만드는 동시에 지역저장소 생성\r\n\r\n```bash\r\n$ cd init [디렉토리명]\r\n```\r\n\r\n3. 현재 커밋을 다른 브랜치에 있는 [커밋메시지] 커밋으로 되돌림\r\n\r\n```bash\r\n$ git reset [커밋메시지] [커밋해시]\r\n```\r\n\r\n4. 병합이 끝난 [브랜치명]을 삭제\r\n\r\n```bash\r\n$ git branch [브랜치명] -d\r\n```\r\n\r\n5. 작업 트리의 수정 내용 stash에 따로 보관하기\r\n\r\n```bash\r\n$ git stash\r\n$ git stash save\r\n```\r\n\r\n6. 보관한 내용을 목록을 출력\r\n\r\n```bash\r\n$ git stash list\r\n```\r\n\r\n7. 보관한 내용을 적용\r\n\r\n```bash\r\n$ git stash apply\r\n$ git stash apply stash@{1}\r\n```\r\n\r\n8. 보관한 내용 중 가장 최근 항목을 삭제\r\n\r\n```bash\r\n$ git stash drop\r\n$ git stash drop stash@{1}\r\n```\r\n\r\n9. stash를 apply하고 제거(drop) 하기\r\n\r\n```bash\r\n$ git stash pop\r\n```\r\n\r\n## 기타 명령어\r\n\r\n1. 긴 명령어 짧게 이름 붙여 사용하기\r\n\r\n```bash\r\n# ex) git log --pretty=oneline을\r\n# -\u003egit history 라는 별명으로 바꾸기.\r\n\r\ngit config alias.[별명] '원하는 명령어'\r\ngit config alias.history 'log --pretty=oneline'\r\n```\r\n\r\n2. tag 설정 하기\r\n\r\n```bash\r\n$ git tag [태그이름][커밋 ID]\r\n$ git tag Version_2 86a99 # tag 달기\r\n$ git tag    #tag 조회하기\r\n$ git show Version_2\r\n```\r\n"},{"title":"html meta tag","description":"SEO(검색엔진 최적화)를 위한 HTML의 meta tag 간단 정리","category":"html","keyword":"html, SEO","date":"2023-03-09","content":"\r\n# 메타태그\r\n\r\n### 메타태그란 쉽게 말해서 눈에 보이지 않는 문서가 가지고 있는 정보들을 담을 수 있는 태그를 말한다.\r\n\r\n## 1. 주로 사용해볼 수 있는 요소\r\n\r\n검색 엔진에 검색되는 단어 지정\r\n\r\n```html\r\n\u003cmeta name=\"keywords\" content=\"\" /\u003e\r\n```\r\n\r\n홈페이지 주제 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"Subject\" content=\"\" /\u003e\r\n```\r\n\r\n제목 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"title\" content=\"\" /\u003e\r\n```\r\n\r\n검색 결과에 표시되는 문자 지정\r\n\r\n```html\r\n\u003cmeta name=\"description\" content=\"\" /\u003e\r\n```\r\n\r\n검색 로봇 제어\r\n\r\n```html\r\n\u003cmeta name=\"robots\" content=\"\" /\u003e\r\n```\r\n\r\n날짜(제작일)\r\n\r\n```html\r\n\u003cmeta name=\"date\" content=\"2016-02-15T07:45:37+09:00\" /\u003e\r\n```\r\n\r\n제작자명 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"author\" content=\"\" /\u003e\r\n```\r\n\r\nog: 태그\r\n\r\n```html\r\n\u003c!-- 하이퍼링크의 미리보기 이미지, 제목, 내용 요약에 사용 가능 --\u003e\r\n\u003cmeta property=\"og:title\" content=\"내 사이트의 제목\" /\u003e\r\n\u003cmeta property=\"og:description\" content=\"보고 있는 페이지의 내용 요약\" /\u003e\r\n\u003cmeta property=\"og:image\" content=\"이미지URL\" /\u003e\r\n```\r\n\r\n## 2. 사용 빈도 낮아보이는 요소\r\n\r\n제작사 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"publisher\" content=\"\" /\u003e\r\n```\r\n\r\n웹 책임자 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"other agent\" content=\"\" /\u003e\r\n```\r\n\r\n제작 도구 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"generator\" content=\"\" /\u003e\r\n```\r\n\r\n메일 주소 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"Reply-To\" content=\"naver@naver.com\" /\u003e\r\n```\r\n\r\n```html\r\n\u003cmeta http-equiv=\"email\" content=\"naver@naver.com\" /\u003e\r\n```\r\n\r\n파일 이름 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"filename\" content=\"index.html\" /\u003e\r\n```\r\n\r\n위치 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"Location\" content=\"\" /\u003e\r\n```\r\n\r\n배포자 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"distribution\" content=\"\" /\u003e\r\n```\r\n\r\n저작권 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"copyright\" content=\"copyright@~~\" /\u003e\r\n```\r\n\r\n제작 년/월/일 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"build\" content=\"date\" /\u003e\r\n```\r\n\r\n최종 수정일 정의\r\n\r\n```html\r\n\u003cmeta\r\n  http-equiv=\"Last-Modified\"\r\n  content=\"Mon,20 Jul 2016 \r\n19:30:30\"\r\n/\u003e\r\n```\r\n\r\n## 3. 사용 빈도가 많이 낮아보이는 요소\r\n\r\n그림 위에 마우스 오버시 이미지 관련 툴바 생성하지 않음\r\n\r\n```html\r\n\u003cmeta http-equiv=\"imagetoolbar\" content=\"no\" /\u003e\r\n```\r\n\r\n캐시 금지\r\n\r\n```html\r\n\u003cmeta http-equiv=\"Cache-Control\" content=\"no-cache\" /\u003e\r\n```\r\n\r\n```html\r\n\u003cmeta http-equiv=\"Pragma\" content=\"no-cache\" /\u003e\r\n```\r\n\r\n캐시 만료일 정의\r\n\r\n```html\r\n\u003cmeta http-equiv=\"expires\" content=\"Mon, 08 Sep 2016 10:10:10 GMT\" /\u003e\r\n```\r\n\r\n60초마다 새로고침\r\n\r\n```html\r\n\u003cmeta http-equiv=\"refresh\" content=\"60\" /\u003e\r\n```\r\n\r\n입력한 주소로 5초후 이동하는 것을 정의\r\n\r\n```html\r\n\u003cmeta http-equiv=\"refresh\" content=\"5;url=주소\" /\u003e\r\n```\r\n\r\n브라우저 호환성 지정\r\n\r\n```html\r\n\u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e\r\n```\r\n\r\n웹 페이지에 쓰인 언어 지정\r\n\r\n````html\r\n\u003cmeta http-equiv=\"Content-Script-Type\" content=\"text/```javascript\" /\u003e\r\n```html\r\n\u003cmeta http-equiv=\"Content-Style-Type\" content=\"text/css\" /\u003e\r\n````\r\n\r\n## 4. 써볼만한 태그\r\n\r\n페이지 인입 시 장면 전환 효과\r\n\r\n```html\r\n\u003cmeta http-equiv=\"Page-Enter\" content=\"revealtrans(Duration=1,Transition=12)\" /\u003e\r\n```\r\n\r\n- Box out : 네모난 박스가 안쪽에서 바깥쪽으로\r\n- Circle in : 원이 바깥에서 안쪽으로\r\n- Circle out : 원이 안쪽에서 바깥쪽으로\r\n- Wipe up : 이미지의 아래에서 위쪽으로 수직 이동\r\n- Wipe down : 이미지의 위에서 아래쪽으로 수직 이동\r\n- Wipe right : 이미지의 왼쪽에서 오른쪽으로 수평 이동\r\n- Wipe left : 이미지의 오른쪽에서 왼쪽으로 수평 이동\r\n- Vertical blinds : 수직 블라인드가 쳐지는 형태로 변환\r\n- Horizontal blinds : 수평 블라인드가 쳐지는 형태로 변환\r\n- Checkerboard across : 바둑판 형태의 격자가 왼쪽에서 오른쪽으로 - 생성\r\n- Checkerboard down : 바둑판 형태의 격자가 위에서 아래로 생성\r\n- Random dissove : 안개와 비슷한 형태로 전환\r\n- Split vertical in : 왼쪽과 오른쪽 끝에서 중앙으로 수직 이동\r\n- Split vertical out : 중앙에서 양쪽 끝으로 수직 이동\r\n- Split Horizontal in : 양쪽에서 중앙으로 수평 이동\r\n- Split Horizontal out : 중앙에서 양쪽끝으로 수직이동\r\n- Strips left down : 대각선 형태로 오른쪽 상단에서 왼쪽 하단으로 - 이동\r\n- Strips left up : 대각선 형태로 오른쪽 하단에서 왼쪽 상단으로 이동\r\n- Strips right down : 대각선 형태로 왼쪽 상단에서 오른쪽 하단으로 - 이동\r\n- Strips right up : 대각선 형태로 왼쪽 하단에서 오른쪽 상단으로 이동\r\n- Random bars horizontal : 수평선이 무작위로 생성\r\n- Random bars vertical : 수직선이 무작위로 생성\r\n- Random : 임의로 생성\r\n"},{"title":"javascript basic 1 num str","description":"javascript 기초 1 숫자열문자열","category":"javascript","keyword":"javascript, string, number","date":"2023-03-06","content":"\r\n# 1. 숫자열을 문자열로 바꾸기\r\n\r\n```javascript\r\n\r\n// 숫자는 숫자+\"\"만 해줘도 (혹은 다른 문자를 더해줘도) 문자열로 바뀐다.\r\n\r\nlet a = 1234\r\nconsole.log(a) // a는 숫자 1234\r\nlet b = a+\"\"\r\nconsole.log(b) // b는 문자 '1234'\r\nlet c = 1234.toString()\r\nconsole.log(c) // c는 문자 '1234\r\n\r\n```\r\n\r\n# 2. 문자열을 숫자열로 바꾸기\r\n\r\n```javascript\r\n\r\n//s는 String\r\nNumber(s)로 문자열을 숫자로 변환 - 인자를 바꿀 수 없으면(ex. 123입니다) NaN을 리턴한다.\r\nparseInt(s)로 문자열을 숫자로 변환 - 정수나 NaN을 리턴한다.\r\nparseFloat(s)로 문자열을 숫자로 변환 - 부동 소수점 숫자를 반환한다.\r\n\r\n// parseFloat 예제\r\n\r\nfunction circumference(r) {\r\n  return parseFloat(r) * 2.0 * Math.PI;\r\n}\r\n\r\nconsole.log(circumference(4.567));\r\n// 28.695307297889173\r\n\r\nconsole.log(circumference('4.567abcdefgh'));\r\n// 28.695307297889173\r\n\r\nconsole.log(circumference('abcdefgh'));\r\n// NaN\r\n\r\n\r\n```\r\n\r\n# 3. 문자열 다루기\r\n\r\n```javascript\r\n\r\nString.trim() - 문자열의 공백을 제거\r\n      .trimStart() - 문자열 왼쪽 공백 제거\r\n      .trimEnd() - 오른쪽 공백 제거\r\n      .slice(0,-1) - 문자열에서 텍스트를 추출하고 새 문자열을 반환\r\n      .split('') - 문자열 String을 ()안 인자(''등)로 나눠 각 글자별로 배열 생성\r\n       \t\t// ex) let name=hanbbi; name.split('') // [ 'h', 'a', 'n', 'b', 'b', 'i' ]\r\n      .join('') 배열 내 요소들을 인자를 통해 이어준다.\r\n      .replace(\"인자1\",\"인자2\") - 문자 내 맨 처음 발견된 인자1을 찾아 인자2로 바꿔준다.\r\n      .replace(\"인자1\",\"인자2\") - 문자 내 모든 인자1을 찾아 인자2로 바꿔준다.\r\n      .repeat() - 해당 문자를 ()번 반복\r\n      .includes() - 문자열이 특정 문자열을 포함하는지 확인\r\n      .charAt(0) - 스트링의 0번째 글자 가져오기(result = string)\r\n      .substring(0,5) - 스트링의 0~4번째 글자 가져오기\r\n\r\n```\r\n"},{"title":"javascript basic 2 date","description":"javascript 기초 2 날짜다루기","category":"javascript","keyword":"javascript, date","date":"2023-03-06","content":"\r\n# Javascript 날짜 다루기\r\n\r\n## 날짜 계산\r\n\r\n```javascript\r\n// 날짜 예제\r\n// Sunday - Saturday : 0 - 6\r\nconst someday = new Date(\"2022-01-23\");\r\n// 날짜 형식은 자유로움 ('january 23 ,2022') 처럼 사용 가능\r\n\r\nconst day1 = someday.getDay();\r\nconsole.log(day1); //  22.01.23은 일요일이므로, 0 반환\r\n\r\n// 날짜 추출\r\nlet today = new Date(); // 인자가 비어있는 경우 현재 날짜/시간 반환\r\n\r\nlet year = today?.getFullYear();\r\nconsole.log(year); // 123 - 2023년 반환값 (2022년 반환값 = 122)\r\n\r\nlet month = today?.getMonth() + 1; // javascript에서는 1월을 0부터 계산해주기 떄문에 + 1을 해준다.\r\nconsole.log(month); // 3\r\n\r\nlet day = today?.getDate();\r\nconsole.log(day); // 6\r\n\r\nlet hour = today?.getHour();\r\nconsole.log(hour); // 현재 시간 추출\r\n\r\nlet minutes = today?.getMinutes();\r\nconsole.log(minutes); // 현재 분 추출\r\n\r\nlet seconds = today?.getSeconds();\r\nconsole.log(seconds); // 현재 초 추출\r\n```\r\n"},{"title":"javascript basic 3 math","description":"javascript 기초 3 Math 다뤄보기","category":"javascript","keyword":"javascript, Math","date":"2023-03-06","content":"\r\n# Javascript Math 메서드\r\n\r\n## 1. 소수점 표현\r\n\r\n```javascript\r\n// n = Number\r\nMath.ceil(n); // 올림\r\nMath.floor(n); // 내림\r\nMath.round(n); // 반올림\r\nMath.toFixed(n); // 소수점 n의 자릿수까지 표현 / 매개변수가 없으면 1의자릿수 반환\r\n\r\n// .toFixed 예제\r\nlet num = 10.987654321;\r\n\r\nnum.toFixed(); // 11\r\nnum.toFixed(1); // 11.0\r\nnum.toFixed(2); // 10.99\r\nnum.toFixed(3); // 10.988\r\nnum.toFixed(4); // 10.9877\r\nnum.toFixed(5); // 10.98765\r\nnum.toFixed(10); // 10.9876543210\r\nnum.toFixed(14); // 10.98765432100000\r\n```\r\n\r\n## 2. 계산/정수 처리\r\n\r\n```javascript\r\nMath.abs(); // 절대값 반환\r\nMath.max(); // 인자 중 가장 큰 값 반환 ex. Math.max(1,2,3) - 3 , Math.max([4,5,6]) - 6\r\nMath.min(); // 인자 중 가장 작은 값 반환 - Math.max 반대\r\nMath.pow(x, y); // 인자간 거듭제곱 값 반환 === x**y와 동일\r\nMath.random(); // 0이상 1미만 랜덤값 반환\r\nMath.sqrt(); // 제곱근 반환\r\n```\r\n"},{"title":"javascript basic 4 array 1","description":"javascript 기초 4 배열 다루기 - 1","category":"javascript","keyword":"javascript, 배열","date":"2023-03-06","content":"\r\n# JavaScript 배열 다뤄보기\r\n\r\n## 1. 배열 수정\r\n\r\n```javascript\r\nlet Arr = [1, 2, 3, 4, 5];\r\n\r\n// Arr배열의 0번째를 123으로 수정\r\nArr[0] = 123; // Arr = [123,2,3,4,5]\r\n```\r\n\r\n## 2. 배열 정렬 (Array.sort())\r\n\r\narray.sort()는 매개변수가 입력되지 않으면 유니코드 순서에 따라 정렬된다.\r\n\r\n또한 sort()는 원본 array를 참조하기 때문에 sort()를 통한 정렬은 원본 array도 동일하게 변경된다.\r\n\r\n### 숫자 배열 정렬\r\n\r\n```javascript\r\nlet arr = [1, 3, 2, 4];\r\n\r\narr.sort(); // [1,2,3,4]\r\narr.sort((a, b) =\u003e a - b); // [1,2,3,4]\r\narr.sort((a, b) =\u003e b - a); // [4,3,2,1]\r\n```\r\n\r\n### 문자 배열 정렬 (대소문자 구분x)\r\n\r\n```javascript\r\nlet arr3 = [\"jon\", \"awre\", \"gwgw\", \"zgfzg\"];\r\n\r\n// 오름차순\r\narr.sort(function (a, b) {\r\n  const upperCaseA = a.toUpperCase();\r\n  const upperCaseB = b.toUpperCase();\r\n\r\n  if (upperCaseA \u003e upperCaseB) return 1;\r\n  if (upperCaseA \u003c upperCaseB) return -1;\r\n  if (upperCaseA === upperCaseB) return 0;\r\n}); // ['awre', 'gwgw', 'jon', 'zgfzg']\r\n\r\n// 내림차순\r\narr.sort(function (a, b) {\r\n  const upperCaseA = a.toUpperCase();\r\n  const upperCaseB = b.toUpperCase();\r\n\r\n  if (upperCaseA \u003c upperCaseB) return 1;\r\n  if (upperCaseA \u003e upperCaseB) return -1;\r\n  if (upperCaseA === upperCaseB) return 0;\r\n}); // ['zgfzg', 'jon', 'gwgw', 'awre']\r\n```\r\n\r\n### 영어가 아닌 한글 등의 문자 정렬\r\n\r\n```javascript\r\nlet arr = [\"가\", \"나\", \"바\", \"다\"];\r\n\r\narr1.sort((a, b) =\u003e a.localeCompare(b)); // ['가', '나', '다', '바']\r\narr1.sort((a, b) =\u003e b.localeCompare(a)); // ['바', '다', '나', '가']\r\n```\r\n\r\n## 3. 배열 메서드\r\n\r\n```javascript\r\n\r\nlet Arr = [1,2,3,4,5]\r\n\r\n    // 배열의 마지막에 새로운 요소를 추가 / 변경된 배열의 길이를 반환\r\nArr.push(12) // Arr = [1,2,3,4,5,12] / 6\r\n\r\n\t// 배열의 마지막 요소를 제거 / 한 후, 제거한 요소를 반환\r\n   .pop() // Arr = [1,2,3,4] / 5\r\n\r\n   // 배열의 첫 번째 자리에 새로운 요소를 추가/ 변경된 배열의 길이를 반환\r\n   .unshift(12) // Arr = [12,1,2,3,4,5] / 6\r\n\r\n   // 배열의 첫 번째 요소를 제거 /  제거한 요소를 반환\r\n   .shift() // Arr = [2,3,4,5] / 1\r\n\r\n   // 배열의 1번째 index부터 2개 원소 제거\r\n   .splice(1, 2) // Arr = [1, 4, 5] / [2, 3] 제거됨\r\n\r\n   // 배열 반전\r\n   .reverse() 배열 반전 // [5,4,3,2,1]\r\n\r\n   // 배열 계산\r\n   //Arr.reduce((이전결과, 현재요소)=\u003e이전결과+현재요소, 초기값)\r\n   // 초기값이 없는 경우 acc = Arr[0] , cur = Arr[1] 이 된다.\r\n   .reduce((acc,cur)=\u003eacc+cur) 배열 계산 // 15\r\n\r\n    // 배열 추출\r\n    // .slice(x, y) x이상 y미만 index에 해당하는 배열 추출\r\n    // 매개변수가 x밖에 없다면 x 이상 index에 해당하는 배열 추출\r\n    // 매개변수가 음수인 경우 ex. (-2) 라면, 배열 끝에서 2번째 index 이상의 배열 추출\r\n    .slice(0, 2) // [1,2]\r\n\r\n```\r\n"},{"title":"javascript basic 4 array 2","description":"javascript 기초 4 배열 다루기 - 2","category":"javascript","keyword":"javascript, 배열","date":"2023-03-06","content":"\r\n# 고차함수와 메서드를 통해 JavaScript 배열 다뤄보기\r\n\r\n## 고차함수란?\r\n\r\n\u003e 함수를 인자로 받거나, 함수를 반환함으로써 작동하는 함수로, .map() , .filter() , .forEach() , .reduce() 등이 있다.\r\n\r\n### 참고\r\n\r\n아래의 메서드들은 모두 원본 배열에 영향을 주지 않는다.\r\n\r\n또한 함수 안의 화살표 함수 arr.filter/map/...((element)=\u003e(element\u003e2)) 와 같이 괄호()를 이용하면 return을 해줄 필요가 없지만, arr.filter/map/...((element)=\u003e{return element \u003e 2}) 처럼 중괄호를 사용하면 return을 꼭 해줘야 한다.\r\n\r\n### Array.filter()\r\n\r\n특정 조건을 부합하는 값만 모아서 새로운 배열을 만들어준다.\r\n\r\n```javascript\r\n// ex\r\nconst arr = [\"a\", \"b\", \"b\", \"c\"];\r\nconst filtered = arr.filter(element =\u003e element != \"b\"); // arr의 원소는 b가 아닌 값으로 거른다.\r\nconsole.log(arr); // ['a', 'b', 'b', 'c']\r\nconsole.log(filtered); // ['a', 'c']\r\n\r\nconst arr_num = [0, 1, 2, 3, 4, 5];\r\nconst new_array = arr_num.filter(element =\u003e element \u003e 3); // arr_num의 원소는 3을 초과한다\r\nconsole.log(new_array); // [ 4, 5 ]\r\n```\r\n\r\n### Array.map()\r\n\r\n반복문처럼 사용 가능. 원본 배열을 흐트러뜨리지 않고, 새로운 배열을 반환한다.\r\n\r\n단, key 값 같은 경우에는 값이 재할당되기 때문에 원본과 비교하는 의미가 없다. (ex. 리액트 사용 시)\r\n\r\n```javascript\r\nconst array_num = [0, 1, 2, 3, 4, 5]; // arr_n은 상수이지만\r\nconst new_arr_num = array_num.map(\r\n  element =\u003e element * 10, // 요렇게 map으로 *10을 돌려주면\r\n);\r\nconsole.log(new_arr_num); // [ 0, 10, 20, 30, 40, 50 ] // 원본 배열 변경 없이 새 배열이 잘 만들어진다.\r\n```\r\n\r\n### Array.concat()\r\n\r\n두 배열을 합친다. 단, 중복 제거는 하지 않는다.\r\n\r\n```javascript\r\nconst array_num = [0, 1, 2, 3, 4, 5];\r\nconst new_array = [4, 5];\r\nconst merge = array_num.concat(new_array);\r\nconsole.log(merge); // [0, 1, 2, 3, 4, 5, 4, 5]\r\n```\r\n\r\n### Array.from()\r\n\r\n배열로 만들어준다.\r\n\r\n```javascript\r\nconst my_name = \"vihan9\";\r\nconst my_name_array = Array.from(my_name);\r\nconsole.log(my_name_array); // [ 'v', 'i', 'h', 'a', 'n', '9' ]\r\n\r\n// 조건을 넣어 배열을 만들고 싶다면? ex\r\nconst my_name_array = Array.from({ length: 4 }, (item, index) =\u003e index);\r\nconsole.log(my_name_array); // [ 0, 1, 2, 3 ] // length가 4인 배열을 만들어준다.\r\n\r\n// 어떤 배열을 index 값 배열로 바꾸고 싶다면? ex\r\nconst my_name = \"vihan9\";\r\nconst num_array = Array.from(my_name, (item, index) =\u003e index);\r\nconsole.log(num_array); // [ 0, 1, 2, 3, 4, 5 ]\r\n```\r\n\r\n### Array.find()\r\n\r\n숫자열 배열의 특정 값을 찾아주며, 조건에 맞는 첫 번째 값을 호출해준다.\r\n\r\n```javascript\r\nconst arr_num = [0, 1, 2, 3, 4, 5];\r\nconst find_num = arr_num.find(v =\u003e v \u003e 3);\r\nconsole.log(find_num); // 4 // 3을 초과하는 첫 값인 4를 출력한다.\r\n```\r\n\r\n### indexOf()\r\n\r\n배열에서 지정된 요소를 찾을 수 있는 첫 번째 반환하고, 존재하지 않으면 -1을 반환한다.\r\n\r\n```javascript\r\nconst comment = \"오늘도 오류 없는 하루가 되게 해주세요\";\r\nconst searchStr = \"오류\";\r\nconst searchStr2 = \"해주세요\";\r\n\r\nconst indexOfFirst = comment.indexOf(searchStr);\r\nconst indexOfFirst2 = comment.indexOf(searchStr2);\r\n\r\nconsole.log(indexOfFirst); // 4 // 오류는 4번째 인덱스부터 시작한다.\r\nconsole.log(indexOfFirst2); // 17 // 해주세요는 17번째 인덱스부터 시작한다.\r\n```\r\n"},{"title":"javascript basic 5 loop","description":"javascript 기초 5 반복문 다루기","category":"javascript","keyword":"javascript, 반복문","date":"2023-03-06","content":"\r\n# for문 사용법\r\n\r\n## for문\r\n\r\n```javascript\r\n\r\nconst arr = [1,2,3,4,5,6,7,8,9,10];\r\n\r\nconst newArr = []\r\n (초기값(i=0) ; 조건(i가 10 미만까지 반복) ; 증감문(i는 1씩 증가한다.))\r\nfor(let i = 0;i\u003carr.length;i++){\r\n    newArr.push(arr[i])\r\n}\r\n// console.log\r\n[\r\n  1, 2, 3, 4,  5,\r\n  6, 7, 8, 9, 10\r\n]\r\n\r\n// 원한다면 조건문을 통해 반복 중단 가능\r\nfor(~~){\r\n\tif(a===b){\r\n    \tbraek\r\n    }\r\n}\r\n\r\n// for문은 i를 통해 반복할 횟수를 설정하여 원하는 반복작업을 // 실행하게 해준다.\r\n\r\n```\r\n\r\n## for ~ of\r\n\r\n```javascript\r\nlet test1 = [1, 2, 3, 4, 5];\r\n\r\nlet test2 = [4, 5, 6, 7, 8];\r\n\r\n// test1 배열 안의 모든 요소를 순회\r\nfor (const items of test1) {\r\n  test2.push(items);\r\n}\r\nconsole.log(test2); // [4, 5, 6, 7, 8, 1, 2, 3, 4, 5]\r\n```\r\n\r\n## for ~~ in\r\n\r\n```javascript\r\nconst obj = { a: 1, b: 2, c: 3 };\r\n\r\n// 오브젝트 안의 모든 객체 순회\r\nfor (const property in obj) {\r\n  console.log(`${property}: ${obj[property]}`);\r\n}\r\n\r\n// \"a: 1\"\r\n// \"b: 2\"\r\n// \"c: 3\"\r\n```\r\n\r\n## while\r\n\r\nwhile문의 첫 괄호() 안의 값이 true인 경우 반복해서 실행된다.\r\n\r\n```javascript\r\nlet n = 0;\r\n\r\n// n이 3 미만인 경우는 반복하여 실행\r\nwhile (n \u003c 3) {\r\n  n++;\r\n}\r\n\r\nconsole.log(n); // 3\r\n```\r\n\r\n# 배열 메서드 반복문처럼 사용하기\r\n\r\n## Array.forEach()\r\n\r\nforEach 메서드는 주어진 함수를 배열 요소 각각에 대해 실행한다.\r\n\r\n```javascript\r\n\r\nconst arr = [1,2,3,4,5,6,7,8,9,10];\r\n\r\n// element라는 이름은 중요하지 않다. 상황에 맞는 이름을 사용하는 것이 중요하다.\r\narr.forEach((element)=\u003econsole.log(element));\r\n\r\n// console.log\r\n1 2 3 4 5 6 7 8 9 10\r\n\r\n// 간단 예제\r\n\r\narr.forEach((element)=\u003econsole.log(element*10)); // 10 20 30 40 --- 80 90 100\r\n\r\n// for문처럼 화살표 함수 오른쪽 부분에 push 등과 같은 메서드를 통해 새 배열을 만들어줄 수도 있다.\r\nconst newArr = [];\r\narr.forEach((item)=\u003e{newArr.push(item)});\r\n// newArr =\r\n[\r\n  1, 2, 3, 4,  5,\r\n  6, 7, 8, 9, 10\r\n]\r\n\r\n```\r\n\r\n## .map()\r\n\r\nforEach와 유사하게 배열 안의 각 요소들에게 콜백 함수를 적용시킨다.\r\n\r\n```javascript\r\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n\r\nlet ex = arr.map(item =\u003e item * 10)[\r\n  //console.log(ex)\r\n  (10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\r\n];\r\n\r\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n\r\nlet ex = arr.map((item, index) =\u003e item * 10 + `(${index}번째)`)[\r\n  //console.log(ex)\r\n  (\"10(0번째)\",\r\n  \"20(1번째)\",\r\n  \"30(2번째)\",\r\n  \"40(3번째)\",\r\n  \"50(4번째)\",\r\n  \"60(5번째)\",\r\n  \"70(6번째)\",\r\n  \"80(7번째)\",\r\n  \"90(8번째)\",\r\n  \"100(9번째)\")\r\n];\r\n```\r\n"},{"title":"nestjs custom repository","description":"Entityrepository()를 대신한 Repository 생성","category":"nestjs","keyword":"nestjs, repository","date":"2023-03-04","content":"\r\n## 포스팅 시점 nestjs 버전 : 9.x.x\r\n\r\n새로운 토이 프로젝트를 만들면서 백엔드를 구축할 프레임워크로 nestjs를 이용하기로 마음먹었다.\r\n\r\n원래 사용하고 있던 javascript/typescript와 동일한 언어를 사용하기 때문에 백엔드 구축에 비교적 진입장벽이 낮다고 생각했기 때문에다.\r\n\r\n# nest 작동순서\r\n\r\nrequest -\u003e controller -\u003e service -\u003e controller -\u003e response 순으로 작동하나, DB와 관련된 일을 시키기 위해서는 repository를 생성해야한다고 한다. 즉,\r\n\r\nrequest -\u003e controller -\u003e service -\u003e repo\\* -\u003e service -\u003e controller -\u003e response\r\n로 한 단계가 추가된다. (Repostitory pattern)\r\n\r\n@EntityRepository를 통해 레포지토리를 설정해주는 방식이 많이 보였지만\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlkldE%2FbtrUQbTjKZA%2FA6hFzyRy8SsueBbUk8cTA1%2Fimg.png)\r\n\r\n현재 버전에서는 사용할 수 없어 다른 방법을 알아봤다.\r\n\r\n## 기본 설정\r\n\r\nconfig 설정\r\n\r\n```typescript\r\n// src/configs/typeorm.configs.ts\r\n\r\nexport const typeORMConfig: TypeOrmModuleOptions = {\r\n  // Database Type\r\n  type: \"postgres\", // 본인은 pg를 사용\r\n  host: \"localhost\",\r\n  port: 5432,\r\n  username: \"postgres\",\r\n  password: \"password\",\r\n  database: \"database\",\r\n  entities: [__dirname + \"/../**/*.entity.{js,ts}\"], // 해당 경로 + 엔티티이름.entity.{js.ts}로 된 엔티티를 이용\r\n  // autoLoadEntities: true, // 위와 다르게 entity들 알아서 찾아줌\r\n  synchronize: true, // @@@@@@@@ 배포할때 true 사용 시 데이터 삭제될 수 있음. production 단계에서는 필히 false로 해줄 것 권장 @@@@@@\r\n};\r\n```\r\n\r\nconfig 설정 후 root 모듈에 import\r\n\r\n```typescript\r\n// app.module.ts\r\n\r\nimport { Module } from \"@nestjs/common\";\r\nimport { AppController } from \"./app.controller\";\r\nimport { PostlistModule } from \"./postlist/postlist.module\";\r\nimport { typeORMConfig } from \"./configs/typeorm.configs\";\r\nimport { TypeOrmModule } from \"@nestjs/typeorm/dist\";\r\n\r\n@Module({\r\n  imports: [TypeOrmModule.forRoot(typeORMConfig), PostlistModule],\r\n  controllers: [AppController],\r\n  providers: [],\r\n})\r\nexport class AppModule {}\r\n```\r\n\r\nentity 생성\r\n\r\n```typescript\r\n// src/postlist/entities/postlist.entity.ts\r\n\r\nimport { BaseEntity, Column, PrimaryGeneratedColumn, Entity } from \"typeorm\";\r\n\r\n@Entity()\r\nexport class Postlist extends BaseEntity {\r\n  @PrimaryGeneratedColumn()\r\n  id: number;\r\n\r\n  @Column()\r\n  title: string;\r\n\r\n  @Column()\r\n  content: string;\r\n\r\n  @Column()\r\n  nickname: string;\r\n\r\n  @Column()\r\n  imageUrl?: string;\r\n}\r\n```\r\n\r\n\u003e config 설정 시 entities에 이름을 ~~.entity.{js.ts} 로 설정해놓고, 정작 entity 파일 이름을 설정한 형식과 다르게 작성하면 [EntityMetadataNotFound] 에러를 띄우게 되기 때문에 설정한대로 이름을 지어줘야 한다.\r\n\r\n참조 : https://github.com/typeorm/typeorm/issues/1327\r\n\r\n## custumRepository 만들기\r\n\r\n본인은 src에 database 디렉토리를 만들어, 데코레이터와 모듈을 그 안에 넣어줬다.\r\n\r\n```typescript\r\n// src/database/typeorm-ex.decorator.ts\r\n\r\nimport { SetMetadata } from \"@nestjs/common\";\r\n\r\nexport const TYPEORM_EX_CUSTOM_REPOSITORY = \"TYPEORM_EX_CUSTOM_REPOSITORY\";\r\n\r\nexport function CustomRepository(entity: Function): ClassDecorator {\r\n  return SetMetadata(TYPEORM_EX_CUSTOM_REPOSITORY, entity);\r\n}\r\n\r\n// typeorm-ex.module.ts\r\n\r\nimport { DynamicModule, Provider } from \"@nestjs/common\";\r\nimport { getDataSourceToken } from \"@nestjs/typeorm\";\r\nimport { DataSource } from \"typeorm\";\r\nimport { TYPEORM_EX_CUSTOM_REPOSITORY } from \"./typeorm-ex.decorator\";\r\n\r\nexport class TypeOrmExModule {\r\n  public static forCustomRepository\u003cT extends new (...args: any[]) =\u003e any\u003e(\r\n    repositories: T[],\r\n  ): DynamicModule {\r\n    const providers: Provider[] = [];\r\n\r\n    for (const repository of repositories) {\r\n      const entity = Reflect.getMetadata(\r\n        TYPEORM_EX_CUSTOM_REPOSITORY,\r\n        repository,\r\n      );\r\n\r\n      if (!entity) {\r\n        continue;\r\n      }\r\n\r\n      providers.push({\r\n        inject: [getDataSourceToken()],\r\n        provide: repository,\r\n        useFactory: (dataSource: DataSource): typeof repository =\u003e {\r\n          const baseRepository = dataSource.getRepository\u003cany\u003e(entity);\r\n          return new repository(\r\n            baseRepository.target,\r\n            baseRepository.manager,\r\n            baseRepository.queryRunner,\r\n          );\r\n        },\r\n      });\r\n    }\r\n\r\n    return {\r\n      exports: providers,\r\n      module: TypeOrmExModule,\r\n      providers,\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n## 사용할 repository 생성\r\n\r\n```typescript\r\n// src/postlist/repository/postlist.repository.ts\r\n\r\nimport { CustomRepository } from \"src/database/typeorm-ex.decorator\";\r\nimport { Repository } from \"typeorm\";\r\nimport { Postlist } from \"../entities/postlist.entity\";\r\n\r\n@CustomRepository(Postlist)\r\nexport class PostlistRepository extends Repository\u003cPostlist\u003e {}\r\n```\r\n\r\n## module에 생성한 repository import\r\n\r\n```typescript\r\n// src/postlist/postlist.module.ts\r\n\r\nimport { Module } from \"@nestjs/common\";\r\nimport { PostlistController } from \"./postlist.controller\";\r\nimport { PostlistService } from \"./postlist.service\";\r\nimport { PostlistRepository } from \"./repository/postlist.repository\";\r\nimport { TypeOrmExModule } from \"src/database/typeorm-ex.module\";\r\n\r\n@Module({\r\n  imports: [TypeOrmExModule.forCustomRepository([PostlistRepository])],\r\n  controllers: [PostlistController],\r\n  providers: [PostlistService],\r\n})\r\nexport class PostlistModule {}\r\n```\r\n\r\n### Module에 import 후 service 비즈니스 로직에만 repository를 넣어주면 된다.\r\n\r\n```typescript\r\n// src/postlist/postlist.service.ts\r\n\r\nimport { Injectable, NotFoundException } from \"@nestjs/common\";\r\nimport { UpdatePostDto } from \"./dto/update-postlist.dto\";\r\n\r\nimport { PostlistRepository } from \"./repository/postlist.repository\";\r\nimport { Postlist } from \"./entities/postlist.entity\";\r\nimport { CreatePostDto } from \"./dto/create-postlist.dto\";\r\n\r\n@Injectable()\r\nexport class PostlistService {\r\n  constructor(private readonly postlistRepository: PostlistRepository) {}\r\n\r\n  async getAllPost(): Promise\u003cPostlist[]\u003e {\r\n    const found = await this.postlistRepository.find();\r\n    return found;\r\n  }\r\n\r\n  async getPostById(id: number): Promise\u003cPostlist\u003e {\r\n    const found = await this.postlistRepository.findOne({ where: { id: id } });\r\n    if (!found) {\r\n      throw new NotFoundException(`Cannot find post with id ${id}`);\r\n    }\r\n    return found;\r\n  }\r\n}\r\n\r\n// src/postlist/postlist.controller.ts\r\n\r\nimport { Body, Controller, Get, Param, Patch, Post } from \"@nestjs/common\";\r\nimport { CreatePostDto } from \"./dto/create-postlist.dto\";\r\nimport { PostlistService } from \"./postlist.service\";\r\nimport { UpdatePostDto } from \"./dto/update-postlist.dto\";\r\nimport { Delete } from \"@nestjs/common/decorators\";\r\nimport { Postlist } from \"./entities/postlist.entity\";\r\n\r\n@Controller(\"postlist\")\r\nexport class PostlistController {\r\n  constructor(readonly postlistService: PostlistService) {}\r\n\r\n  @Post()\r\n  createOne(@Body() createPostDto: CreatePostDto): Promise\u003cPostlist\u003e {\r\n    return this.postlistService.createPost(createPostDto);\r\n  }\r\n\r\n  @Get()\r\n  getAll(): Promise\u003cPostlist[]\u003e {\r\n    return this.postlistService.getAllPost();\r\n  }\r\n\r\n  @Get(\":id\")\r\n  getOne(@Param(\"id\") id: number): Promise\u003cPostlist\u003e {\r\n    return this.postlistService.getPostById(id);\r\n  }\r\n\r\n  @Patch(\":id\")\r\n  updateOne(\r\n    @Param(\"id\") id: number,\r\n    @Body() updateData: UpdatePostDto,\r\n  ): Promise\u003cPostlist\u003e {\r\n    return this.postlistService.updatePost(id, updateData);\r\n  }\r\n\r\n  @Delete(\":id\")\r\n  deleteOne(@Param(\"id\") id: number): Promise\u003cvoid\u003e {\r\n    return this.postlistService.deletePost(id);\r\n  }\r\n}\r\n```\r\n\r\n필요한 로직을 설정한 후 postman을 작동시켜주면 정상적으로 실행되는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbMxspb%2FbtrUIZG6vWP%2F0dVetFuaUfkfuI9EXCKeN0%2Fimg.png)\r\n\r\nnextjs와 동시에 작업하기 위해 nestjs 포트를 3001로 설정했지만, 보통은 nest 설치 시 app에 3000으로 설정된다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcOfHG5%2FbtrUOQBYHjX%2FoGOqOJtiF2KbPiyKu9JCdK%2Fimg.png)\r\n\r\nDB는 postgreSQL을 이용했다.\r\n정상적으로 테이블에 있는 데이터가 추출되는 것이 잘 확인된다.\r\n\r\n### 참고 :\r\n\r\nhttps://orkhan.gitbook.io/typeorm/readme_ko\r\n\r\nhttps://docs.nestjs.com/techniques/database\r\n"},{"title":"nextjs loading","description":"nextjs에서의 로딩처리","category":"nextjs","keyword":"nextjs, loading","date":"2023-03-04","content":"\r\n# Nextjs에서 로딩처리하기\r\n\r\n### 모든 페이지를 미리 렌더링하는 NextJS 특성상, 다른 페이지로 라우팅이 진행될때, 사용자는 가만히 멈춰있는 화면을 보게될 수 있다. 때문에 페이지 전환을 정지화면으로 두지 않기 위해 로딩 처리를 구현해볼 수 있다.\r\n\r\n## 로딩 스피너 세팅\r\n\r\n```typescript\r\n// _app.tsx\r\n\r\n// 미리 만들어놓은 로딩 훅과 로딩 스피너\r\nimport { useLoading } from \"src/hooks/useLoading\";\r\nimport { LoadingSpinner } from \"src/components/videos/video/LoadingSpinner\";\r\n\r\n\u003cLayout\u003e\r\n  {isLoading ? \u003cLoadingSpinner /\u003e : null}\r\n  \u003cComponent {...pageProps} /\u003e\r\n\u003c/Layout\u003e;\r\n```\r\n\r\n로딩스피너는 CSS로 만들어도 좋고, SVG나 GIF, 라이브러리 등 자유롭게 적용해도 좋다.\r\n\r\n## 라우팅 시 적용될 이벤트 설정\r\n\r\n```typescript\r\n// useLoading.ts\r\n\r\nimport Router from \"next/router\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\nexport const useLoading = () =\u003e {\r\n  const [nowLoading, setNowLoading] = useState\u003cboolean\u003e(false);\r\n  useEffect(() =\u003e {\r\n    const start = () =\u003e {\r\n      setNowLoading(true);\r\n    };\r\n    const end = () =\u003e {\r\n      setNowLoading(false);\r\n    };\r\n    Router.events.on(\"routeChangeStart\", start);\r\n    Router.events.on(\"routeChangeComplete\", end);\r\n    Router.events.on(\"routeChangeError\", end);\r\n    return () =\u003e {\r\n      Router.events.off(\"routeChangeStart\", start);\r\n      Router.events.off(\"routeChangeComplete\", end);\r\n      Router.events.off(\"routeChangeError\", end);\r\n    };\r\n  }, []);\r\n\r\n  return nowLoading ? true : false;\r\n};\r\n```\r\n\r\n- routeChangeStart(url, { shallow }) - 라우트가 변경되기 시작할때 트리거됨.\r\n\r\n- routeChangeComplete(url, { shallow }) - 라우트가 완전히 변경되었을 때 트리거됨.\r\n\r\n- routeChangeError(err, url, { shallow }) - 라우트 변경 중에 에러가 발생했거나, 취소되었을 때 트리거됨.\r\n\r\n\\_app.tsx(jsx)에 로딩 스피너나 로딩 페이지를 적용해 놓으면,\r\n\r\n라우팅으로 인한 페이지 이동이 일어날 때마다 원하는 로딩 창을 호출해줄 수 있다.\r\n\r\n## 적용된 페이지\r\n\r\n![image](https://blog.kakaocdn.net/dn/cWz72g/btrSmvngm4A/hgKg4FviDpAqQk5U6kGHXK/img.gif)\r\n"},{"title":"nextjs react responsive","description":"nextjs에 react responsive 적용하기","category":"nextjs","keyword":"responseive, UI","date":"2023-03-04","content":"\r\n### 이번에 새로 만들고 있는 토이 프로젝트를 작업하던 중, 모바일 화면일때만 화면을 보여주고 싶었다. 단, 모든 컴포넌트에 미디어쿼리를 통해 작성해줄 수는 없기에 react-responsive를 적용해 화면이 481px을 넘어가면 고정된 페이지를 보여줄 수 있도록 코드를 작성했다.\r\n\r\n## react-responsive 설치\r\n\r\n```bash\r\nyarn add react-responsive\r\n```\r\n\r\n## hook 설정\r\n\r\n```typescript\r\n// hook\r\n// useMideaQuery.tsx\r\nexport const Desktop = ({ children }: any) =\u003e {\r\n  const isDesktop = useMediaQuery({\r\n    minWidth: 481,\r\n  });\r\n  return isDesktop ? children : null;\r\n};\r\n\r\nexport const Mobile = ({ children }: any) =\u003e {\r\n  const isMobile = useMediaQuery({\r\n    minWidth: 481,\r\n  });\r\n  return Mobile ? children : null;\r\n};\r\n```\r\n\r\n## \\_app.ts 적용\r\n\r\n```typescript\r\n// _app.tsx\r\n\r\n// ...\r\nimport { Mobile } from \"src/hooks/useMideaQuery\";\r\nimport { CannotDesktop } from \"src/desktop/CannotDesktop\";\r\n\r\n\u003c\u003e\r\n  \u003cMobile\u003e\r\n    \u003cLayout\u003e\r\n      {isLoading ? \u003cLoadingSpinner /\u003e : null}\r\n      \u003cComponent {...pageProps} /\u003e\r\n    \u003c/Layout\u003e\r\n  \u003c/Mobile\u003e\r\n  \u003cDesktop\u003e\r\n    \u003cCannotDesktop /\u003e\r\n  \u003c/Desktop\u003e\r\n\u003c/\u003e;\r\n```\r\n\r\n똑같은 코드로 리액트 코드에 적용할 때는 문제가 없었지만, Nextjs를 이용한 이번 상황의 경우 Hydration 에러가 발생했다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbjYUXg%2FbtrTRCeaovE%2FwQr4OZdJectnkkG06XmTEk%2Fimg.png)\r\n\r\nvercel로 배포할 때는 정상적으로 빌드되기는 했지만\r\n\r\n로컬에서 작업할때 지속적으로 발생하는 오류 메세지 창이 불편하기도 하여 바로 처리해봤다.\r\n\r\n\u003e Hydration failed because the initial UI does not match what was rendered on the server\r\n\r\n초기 UI가 서버에서 렌더링된 것과 일치하지 않는다고 한다.\r\n\r\nhttps://nextjs.org/docs/messages/react-hydration-error\r\n\r\n공식 페이지를 보면 \"애플리케이션을 렌더링하는 동안 미리 렌더링된 React 트리(SSR/SSG)와 브라우저에서 첫 번째 렌더링 중에 렌더링된 React 트리 간에 차이가 있었기 때문에 발생한 오류\"라고 한다.\r\n\r\n일반적으로 이 문제는 사전 렌더링과 브라우저 간에 다를 수 있는 항목에 의존하는 특정 라리브러리 또는 애플리케이션 코드를 사용하여 발생한다고 하는데,\r\n\r\n나의 경우, react-responsive에 의한 경우였다.\r\n\r\n## 코드 수정\r\n\r\n```typescript\r\n// useMideaQuery.tsx\r\n\r\nimport { useEffect, useState } from \"react\";\r\nimport { useMediaQuery } from \"react-responsive\";\r\n\r\nexport const Mobile = () =\u003e {\r\n  const [mobile, setMobile] = useState\u003cboolean\u003e(false);\r\n  const isMobile = useMediaQuery({ maxWidth: 480 });\r\n\r\n  const checkResize = () =\u003e {\r\n    if (isMobile) {\r\n      setMobile(true);\r\n    } else {\r\n      setMobile(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() =\u003e {\r\n    checkResize();\r\n  }, [isMobile]);\r\n\r\n  return mobile;\r\n};\r\n//_app.tsx\r\n\r\n\u003cRecoilRoot\u003e\r\n  {isMobile ? (\r\n    \u003cLayout\u003e\r\n      {isLoading ? \u003cLoadingSpinner /\u003e : null}\r\n      \u003cComponent {...pageProps} /\u003e\r\n    \u003c/Layout\u003e\r\n  ) : (\r\n    \u003cCannotDesktop /\u003e\r\n  )}\r\n\u003c/RecoilRoot\u003e;\r\n```\r\n\r\nuseMideaQuery가 window 화면을 기준으로 동작하기 때문에,\r\n\r\n공식문서의 예제와 비슷하게 useState를 통한 boolean 값으로 화면을 노출시켜줬다.\r\n\r\n위의 방식을 적용하니 hydration 에러 없이 잘 작동하는 모습을 볼 수 있었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdH0CZg%2FbtrTRp0izJZ%2FiolwpQXLvGOommEBhpCkaK%2Fimg.png)\r\n"},{"title":"redux mock server","description":"postman을 이용해 redux Mock server(json-server) 사용해보기","category":"redux","keyword":"redux, mock server","date":"2023-03-04","content":"\r\n### React를 사용하면서 서버와 연결 전, Post Man을 통해 임시로 서버를 연결해 React와 소통하는 데이터와 view가 어떻게 처리되는지 확인하고 싶을때 사용해볼 수 있다.\r\n\r\npostman 링크 : https://www.postman.com/\r\n\r\n## json-server 설치\r\n\r\n```bash\r\nyarn add json-server\r\n```\r\n\r\n위 명령어 입력 시 db.json 파일이 자동으로 생성된다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fle0HO%2FbtrMjcfRkOG%2FPMsBpdgzHf6545oXRlN8BK%2Fimg.png)\r\n\r\n설치가 완료된 후 아래의 명령어를 입력하면 json server가 실행된다.\r\n\r\n## json-server 실행\r\n\r\n```bash\r\nyarn json-server --watch db.json --port 3001\r\n```\r\n\r\n\u003e json-server를 설치해줄때 생성된 db.json 파일을 실행하는데, 3001번 포트를 사용한다는 의미이다. 포트를 설정해주지 않으면 기본값은 3000이다.\r\n\r\n\u003e 보통 React를 로컬로 실행시킬때의 포트도 3000이기 때문에 3001번으로 열어줬다. 포트번호는 3001이든 4000이든 5000이든 사용하고 있는 포트번호만 아니면 된다.\r\n\r\n## postman 사용\r\n\r\n이제 임시 DB를 사용하고 있기 때문에 Post Man을 설치하거나, 웹에 로그인을 한 후, json-server가 실행된 상태로 post man에 적용하고자 하는 url을 입력해주면 GET, POST, PUT, DELETE 등 다양한 요청을 처리할 수 있게 된다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fl4yDj%2FbtrMkdzirLp%2FweLBKktEnHFX5QcT4NHTK1%2Fimg.png)\r\n\r\n사용되는 url은 db.json에 있는 목록명을 기준으로 적용된다.\r\n\r\n```javascript\r\n\r\n// ex\r\n\r\n{\r\n  \"comments\": [\r\n    {\r\n      \"id\": 1,\r\n      \"profile_url\": \"https://picsum.photos/id/1/50/50\",\r\n      \"author\": \"abc_1\",\r\n      \"content\": \"UI 테스트는 어떻게 진행하나요\",\r\n      \"createdAt\": \"2022-03-01\"\r\n    },\r\n    {\r\n      \"id\": 2,\r\n      \"profile_url\": \"https://picsum.photos/id/2/50/50\",\r\n      \"author\": \"abc_2\",\r\n      \"content\": \"막히면 대답은 빨리 해주나요\",\r\n      \"createdAt\": \"2022-03-02\"\r\n    },\r\n  ],\r\n  \"post\": [\r\n    {\r\n      \"id\": 1,\r\n      \"author\": \"abc_1\",\r\n      \"content\": \"UI 테스트는 어떻게 진행하나요\",\r\n      \"createdAt\": \"2022-03-01\"\r\n    }\r\n    {\r\n      \"id\": 2,\r\n      \"author\": \"abc_2\",\r\n      \"content\": \"막히면 대답은 빨리 해주나요\",\r\n      \"createdAt\": \"2022-03-01\"\r\n    }\r\n  ]\r\n}\r\n\r\n```\r\n\r\n예를 들어 db.json이 위와 같이 돼있는 상태라면\r\n\r\n### http://localhost:3001/post - post 데이터\r\n\r\n1. GET : http://localhost:3001/post - 전체 post 목록 불러오기\r\n2. GET : http://localhost:3001/post/1 - id가 1인 post 불러오기\r\n3. POST : http://localhost:3001/post - 새 post 생성(저장)\r\n4. PUT : http://localhost:3001/post/1 - id가 1인 post 수정하기\r\n5. DELETE : http://localhost:3001/post/1 - id가 1인 post 삭제하기\r\n\r\n### http://localhost:3001/comments - comments 데이터\r\n\r\n1. GET : http://localhost:3001/comments - 전체 comments 목록 불러오기\r\n2. GET : http://localhost:3001/comments/1 - id가 1인 comments 불러오기\r\n3. POST : http://localhost:3001/comments - 새 comments 생성(저장)\r\n4. PUT : http://localhost:3001/comments/1 - id가 1인 comments 수정하기\r\n5. DELETE : http://localhost:3001/comments/1 - id가 1인 comments 삭제하기\r\n\r\n위와 같은 방식으로 기본적인 동작을 사용해볼 수 있고, header 값이나 body 값 설정 등 다양한 작업을 진행해볼 수 있다.\r\n\r\nRedux를 사용할때, 해당 데이터들을 추출하여 전역 상태로 관리해보는 등의 작업을 실행할 수 있다.\r\n"},{"title":"redux toolkit async thunk","description":"React reduxToolkit과 미들웨어 AsyncThunk 사용해보기","category":"redux","keyword":"redux, 미들웨어","date":"2023-03-04","content":"\r\n# ReduxToolkit\r\n\r\n리덕스 툴킷은 일반적인 리덕스보다 store 설정을 용이하게 해주고, 추가적인 패키지 설치가 필요하지 않게 설계되었으며, 보일러플레이트(여러 군데에서 반복되는 코드)를 최소화하기 위해 만들어졌다.\r\n\r\n더 사용하기 쉽다는 의미이다. 이번 글에서는 미들웨어인 AsyncThunk와 함께 사용하는 방법을 확인할 수 있다.\r\n\r\n## 1. 설치\r\n\r\n```bash\r\nyarn add @reduxjs/toolkit react-redux\r\n```\r\n\r\n## 2. store 생성\r\n\r\n```javascript\r\n// src/redux/store.js\r\n\r\nimport { configureStore } from \"@reduxjs/toolkit\";\r\nimport posts from \"./modules/postSlice\"; // 만들어줄 Slice\r\n\r\nconst store = configureStore({\r\n  reducer: {\r\n    posts,\r\n  },\r\n});\r\nexport default store;\r\n```\r\n\r\n## 3. 최상위 파일(index.js, App.js 등)에 Provider import해오기\r\n\r\n```javascript\r\n// import -- 기존 코드들 --\r\nimport { Provider } from \"react-redux\";\r\nimport store from \"./redux/store\";\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\r\nroot.render(\r\n  \u003cProvider store={store}\u003e\r\n    \u003cApp /\u003e\r\n  \u003c/Provider\u003e,\r\n);\r\n```\r\n\r\n## 4. 슬라이스 생성\r\n\r\n2번의 store에 import 해줄 파일이다.\r\n\r\n```javascript\r\n// postSlice.js\r\n\r\nimport { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\r\nimport axios from \"axios\";\r\n\r\nconst BASE_URL = \"http://localhost:3001\";\r\n\r\nconst initialState = {\r\n  // data, isLoading, error로 상태관리\r\n  posts: [],\r\n  isLoading: false,\r\n  error: null,\r\n};\r\n\r\nexport const getPosts = createAsyncThunk(\r\n  \"GET_ALL_Posts\",\r\n  async (payload, thunkAPI) =\u003e {\r\n    try {\r\n      const { data } = await axios.get(`${BASE_URL}/posts`);\r\n      return thunkAPI.fulfillWithValue(data);\r\n    } catch (error) {\r\n      return thunkAPI.rejectWithValue(error);\r\n    }\r\n  },\r\n);\r\n\r\nexport const addPosts = createAsyncThunk(\r\n  \"POST_Posts\",\r\n  async (payload, thunkAPI) =\u003e {\r\n    try {\r\n      const { data } = await axios.post(`${BASE_URL}/posts`, payload);\r\n      console.log(\"data\", data);\r\n      return thunkAPI.fulfillWithValue(data);\r\n    } catch (errer) {\r\n      return thunkAPI.rejectWithValue(errer);\r\n    }\r\n  },\r\n);\r\n\r\nexport const updatePosts = createAsyncThunk(\r\n  \"UPDATAE_Posts\",\r\n  async (payload, thunkAPI) =\u003e {\r\n    try {\r\n      console.log(payload);\r\n      const { data } = await axios.put(\r\n        `${BASE_URL}/posts/${payload.id}`,\r\n        payload,\r\n      );\r\n      console.log(\"data\", DataTransfer);\r\n      return thunkAPI.fulfillWithValue(data.data);\r\n    } catch (error) {\r\n      return thunkAPI.rejectWithValue(error);\r\n    }\r\n  },\r\n);\r\n\r\nexport const deletePosts = createAsyncThunk(\r\n  \"DELETE_posts\",\r\n  async (payload, thunkAPI) =\u003e {\r\n    try {\r\n      await axios.delete(`${BASE_URL}/posts/${payload}`);\r\n      return thunkAPI.fulfillWithValue(payload);\r\n    } catch (error) {\r\n      return thunkAPI.rejectWithValue(error);\r\n    }\r\n  },\r\n);\r\n\r\nexport const postsSlice = createSlice({\r\n  name: \"posts\",\r\n  initialState,\r\n  reducers: {},\r\n  extraReducers: {\r\n    /* Pending */\r\n    [getPosts.pending]: (state, action) =\u003e {\r\n      state.isLoading = true;\r\n    },\r\n    [addPosts.pending]: (state, action) =\u003e {\r\n      state.isLoading = true;\r\n    },\r\n    [deletePosts.pending]: (state, action) =\u003e {\r\n      state.isLoading = true;\r\n    },\r\n    /* Fulfilled */\r\n    [getPosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      console.log(action);\r\n      state.posts = [...action.payload];\r\n    },\r\n    [addPosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      state.posts.push(action.payload);\r\n    },\r\n    [updatePosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      console.log(action);\r\n      const newState = state.posts.map(item =\u003e\r\n        action.meta.arg.id === item.id\r\n          ? { ...item, content: action.meta.arg.content }\r\n          : item,\r\n      );\r\n      state.posts = newState;\r\n      return state;\r\n    },\r\n    [deletePosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      const newState = state.posts.filter(item =\u003e item.id !== action.meta.arg);\r\n      state.posts = newState;\r\n      return state;\r\n    },\r\n    /* Rejected */\r\n    [getPosts.rejected]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      state.error = action.payload;\r\n    },\r\n  },\r\n});\r\n\r\nexport default postsSlice.reducer;\r\n```\r\n\r\n이 상태에서 Postman을 통해 json 서버를 이용하기 때문에 BASE_URL은 로컬 경로로 설정해줬다.\r\n\r\nextraReducers 의 pending, fulfilled, rejected는 각각 대기중/성공/실패 정도로 생각하면 된다.\r\n\r\n아래와 같이 PostMan을 통해 db.json에 데이터가 정상적으로 확인되면\r\n\r\n포스트맨 사용법 : https://lee-yo-han.github.io/redux/redux와-mock-server-사용하기\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fri6Yi%2FbtrMjiBl1Va%2FlCNsQyz5vPTIhIfBFfpC41%2Fimg.png)\r\n\r\n아래와 같이 Redux hook을 통해 데이터를 자유롭게 사용할 수 있다.\r\n\r\n```javascript\r\nimport { getPosts } from \"../redux/modules/postSlice\";\r\nimport { useEffect } from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\"; // Redux hooks\r\n\r\nexport default function Home() {\r\n  const data = useSelector(state =\u003e state.posts.posts); // postSlice에 있는 전역 State 가져오기\r\n  const dispatch = useDispatch(); //dispatch 사용 준비\r\n\r\n  useEffect(() =\u003e {\r\n    dispatch(getPosts()); // dispatch 사용 dispatch(액션함수())\r\n  }, []);\r\n\r\n  console.log(data);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eredux랑 포스팅CRUD\u003c/p\u003e\r\n      \u003cp\u003e데이터를 주세욥\u003c/p\u003e\r\n      \u003cul\u003e\r\n        {data.map(item =\u003e (\r\n          \u003cli\u003e\r\n            \u003cspan\u003e{item.id}\u003c/span\u003e\r\n            \u003cspan\u003e{item.nickname}\u003c/span\u003e\r\n            \u003cspan\u003e{item.content}\u003c/span\u003e\r\n          \u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n위의 코드에서는 액션 함수의 인자(괄호())가 비어있지만, Slice에 원하는 액션 함수들을 작성한 후 dispatch를 해줄때 데이터가 필요한 경우는 아래의 순서로 데이터가 처리된다고 생각하면 좋다.\r\n\r\n### 데이터 처리 순서\r\n\r\n```javascript\r\n\r\n// jsx component\r\ndispath(액션함수(id등의 데이터))\r\n\r\n// =\u003e postSlice 파일 내의 액션 함수\r\nexport const addPosts = createAsyncThunk(\r\n    \"POST_Posts\",\r\n    async (payload, thunkAPI) =\u003e { // payload를 통해 데이터를 받고 아래 코드에서 처리할 수 있도록 함\r\n      try {\r\n        const { data } = await axios.post(`${BASE_URL}/posts`, payload);\r\n        console.log(\"data\", data);\r\n        return thunkAPI.fulfillWithValue(data); // 요청 성공 부분\r\n      } catch (errer) {\r\n        return thunkAPI.rejectWithValue(errer);\r\n      }\r\n    }\r\n  );\r\n\r\n// =\u003e extraReducers\r\nexport const postsSlice = createSlice({\r\n  name: \"posts\",\r\n  initialState,\r\n  reducers: {},\r\n  extraReducers: {\r\n    // ---- 생략 ----\r\n    /* Fulfilled */\r\n    [addPosts.fulfilled]: (state, action) =\u003e { // 요청 성공 시, action 인자를 통해 state(전역 상태)를 관리해줄 수 있음 (ex action.payload .---)\r\n      state.isLoading = false;\r\n      state.posts.push(action.payload);\r\n    },\r\n    // ---- 생략 ----\r\n```\r\n\r\n데이터가 정상적으로 화면으로 출력되는 것을 볼 수 있다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKVbGZ%2FbtrMljZJHmV%2F3XHhLVMqFgXEAjz2HqKky0%2Fimg.png)\r\n\r\n단, useSelector를 사용할 때, (state)=\u003estate... 부분은 데이터에 따라 값의 구조가 다를 수 있기 때문에, console.log()를 통해 데이터를 어떻게 받아오는지 확인하며 코드를 작성해주자.\r\n\r\n## 간단한 CRUD 적용 예시\r\n\r\n![image](https://blog.kakaocdn.net/dn/bDrG2e/btrMjWLhmxB/gsemxzlV7oyCzREe8oHOM1/img.gif)\r\n\r\n## AsyncThunk를 사용한다는 것은\r\n\r\n공식문서 : https://redux-toolkit.js.org/api/createAsyncThunk\r\n\r\n공식 문서에 반환된 Promise를 기반으로 LifeCycle 작업을 전달하는 Thunk 작업 생성자를 반환해 비동기 요청 LifeCycle을 처리하기 위한 표준 권장 접근 방식을 추상화한다는 내용이 있다\r\n\r\n이것은 위의 데이터 처리 순서로 설명한 것과 유사하다.\r\n\r\n```javascript\r\n\r\nexport const addPosts = createAsyncThunk(\r\n    \"POST_Posts\",\r\n    async (payload, thunkAPI) =\u003e {\r\n      try {\r\n        const { data } = await axios.post(`${BASE_URL}/posts`, payload);\r\n        console.log(\"data\", data);\r\n        return thunkAPI.fulfillWithValue(data);\r\n      } catch (errer) {\r\n        return thunkAPI.rejectWithValue(errer);\r\n      }\r\n    }\r\n  );\r\n\r\n  ↑↑↑ 이 부분에서 Promise를 반환해주고\r\n\r\n\r\n\r\n\r\n ↓↓↓↓ 이 부분에서 대기/성공/실패 로 구분해 데이터를 처리해준다\r\n\r\n //Panding\r\n //Fulfilled\r\n ...\r\n\r\n [addPosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      state.posts.push(action.payload); // 게시글을 추가했을때 처리해주는 방식\r\n    },\r\n\r\n ...\r\n //Rejected\r\n\r\n```\r\n\r\n# 전체 예제코드\r\n\r\n```javascript\r\n// Home.jsx\r\n\r\nimport {\r\n  deletePosts,\r\n  getPosts,\r\n  updatePosts,\r\n  addPosts,\r\n} from \"../redux/modules/postSlice\";\r\n\r\nimport { useState, useEffect } from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\n\r\nexport default function Home() {\r\n  const [inputValue, setInputValue] = useState();\r\n\r\n  const data = useSelector(state =\u003e state.posts.posts);\r\n  const dispatch = useDispatch();\r\n  useEffect(() =\u003e {\r\n    dispatch(getPosts());\r\n  }, []);\r\n  console.log(data);\r\n\r\n  const addButton = () =\u003e {\r\n    let addData = {\r\n      nickname: \"한삐\",\r\n      content: inputValue,\r\n    };\r\n    dispatch(addPosts(addData));\r\n  };\r\n\r\n  const deletButton = props =\u003e {\r\n    dispatch(deletePosts(props));\r\n  };\r\n\r\n  const editButton = props =\u003e {\r\n    let updateData = {\r\n      id: props,\r\n      nickname: \"한삐\",\r\n      content: \"냠냠1231241214\",\r\n    };\r\n    dispatch(updatePosts(updateData));\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eredux랑 포스팅CRUD\u003c/p\u003e\r\n      \u003cp\u003e데이터를 주세욥\u003c/p\u003e\r\n      \u003cinput onChange={e =\u003e setInputValue(e.target.value)} type=\"text\" /\u003e\r\n      \u003cbutton onClick={addButton}\u003e글쓰기\u003c/button\u003e\r\n      \u003cul\u003e\r\n        {data.map(item =\u003e (\r\n          \u003cli key={item.id}\u003e\r\n            \u003cdiv\u003e\r\n              \u003cspan\u003e{item.id}\u003c/span\u003e\r\n              \u003cbr /\u003e\r\n              \u003cspan\u003e{item.nickname}\u003c/span\u003e\r\n              \u003cbr /\u003e\r\n              \u003cspan\u003e{item.content}\u003c/span\u003e\r\n              \u003cbr /\u003e\r\n            \u003c/div\u003e\r\n            \u003cdiv\u003e\r\n              \u003cbutton onClick={() =\u003e editButton(item.id)}\u003e수정\u003c/button\u003e\r\n              \u003cbutton onClick={() =\u003e deletButton(item.id)}\u003e삭제\u003c/button\u003e\r\n            \u003c/div\u003e\r\n          \u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n```javascript\r\n// store.js\r\nimport { configureStore } from \"@reduxjs/toolkit\";\r\nimport posts from \"./modules/postSlice\";\r\n\r\nconst store = configureStore({\r\n  reducer: {\r\n    posts,\r\n  },\r\n});\r\n\r\nexport default store;\r\n```\r\n\r\n```javascript\r\n// postSlice.js\r\n\r\nimport { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\r\nimport { current } from \"@reduxjs/toolkit\";\r\nimport axios from \"axios\";\r\n\r\nconst BASE_URL = \"http://localhost:3001\";\r\n\r\nconst initialState = {\r\n  // data, isLoading, error로 상태관리\r\n  posts: [],\r\n  isLoading: false,\r\n  error: null,\r\n};\r\n\r\nexport const getPosts = createAsyncThunk(\r\n  \"GET_ALL_Posts\",\r\n  async (payload, thunkAPI) =\u003e {\r\n    try {\r\n      const { data } = await axios.get(`${BASE_URL}/posts`);\r\n      return thunkAPI.fulfillWithValue(data);\r\n    } catch (error) {\r\n      return thunkAPI.rejectWithValue(error);\r\n    }\r\n  },\r\n);\r\n\r\nexport const addPosts = createAsyncThunk(\r\n  \"POST_Posts\",\r\n  async (payload, thunkAPI) =\u003e {\r\n    try {\r\n      const { data } = await axios.post(`${BASE_URL}/posts`, payload);\r\n      console.log(\"data\", data);\r\n      return thunkAPI.fulfillWithValue(data);\r\n    } catch (errer) {\r\n      return thunkAPI.rejectWithValue(errer);\r\n    }\r\n  },\r\n);\r\n\r\nexport const updatePosts = createAsyncThunk(\r\n  \"UPDATAE_Posts\",\r\n  async (payload, thunkAPI) =\u003e {\r\n    try {\r\n      console.log(payload);\r\n      const { data } = await axios.put(\r\n        `${BASE_URL}/posts/${payload.id}`,\r\n        payload,\r\n      );\r\n      console.log(\"data\", DataTransfer);\r\n      return thunkAPI.fulfillWithValue(data.data);\r\n    } catch (error) {\r\n      return thunkAPI.rejectWithValue(error);\r\n    }\r\n  },\r\n);\r\n\r\nexport const deletePosts = createAsyncThunk(\r\n  \"DELETE_posts\",\r\n  async (payload, thunkAPI) =\u003e {\r\n    try {\r\n      await axios.delete(`${BASE_URL}/posts/${payload}`);\r\n      return thunkAPI.fulfillWithValue(payload);\r\n    } catch (error) {\r\n      return thunkAPI.rejectWithValue(error);\r\n    }\r\n  },\r\n);\r\n\r\nexport const postsSlice = createSlice({\r\n  name: \"posts\",\r\n  initialState,\r\n  reducers: {},\r\n  extraReducers: {\r\n    /* Pending */\r\n    [getPosts.pending]: (state, action) =\u003e {\r\n      state.isLoading = true;\r\n    },\r\n    [addPosts.pending]: (state, action) =\u003e {\r\n      state.isLoading = true;\r\n    },\r\n    [deletePosts.pending]: (state, action) =\u003e {\r\n      state.isLoading = true;\r\n    },\r\n    /* Fulfilled */\r\n    [getPosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      console.log(action);\r\n      state.posts = [...action.payload];\r\n    },\r\n    [addPosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      state.posts.push(action.payload);\r\n    },\r\n    [updatePosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      console.log(action);\r\n      const newState = state.posts.map(item =\u003e\r\n        action.meta.arg.id === item.id\r\n          ? { ...item, content: action.meta.arg.content }\r\n          : item,\r\n      );\r\n      state.posts = newState;\r\n      return state;\r\n    },\r\n    [deletePosts.fulfilled]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      const newState = state.posts.filter(item =\u003e item.id !== action.meta.arg);\r\n      state.posts = newState;\r\n      return state;\r\n    },\r\n    /* Rejected */\r\n    [getPosts.rejected]: (state, action) =\u003e {\r\n      state.isLoading = false;\r\n      state.error = action.payload;\r\n    },\r\n  },\r\n});\r\n\r\nexport default postsSlice.reducer;\r\n```\r\n"},{"title":"redux typescript react reduxtoolkit","description":"Typescript react에서 ReduxToolkit 사용해보기","category":"redux","keyword":"redux, reduxtoolkit","date":"2023-03-04","content":"\r\njavascript에서의 ReduxToolkit 사용 예제 : https://lee-yo-han.github.io/redux/redux-toolkit-사용해보기\r\n\r\n## 1. 설치\r\n\r\n```bash\r\nyarn add @reduxjs/toolkit react-redux\r\n```\r\n\r\n## 2. store 설정\r\n\r\nstate와 dispatch type 생성\r\n\r\n```typescript\r\n// store.ts\r\nimport { configureStore } from \"@reduxjs/toolkit\";\r\nimport commentSlice from \"./commentSlice\";\r\n\r\nconst store = configureStore({\r\n  reducer: {\r\n    commentSlice,\r\n  },\r\n});\r\nexport default store;\r\n\r\nexport type RootState = ReturnType\u003ctypeof store.getState\u003e; // 1. state type 가져오기\r\nexport type AppDispatch = typeof store.dispatch; // 2. dispatch type 가져오기\r\n```\r\n\r\n## 3. Redux hook 설정\r\n\r\ndispatch 함수와 useSelector 실행을 위해, Redux hook을 따로 설정해준다.\r\n\r\n```typescript\r\n// useRedux.ts\r\n\r\nimport type { TypedUseSelectorHook } from \"react-redux\";\r\nimport type { RootState, AppDispatch } from \"../redux/store\"; // store에서 미리 설정해준 state와 dispatch type\r\n\r\nexport const useAppDispatch: () =\u003e AppDispatch = useDispatch;\r\nexport const useAppSelector: TypedUseSelectorHook\u003cRootState\u003e = useSelector;\r\n```\r\n\r\n위의 설정을 마치면 javascript에서 dispatch를 사용하는 것과 같이 사용할 수 있다.\r\n\r\n```typescript\r\n\r\n// Form.tsx\r\nimport { useAppDispatch, useAppSelector } from \"../hook/useRedux\";\r\nimport { FormEvent } from \"../type\"; // 별도로 지정한 eventType\r\nimport { addComments } from \"../redux/commentSlice\"; // Slice의 action함수\r\n\r\nexport const Form = () =\u003e {\r\n\tconst dispatch = useAppDispatch();\r\n\r\n    const formData = {...}\r\n\r\n    const onSubmitHandler = async (e: FormEvent, dispatch: any) =\u003e {\r\n        e.preventDefault();\r\n        dispatch(addComments(formData)); // 정상작동\r\n    };\r\n\r\n    return ( ...\r\n}\r\n\r\n```\r\n\r\n참고 : https://redux-toolkit.js.org/usage/usage-with-typescript\r\n"},{"title":"redux usage","description":"redux 사용해보기","category":"redux","keyword":"redux사용법","date":"2023-03-04","content":"\r\n# React에서 Redux 사용해보기\r\n\r\n리덕스 툴킷 x\r\n\r\n## Redux 설치\r\n\r\n```bash\r\nyarn add redux react-redux\r\n```\r\n\r\n1. src 디렉토리 안에 redux 폴더 생성\r\n2. redux 폴더 안에 config, modules 폴더 생성 (생성할 state들의 그룹)\r\n3. modules 폴더 안 store.js 생성\r\n   \u003e 폴더/파일 명은 목적이나 폴더 구조에 맞춰 자유롭게 생성해줘도 괜찮다.\r\n\r\n## 스토어 생성\r\n\r\n```javascript\r\n// src/configStore.js\r\n\r\nimport { createStore, combineReducers } from \"redux\";\r\nimport todo from \"./modules/todo\"; // 모듈에 있는 reducer 불러오기\r\n\r\nconst rootReducer = combineReducers({});\r\nconst store = createStore(rootReducer);\r\n\r\nexport default store;\r\n```\r\n\r\n## 스토어 연동\r\n\r\n```javascript\r\n// 디렉토리 최상단 파일 ex/ index.js or app.js\r\n\r\nimport store from \"./redux/config/configStore\";\r\nimport { Provider } from \"react-redux\";\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\r\nroot.render(\r\n  //App을 Provider로 감싸주고, configStore에서 export default 한 store를 넣어준다.\r\n  \u003cProvider store={store}\u003e\r\n    \u003cApp /\u003e\r\n  \u003c/Provider\u003e,\r\n);\r\nreportWebVitals();\r\n```\r\n\r\n## reducer 편집\r\n\r\n```javascript\r\n// 예제\r\n// todo.js - ./modules에 있는 파일\r\n\r\n// Actions\r\nconst CREATE = \"my-app/todo/CREATE\";\r\nconst REMOVE = \"my-app/todo/REMOVE\";\r\n\r\n// Reducer\r\n//action이 없으면 state는 아래 initialState의 초기값, 있으면 action 값\r\nexport default function reducer(state = initialState, action = {}) {\r\n  switch (action.type) {\r\n    case CREATE: {\r\n      const new_todo_list = [...state.todos, action.todo];\r\n      return { todos: new_todo_list };\r\n    }\r\n    case REMOVE: {\r\n      const new_todo_list = action.todo;\r\n      return { todos: new_todo_list };\r\n    }\r\n\r\n    // ...etc\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// Action Creators\r\nexport function createTodo(todo) {\r\n  console.log(\"create 액션 생성\");\r\n  return { type: CREATE, todo };\r\n}\r\n\r\nconst initialState = {\r\n  // createTodo(todo)의 초기값 설정\r\n  todos: [\r\n    {\r\n      id: 1,\r\n      name: \"qwert\",\r\n    },\r\n    {\r\n      id: 2,\r\n      name: \"asdf\",\r\n    },\r\n  ],\r\n};\r\n\r\nexport function removeTodo(todo) {\r\n  console.log(\"remove 액션 생성\");\r\n  return { type: REMOVE, todo };\r\n}\r\n```\r\n\r\n## 컴포넌트에서의 사용\r\n\r\nreducer를 모두 작성해준 후 컴포넌트에서 사용할 수 있다.\r\n\r\n```javascript\r\n\r\n// 리덕스 훅\r\nimport {useSelector , useDispatch} from \"react-redux\";\r\n\r\n\r\nconst test = () =\u003e{\r\n\t// 해당 상수는 useSelector를 통해 reducer에 있는 state 값을 가져온다.\r\n\tconst testList = useSelector((state=\u003estate.todo.todos))\r\n    // 액션을 생성하기 위해 준비\r\n    const dispatch = useDispatch()\r\n\r\n    const addBtn = () =\u003e{\r\n    \t// ---실행하고싶은 코드들---\r\n        // -------------------------\r\n        // dispatch로 액션을 생성했으니, 원하는 처리는 reducer에서 입력하면 된다.\r\n        dispatch(createTodo(reducer에서 처리하고 싶은 값))\r\n    }\r\n    return(\r\n    \t\u003cdiv\u003e\u003c/div\u003e\r\n    )\r\n}\r\n\r\n```\r\n\r\n참조 : https://ko.redux.js.org/\r\n"},{"title":"react datepicker","description":"React datepicker 사용하기","category":"react","keyword":"react-datepicker","date":"2023-03-03","content":"\r\n# React Datepicker 사용하기\r\n\r\n공식 문서\r\n\r\nhttps://reactdatepicker.com/\r\n\r\n### package 설치\r\n\r\n```bash\r\nyarn add react-datepicker\r\n```\r\n\r\n패키지 설치 후 아래와 같이 import해 사용할 수 있다.\r\n\r\n```javascript\r\nimport DatePicker from \"react-datepicker\"; // 데이트픽커 import\r\nimport \"react-datepicker/dist/react-datepicker.css\"; // 데이트픽커 기본 CSS\r\nimport { ko } from \"date-fns/esm/locale\"; // 한국어 변환\r\n\r\nexport default function DatePickerTest() {\r\n  const [startDate, setStartDate] = useState(new Date());\r\n  const [endDate, setEndDate] = useState(null);\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003cDatePicker local={ko} /\u003e\r\n    \u003c/\u003e\r\n  );\r\n}\r\n```\r\n\r\n달력은 props 설정을 통해 다양한 방식의 달력을 설정해줄 수 있다.\r\n\r\n아래는 범위 지정 달력을 만드는 코드이다.\r\n\r\n```javascript\r\nexport default function DatePickerTest() {\r\n  const [startDate, setStartDate] = useState(new Date());\r\n  const [endDate, setEndDate] = useState(null);\r\n\r\n  const onChange = dates =\u003e {\r\n    const [start, end] = dates;\r\n    setStartDate(start);\r\n    setEndDate(end);\r\n  };\r\n\r\n  return (\r\n    \u003cDatePicker\r\n      elected={startDate}\r\n      onChange={onChange}\r\n      startDate={startDate}\r\n      endDate={endDate}\r\n      locale={ko}\r\n      selectsRange\r\n      inline\r\n    /\u003e\r\n  );\r\n}\r\n```\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F5DkxI%2FbtrMUTz6YZb%2FpYNfcGfYjpM5GZlENLALTk%2Fimg.png)\r\n\r\n위 코드는 selectsRange라는 속성의 달력을 이용한다.\r\n다양한 속성은 상단의 공식 페이지 링크를 참고하면 좋다.\r\n\r\n## 스타일 적용\r\n\r\ncustom header 같은 props 옵션 등을 통해 css 스타일을 줄 수 있지만, 스타일이 원하는대로 입히기 어려운 점도 있었고 전체적인 코드가 보기 불편하다는 생각이 들어 styled component를 통해 css를 적용해줬다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzDzqF%2FbtrMWeKqb6T%2FkKiJfjfF1fP7vPcnWpyHOK%2Fimg.png)\r\n\r\n```javascript\r\n\r\nconst StyledDatePickerWrapper = styled.section`\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 300px;\r\n  height: 380px;\r\n  border-radius: 20px;\r\n  box-shadow: 0 0 5px 0 rgb(71, 181, 255);\r\n\r\n  .react-datepicker {\r\n    background-color: white;\r\n    border-color: rgb(198, 232, 255);\r\n    border-radius: 20px;\r\n  }\r\n\r\n  /* ... */\r\n\r\n```\r\n\r\n코드가 길어지더라도 jsx와 철저하게 분리하고 싶다면 이런 방법도 나쁘지 않은 것 같다.\r\n"},{"title":"react media query","description":"React mediaQuery 사용법","category":"react","keyword":"react, mediaQuery","date":"2023-03-03","content":"\r\n# react-responsive 사용해보기\r\n\r\n공식 사이트 : https://yarnpkg.com/package/react-responsive\r\n\r\nCSS의 mediaQuery를 사용해볼 수도 있지만, 간편하게 적용할 수 있는 패키지가 있어서 사용해봤다.\r\n\r\n### 패키지 설치\r\n\r\n```bash\r\nyarn add react-responsive\r\n```\r\n\r\n### useMediaQuery 세팅\r\n\r\n```javascript\r\n// useMideaQuery.js\r\n\r\nimport { useMediaQuery } from \"react-responsive\";\r\n\r\nexport const Desktop = ({ children }) =\u003e {\r\n  const isDesktop = useMediaQuery({\r\n    minWidth: 481,\r\n  });\r\n  return isDesktop ? children : null;\r\n};\r\n\r\nexport const Mobile = ({ children }) =\u003e {\r\n  const isMobile = useMediaQuery({ maxWidth: 480 });\r\n  return isMobile ? children : null;\r\n};\r\n```\r\n\r\n위의 경우 모바일과 PC만 나눴지만 대략적인 분기점은 아래와 같이 설정해도 괜찮다\r\n\r\n1. 낮은 해상도의 PC, 태블릿 가로 : ~1024px\r\n2. 태블릿 가로 : 768px ~ 1023px\r\n3. 모바일 가로, 태블릿 : 480px ~ 767px\r\n4. 모바일 : ~480\r\n\r\n### useMediaQuery 사용\r\n\r\n```javascript\r\n// Responsive.jsx\r\n\r\nimport { Desktop, Mobile } from \"../../hooks/useMideaQuery\";\r\n\r\nexport const Responsive = () =\u003e {\r\n  return (\r\n    \u003c\u003e\r\n      \u003cDesktop\u003e\r\n        \u003cdiv\u003ePC화면\u003c/div\u003e\r\n      \u003c/Desktop\u003e\r\n      \u003cMobile\u003e\r\n        \u003cdiv\u003e모바일화면\u003c/div\u003e\r\n      \u003c/Mobile\u003e\r\n    \u003c/\u003e\r\n  );\r\n};\r\n```\r\n\r\n편의상 한 컴포넌트에 다 집어넣을 수도 있지만, 모바일과 데스크탑 환경의 view는 아예 다른 경우가 많기 때문에, 코드 관리를 편하게 하기 위해서는 모바일 컴포넌트를 따로 만드는게 더 나을 것 같다는 생각이 든다.\r\n"},{"title":"react modal non library","description":"라이브러리 없이 React Modal 만들기","category":"react","keyword":"react, modal","date":"2023-03-03","content":"\r\n# 라이브러리 없이 모달창 만들어보기\r\n\r\n모달 버튼이 있는 페이지\r\n\r\n```javascript\r\n// ModalTest.jsx\r\n\r\nimport ModalPage from \"./ModalPage\";\r\nimport { useState } from \"react\";\r\n\r\nexport default function ModalTest() {\r\n  // 모달을 보여줄지 말지 상태를 관리하는 state를 만들어준다.\r\n  const [showModal, setShowModal] = useState(false);\r\n\r\n  // 모달 버튼을 클릭하면 열리고\r\n  const openModal = () =\u003e {\r\n    setShowModal(true);\r\n  };\r\n  // 활성화된 모달창 밖을 클릭하면 닫힌다.\r\n  const closeModal = () =\u003e {\r\n    setShowModal(false);\r\n  };\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003cbutton onClick={openModal}\u003e모달이에옹\u003c/button\u003e\r\n      // 모달상태가 true면 ModalPage를 보여주고, 아니면 null // props로 showModal과\r\n      closeModal을 전달한다.\r\n      {showModal === true ? (\r\n        \u003cModalPage showModal={showModal} closeModal={closeModal} /\u003e\r\n      ) : null}\r\n    \u003c/\u003e\r\n  );\r\n}\r\n```\r\n\r\n모달 컴포넌트\r\n\r\n```javascript\r\nimport styled from \"styled-components\";\r\n\r\nexport default function ModalPage({ showModal, closeModal }) {\r\n  return (\r\n    // 모달 밖을 클릭하면 모달창을 닫게 만든다.\r\n    \u003cStyledModalBackground onClick={closeModal}\u003e\r\n      // stopPropagation은 부모태그로부터의 이벤트 전파를 중지시킨다. // 이\r\n      친구가 없으면 모달창 안쪽을 클릭해도 closeModal이 실행된다.\r\n      \u003cStyledModalContainer onClick={e =\u003e e.stopPropagation()}\u003e\r\n        \u003cStyledModal\u003e열린 모달창이에옹\u003c/StyledModal\u003e\r\n      \u003c/StyledModalContainer\u003e\r\n    \u003c/StyledModalBackground\u003e\r\n  );\r\n}\r\n\r\n// 위치를 대략 가운대로 정해주고\r\nconst StyledModalContainer = styled.div`\r\n  position: fixed;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n`;\r\n\r\n// 모달 밖 배경색은 우리에게 익숙한 어두운 색으로 만들어주자\r\nconst StyledModalBackground = styled.div`\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  bottom: 0;\r\n  right: 0;\r\n  background-color: rgba(0, 0, 0, 0.4);\r\n  z-index: 0;\r\n  cursor: auto;\r\n`;\r\n\r\n// 모달창 사이즈는 용도에 맞춰 설정해준다.\r\nconst StyledModal = styled.div`\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: white;\r\n`;\r\n```\r\n\r\n브라우저 화면\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOLJGf%2FbtrNjUdVndT%2FvgVskBO2xWeRwi01YQPzkk%2Fimg.png)\r\n\r\n스타일은 용도에 맞게 다양하게 변경시킬 수 있다.\r\n"},{"title":"react navigate props","description":"React navigate로 props 넘기기","category":"react","keyword":"react, navigate, props","date":"2023-03-03","content":"\r\n# useNavigate를 이용한 props 전달\r\n\r\n### useNavigate로 다른 페이지의 화면으로 이동할 때, props처럼 값을 넘기는 방법을 사용해볼 수 있다.\r\n\r\n```javascript\r\n\r\n// 보내는컴포넌트.jsx\r\n\r\nimport { useNavigate } from \"react-router-dom\";\r\n\r\nconst Component1 = () =\u003e {\r\nconst navigate = useNavigate()\r\n\r\nlet someDatas = {\r\n\tname:\"hihi\"\r\n    value:\"here\"\r\n}\r\n\r\nreturn\r\n\u003cdiv onClick={() =\u003e navigate(`/다른페이지주소`,{ state: someDatas });}\u003e\r\n\t다른페이지로 이동\r\n\u003c/div\u003e\r\n}\r\n\r\n\r\n\r\n// 받는 컴포넌트.jsx\r\n\r\nimport { useLocation } from \"react-router-dom\";\r\n\r\nconst Component2 = () =\u003e {\r\n\tconst location = useLocation();\r\n\tconsole.log(location);\r\n}\r\n\r\n```\r\n\r\n위와 같이 작성은 아래와 같이 데이터를 받아오는 것을 보여준다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FedpbW9%2FbtrRGwsRGuz%2FKp5GIecYeABXw1FPbGLdsK%2Fimg.png)\r\n\r\n하지만 데이터를 받는 페이지가 직접적으로 접속할 수 있는 페이지라면 그렇게 접속한 페이지는 아무 데이터가 없는 화면으로 노출될 수 있기 때문에, 전역 상태를 관리해줄지, 데이터를 넘겨줄지 상황에 알맞는 방식을 적용하는 것이 중요하다.\r\n"},{"title":"react simple formdata code","description":"react formdata 코드간소화","category":"react","keyword":"react, 코드 간소화","date":"2023-03-03","content":"\r\n# FormData 저장 코드 간소화하기\r\n\r\n하나의 폼에서 여러 개의 input 값을 변경하기 위해 함수를 만들어 간단하게 코드를 간소화시킬 수 있다.\r\n\r\n```typescript\r\n// form.tsx\r\n\u003cContainer onSubmit={e =\u003e onSubmitHandler(e, dispatch)}\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"profile_url\"\r\n    placeholder=\"https://picsum.photos/id/1/50/50 - 필수 X\"\r\n    value={formData.profile_url}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"author\"\r\n    placeholder=\"작성자\"\r\n    value={formData.author}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n    required\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003ctextarea\r\n    name=\"content\"\r\n    placeholder=\"내용\"\r\n    value={formData.content}\r\n    onChange={e =\u003e onChangeHandler(e)}\r\n    required\r\n  \u003e\u003c/textarea\u003e\r\n  \u003cbr /\u003e\r\n  \u003cinput\r\n    type=\"text\"\r\n    name=\"createdAt\"\r\n    placeholder={`${todayDate()}`}\r\n    disabled\r\n    required\r\n  /\u003e\r\n  \u003cbr /\u003e\r\n  \u003cbutton type=\"submit\"\u003e{isEdit ? \"수정하기\" : \"등록\"}\u003c/button\u003e\r\n\u003c/Container\u003e;\r\n\r\n// useForm.tsx\r\nconst [formData, setFormData] = useState\u003cFormData\u003e({\r\n  profile_url: \"\",\r\n  author: \"\",\r\n  content: \"\",\r\n  createdAt: todayDate(),\r\n});\r\n\r\nconst onChangeHandler = (e: InputEvent) =\u003e {\r\n  let type = e.target.name;\r\n  let value = e.target.value;\r\n  if (type === \"profile_url\")\r\n    setFormData(prev =\u003e ({ ...prev, profile_url: value }));\r\n  if (type === \"author\") setFormData(prev =\u003e ({ ...prev, author: value }));\r\n  if (type === \"content\") setFormData(prev =\u003e ({ ...prev, content: value }));\r\n  setFormData(prev =\u003e ({ ...prev, [type]: value }));\r\n};\r\n```\r\n\r\n하지만 위와 같이 if문이 많아져 코드의 성능과 가독성을 떨어뜨릴 수 있기 때문에, 아래와 같이 변경해볼 수 있다.\r\n\r\n```typescript\r\n// useForm.tsx\r\n\r\nconst [formData, setFormData] = useState\u003cFormData\u003e({\r\n  profile_url: \"\",\r\n  author: \"\",\r\n  content: \"\",\r\n  createdAt: todayDate(),\r\n});\r\n\r\nconst onChangeHandler = (e: InputEvent) =\u003e {\r\n  const { name, value } = e.target.name;\r\n  setFormData(prev =\u003e ({ ...prev, [name]: value }));\r\n};\r\n```\r\n\r\nhtml input의 name 속성을 이용해 setState 코드를 간소화시킬 수 있는 방법이다.\r\n"},{"title":"react styled components hover","description":"react에 styled-components를 이용해 hover 적용하기","category":"react","keyword":"react, hover","date":"2023-03-03","content":"\r\n# 리액트 스타일 컴포넌트에 hover 적용하기\r\n\r\n```typescript\r\n// \u0026:hover를 넣는다.\r\n\r\nconst ButtonStyle = styled.button`\r\n  \u0026:hover {\r\n    background-color: skyblue;\r\n    color: blue;\r\n  }\r\n`;\r\n```\r\n\r\n비슷한 상황에서 a 태그를 사용할때 자동으로 설정되는 스타일도 수정해줄 수 있다.\r\n\r\n```typescript\r\nconst LinkTag = styled.a`\r\n  /* 밑줄 제거 */\r\n  text-decoration: none;\r\n\r\n  /* 마우스를 링크에 올려뒀을 때의 스타일 */\r\n  \u0026:hover {\r\n  }\r\n  /* 아직 방문하지 않은 링크의 스타일 */\r\n  \u0026:link {\r\n  }\r\n  /* 사용자가 방문한 적이 있는(클릭한 이후) 링크의 스타일 */\r\n  \u0026:visited {\r\n  }\r\n  /* 마우스로 링크를 클릭하고 뗄 때까지의 스타일 */\r\n  \u0026:active {\r\n  }\r\n`;\r\n```\r\n"},{"title":"react submit prevent default","description":"form 태그에서 submit 이벤트 방지하기","category":"react","keyword":"form이벤트, submit 방지","date":"2023-03-03","content":"\r\n# react form에서 submit 이벤트 방지하기\r\n\r\n### submit 이벤트가 발생하면 페이지가 새로고침이 된다.\r\n\r\n단순히 페이지가 리프레시 되는 것도 좋은 사용자 경험이 아닌데, 임시로 저장돼있던 데이터(회원가입 정보 등)가 날아가면 React의 작동 방식을 거스를 뿐 아니라 사용자 경험에도 치명적이다.\r\n\r\n떄문에 우리는 sumbit 이벤트를 멈춰줄 필요가 있다.\r\n\r\n```javascript\r\nconst Header = () =\u003e {\r\n  const onSubmit = e =\u003e {\r\n    e.preventDefault(); // 해당 코드로 이벤트를 멈춰줄 수 있다.\r\n  };\r\n\r\n  return (\r\n    \u003cform\u003e\r\n      \u003cinput type=\"text\" /\u003e\r\n      // 버튼 타입도 submit으로 꼭 변경해준다.\r\n      \u003cbutton type=\"submit\" onSubmit={e =\u003e onSubmit(e)}\u003e\r\n        입력\r\n      \u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n};\r\n```\r\n\r\n위와 같이 작성하면 같은 폼 안에 있는 경우에 대해 submit 방지가 잘 되는 것을 확인할 수 있다.\r\n"},{"title":"react z index error","description":"z-index가 올바르게 적용되지 않을때 적용해볼 수 있는 방법","category":"react","keyword":"z-index","date":"2023-03-03","content":"\r\n# z-index 미적용시 해결방법\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2c0QV%2FbtrXD8G7Ar9%2FpCFQ6eujsGgA0bKCKx1kpk%2Fimg.png)\r\n\r\n위와 같이 z-index를 999로 적용해도 원하는대로 작동하지 않는 경우를 볼 수 있다.\r\n\r\n### MDN 공식 문서 : https://developer.mozilla.org/ko/docs/Web/CSS/z-index\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8pPBj%2FbtrXCijsq0h%2FkdCdCRUKvZIGe7dk8KPJf0%2Fimg.png)\r\n\r\n해당 사진의 마지막 줄의 \"자손의 z-index를 자기 외의 바깥 요소와 비교하지 않습니다.\" 이 부분으로 인한 문제로 생각됐다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fct1Z18%2FbtrXH8zek29%2Fjwx0ckk9YgnPRLS2sM06k0%2Fimg.png)\r\n\r\n부모 요소는 부모 요소끼리, 자식 요소는 자식 요소끼리 경쟁하기 때문에, 기존 코드는 이와 같이 HeaderNav 안에 SideMenu가 있어 HeaderNav 내에서만 z-index를 비교하고 있던 것이었다.\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbUIap4%2FbtrXCicOSRi%2FzWiWf6wrtlUx9aK2uYKK7K%2Fimg.png)\r\n\r\n이처럼 SideMenu를 HeaderNav 밖으로 빼주니, 아래와 같이 정상적으로 작동하는 모습을 볼 수 있었다.\r\n\r\n### 정상 적용된 화면\r\n\r\n![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\u0026fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FwMc3x%2FbtrXFupLVFz%2FWH6kLZ1IbRxHnXK2bqkHa0%2Fimg.png)\r\n\r\n## z-index가 제대로 작동하지 않을때 참고할만한 사항\r\n\r\n1. 부모 요소는 부모 요소끼리 경쟁되고 있는지 확인한다.\r\n2. Element가 static(position 속성의 default 값)이 아닌 position 속성이 설정되어있는지 확인한다.(relative, absolute, fixed, sticky)\r\n3. opacity나 transform과 같은 css 속성이 설정돼있는지 확인한다. 해당 css요소가 설정돼있다면 1번의 기준에 맞춰 코드를 다시 작성해준다.\r\n\r\n이정도면 버그를 수정하는데 충분하지만 더 싶도 깊은 내용은 아래를 참고해보면 좋을 것 같다.\r\n\r\n참조 : https://coder-coder.com/z-index-isnt-working/\r\n"},{"title":"typescript syntax","description":"Typescript 사용을 위한 기본적인 문법 정리","category":"typescript","keyword":"typescript, 문법","date":"2023-03-02","content":"\r\n# 기본 TypeScript 타입 선언\r\n\r\n```typescript\r\n\r\n// 문자열\r\nlet str: string = \"hello\";\r\n\r\n// 숫자\r\nlet num: number = 100;\r\n\r\n// 배열\r\nlet arr: Array\u003cnumber\u003e = [10,20,30];\r\nlet arr2: number[] = [10,20,30];\r\nlet arr3: Array\u003cstring\u003e = [\"hello\",\"hellololo\" ];\r\nlet arr4: [string, number] = [\"hello\", 182];\r\n\r\n// 객체\r\nlet obj:object = {name:\"hello\", age:29};\r\nlet person:{name: string, age:number};\r\n\r\n// Boolean\r\nlet isAvaliable: boolean = true;\r\n\r\n\r\n// 함수 선언\r\nparameter와 return 값에 대해 타입 선언 가능\r\nconst sum = (a:number, b:number):number =\u003e {\r\nreturn a+b;\r\n}\r\n\r\n// optional parameter일 경우 ?를 사용\r\n\r\nconst log = (time: string, result?: string, option?: string) =\u003e {\r\nconsole.log(time, result, option);\r\n}\r\nlog(\"2021-10-04\", \"success\");\r\n\r\n```\r\n\r\n# 인터페이스 (interface)\r\n\r\n### 자주 사용하는 타입들을 object 형태의 묶음으로 정의해 새로운 타입을 만들어 사용하는 기능\r\n\r\n```typescript\r\n\r\n// interface 선언\r\ninterface User {\r\nage: number;\r\nname: string;\r\n}\r\n\r\n// 변수 활용\r\nconst hanbbi: User = { age: 30, name: \"hello\"}\r\n\r\n\r\n// 함수 인자로의 활용\r\nconst getUser = (user:User){\r\nconsole.log(user);\r\n}\r\ngetUser({ age:10, name: \"hanbbi\" })\r\n\r\n\r\n\r\n// 함수 구조 활용\r\ninterface Sum {\r\n(a:number, b:number): number;\r\n}\r\n\r\nlet sumFinc: Sum:\r\nsumFunc = function(a: number, b: number): number {\r\nreturn a+b;\r\n}\r\n\r\n\r\n\r\n// 배열 활용\r\ninterface StringArray {\r\n[index:number]: string;\r\n}\r\n\r\nlet arr: StringArray = [\"a\", \"b\", \"c\"];\r\n\r\n\r\n// 객체 활용\r\ninterface StringRegexObject {\r\n[key: string]: RegExp;\r\n}\r\n\r\nconst obj: StringRegexObject {\r\ncssFile: /\\.css$/,\r\n   jsFile: /\\.js$/\r\n}\r\n\r\n\r\n// interface 확장 (extends 사용)\r\ninterface Person {\r\nname: string;\r\nage:number;\r\n}\r\ninterface Developer extends Person {\r\nskill: string;\r\n}\r\n\r\nconst juniorDeveloper = {\r\nname: \"hanbbi\",\r\nage:100,\r\nskill: \"JS\"\r\n}\r\n\r\n```\r\n\r\n# 타입 별칭(type aliases)\r\n\r\n### 타입 키워드는 interface와 다르게 새로운 타입을 생성하는 것이 아닌 별칭을 부여하는 것으로, extends 키워드는 사용할 수 없음\r\n\r\n```typescript\r\n\r\n// 타입 별칭 선언 및 활용\r\ntype MyString = string;\r\nconst str: MyString = \"Hello dear\"\r\n\r\ntype Todo = {\r\nid: string;\r\ntitle: string;\r\ndone: boolean\r\n}\r\n\r\nconst getTodo(todo:Todo){\r\nconsole.log(todo);\r\n}\r\n\r\n```\r\n\r\n# 연산자 (Operator)\r\n\r\n## Uinon Type\r\n\r\n### 한 가지 이상의 type을 선언하고자 할 때 사용 가능. | 기호 사용\r\n\r\n```typescript\r\nconst logMessage = (value: string | number) =\u003e {\r\n  if (typeof value === \"string\") {\r\n    value.toString();\r\n  } else if (typeof value === \"number\") {\r\n    value.toLocaleString();\r\n  } else {\r\n    throw new TypeError(\"value must be string or number\");\r\n  }\r\n};\r\nlogMessage(\"hello\");\r\nlogMessage(1000);\r\n```\r\n\r\n## intersection Type\r\n\r\n### 합집합과 같은 개념으로, 함수 호출의 경우 함수 인자에 명시한 type을 모두 제공해야 한다. \u0026 기호 사용\r\n\r\n```typescript\r\n\r\ninterface Zoo {\r\nname: string;\r\nlocation: string\r\nprice: number;\r\n}\r\n\r\ninterface Animal {\r\nname: string;\r\ncount: number;\r\n}\r\n\r\nconst askZookeeper = ( value : Zoo \u0026 Animal ) =\u003e {\r\n    // value 는\r\n    { name:\"어린이대공원\", location: \"서울시 광진구\", price: 10000, count: 10000}\r\n    // 와 같이 Zoo와 Animal이 모두 포함되는 인자를 줘야한다.\r\n}\r\n\r\n```\r\n\r\n# Enum\r\n\r\n### enum 키워드를 사용하면 일종의 default 값을 선언할 수 있다.\r\n\r\n```typescript\r\n\r\n// 숫자형 enum\r\n// 자동으로 0에서 1씩 증가하는 값을 부여\r\n\r\nenum Shoes {\r\nNike, // 0\r\nAdidas, // 1\r\nNewBalance //2\r\n}\r\nconst myShoes = Shoes.Nike; // 0\r\n\r\n문자형 enum\r\nenum Food {\r\ncake = \"케익\",\r\ncookie = \"쿠키\"\r\n}\r\nconst player = Food.cookie; // 쿠키\r\n\r\n```\r\n\r\n# 제네릭\r\n\r\n### 제네릭을 활용하면 인자를 넘겨 호출하는 시점에 타입을 결정할 수 있다. 제네릭 활용 시 동일한 기능을 하는 함수를 일일이 만들 필요가 없으며, 타입 추론에 있어 강점을 가진다.\r\n\r\n제네릭 선언\r\n\u003cT\u003e와 같이 타입을 선언한다. 알파벳은 통상 T로 정해져 있다.\r\n\r\n```typescript\r\n\r\nconst logText\u003cT\u003e = (text: T):T =\u003e {\r\nconsole.log(text);\r\nreturn text;\r\n}\r\nlogText\u003cstring\u003e(\"Hello hanbbi\");\r\n\r\n\r\n// interface에 제네릭 선언\r\n\r\ninterface Dropdown\u003cT\u003e {\r\nvalue: T;\r\nselected: boolean;\r\n}\r\ncosnt obj: Dropdown\u003cstring\u003e = { value: \"hamburger\" , selected: true};\r\n\r\n```\r\n\r\n# 제네릭 타입 제한\r\n\r\n## 1. 배열 힌트\r\n\r\n```typescript\r\n\r\nconst logTextLength\u003cT\u003e = (text: T[]): T[] =\u003e{\r\nconsole.log(text.length);\r\ntext.forEach(text =\u003e{\r\nconsole.log(text):\r\n});\r\n}\r\nlogTextLength\u003cstring\u003e([\"hi\", \"hello\"]);\r\n\r\n\r\n```\r\n\r\n## 2. 정의된 타입 이용(extends)과 keyof\r\n\r\n```typescript\r\n\r\ninterface ShoppingItem {\r\nname: string;\r\nprice: number;\r\nstock: number;\r\n}\r\n\r\nconst getShoppingItemOption\u003cT extends keyof ShoppinggItem\u003e(itemOption: T): T {\r\nreturn itemOption;\r\n}\r\n\r\n// \"name\", \"price\", \"stock\"만 인자로 가능\r\ngetShoppingItemOption(\"price\");\r\n\r\n```\r\n\r\n# 타입 추론 (Type inference)\r\n\r\n## 1. 기본 변수 타입 추론\r\n\r\n```typescript\r\n\r\n// string으로 추론\r\nlet a = \"abc\";\r\n\r\n// a: number로 추론\r\n// b: string으로 추론\r\n// return value는 string으로 추론\r\nconst getValue(a = 10) {\r\nlet b = \"hello\";\r\nreturn a + b;\r\n}\r\n\r\n\r\n```\r\n\r\n## 2. interface추론\r\n\r\n```typescript\r\n\r\n// interface 1개\r\ninterface Dropdown\u003cT\u003e {\r\nvalue: T;\r\ntitle: string;\r\n}\r\nconst shoppingItem:Dropdown\u003cnumber\u003e ={\r\nvalue: 10000;\r\ntitle: \"shoe\"\r\n}\r\n// interface 2개\r\ninterface Dropdown2\u003cT\u003e {\r\nvalue: T;\r\ntitle: string;\r\n}\r\ninterface DetailedDropdown\u003cK\u003e extends Dropdown2\u003cK\u003e{\r\ntag: K;\r\ndesc: string;\r\n}\r\nconst detailed: DetailedDropdown\u003cstring\u003e{\r\nvalue: \"10000\";\r\ntitle: \"shoe\",\r\ntag: \"10000\",\r\ndesc: \"description\"\r\n}\r\n\r\n```\r\n\r\n# 타입 단언 (Type assertion)\r\n\r\n### as 키워드를 사용해 타입을 정함으로써 typescript에게 타입을 알려줄 수 있다. 주로 DOM API를 조작할 떄 사용한다.\r\n\r\n```typescript\r\n// div가 있는지 장담할 수 없음, HTMLDivElement | null\r\n// 따라서 typescript에게 타입을 단언해 타입을 알려줄 수 있음.\r\nconst div = document.querySelector(\"div\") as HTMLDivElement;\r\ndiv.innerText = \"test\";\r\n```\r\n\r\n# 타입 가드 (Type guard)\r\n\r\n### union type을 사용하는 경우 공통된 속성만 접근 가능하며, 로직상 공통되지 않은 속성에 접근하고자 할 때 불편함을 해소하기 위해 타입 단언으로 공통되지 않은 속성에 접근하고자 하는 방법이 있지만, 코드 가독성을 위해 타입 가드 방법을 주로 사용한다.\r\n\r\n```typescript\r\nconst isDeveloper = (target: Developer | Humanoid): target is Developer =\u003e {\r\n  return (target as Developer).skill !== undefined;\r\n};\r\nif (isDeveloper(tom)) {\r\n  console.log(tom.name);\r\n  console.log(tom.skill);\r\n} else {\r\n  console.log(tom.name);\r\n  console.log(tom.age);\r\n}\r\n```\r\n\r\n# 타입 호환 (Type compatibility)\r\n\r\n### TypeScript에서 더 큰 타입 구조를 갖는 변수에 작은 타입 구조를 갖는 변수를 할당 가능\r\n\r\n```typescript\r\nlet add = function (a: number) {\r\n  // ...\r\n};\r\nlet sum = function (a: number, b: number) {\r\n  // ...\r\n};\r\n// 아래는 에러가\r\n// add = sum;\r\n\r\n// 에러가 나지 않는 방식. sum의 구조가 더 크다고 볼 수 있음\r\nsum = add;\r\n```\r\n\r\n참조 : https://yeomkyeorae.github.io/typesciprt/basic_typescript/\r\n"},{"title":"html input basic","description":"HTML input 속성 이용하기","category":"html","keyword":"html, input","date":"2023-02-09","content":"\r\n# Input element 사용하기\r\n\r\n## 타입\r\n\r\n- type=\"text\" 일반 텍스트\r\n- type=\"password\" 패스워드 형식(마스킹 처리)\r\n- type=\"eamil\" 이메일 형식\r\n- type=\"radio\" 설문 등 여러 선택지 중 하나의 값을 선택하는 형식\r\n- type=\"checkbox\" 설문 등 여러 선택지 중 여러 값을 선택하는 형식\r\n- type=\"number\" 숫자\r\n- type=\"file\" 파일 업로드\r\n- type=\"date\" 달력\r\n- type=\"range\" 볼륨 조절 위젯같이 값이 가려진 숫자를 입력하는 조작 가능\r\n\r\n## 속성\r\n\r\n- accept=\"업로드할 파일의 기댓값 암시\"\r\n- placeholder=\"input 안 힌트 텍스트\"\r\n- autofocus \"페이지 전환 시 자동으로 맨 처음 포커싱\"\r\n- required \"필수값\"\r\n- maxlength=\"최댓값\"\r\n- disabled \"비활성화\"\r\n- autocomplete=\"off\" \"브라우저의 자동완성 제거\"\r\n- checked \"radio나 checkbox 등의 체크 여부\"\r\n- name input의 이름으로 radio나 checkbox의 카테고리 묶음이나 javascript 이벤트 등을 유연하게 적용할 수 있음\r\n"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"7MVUNX53bjILeXNTpzEEK","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>